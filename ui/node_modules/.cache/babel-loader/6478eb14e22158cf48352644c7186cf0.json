{"ast":null,"code":"import { parse, GraphQLError, isNonNullType, Kind, valueFromAST, print, isObjectType, isListType, isSpecifiedDirective, astFromValue, isSpecifiedScalarType, isIntrospectionType, isInterfaceType, isUnionType, isInputObjectType, isEnumType, isScalarType, GraphQLDeprecatedDirective, specifiedRules, concatAST, validate, versionInfo, buildClientSchema, visit, TokenKind, Source, isTypeSystemDefinitionNode, getNamedType, GraphQLString, GraphQLNonNull, GraphQLList, GraphQLID, GraphQLBoolean, GraphQLFloat, GraphQLInt, GraphQLObjectType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLDirective, GraphQLUnionType, GraphQLEnumType, GraphQLScalarType, isNamedType, getNullableType, isLeafType, GraphQLSchema, isDirective, isCompositeType, doTypesOverlap, getOperationAST, getDirectiveValues, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST, isAbstractType, getOperationRootType, TypeNameMetaFieldDef, buildASTSchema } from 'graphql';\n\nconst asArray = fns => Array.isArray(fns) ? fns : fns ? [fns] : [];\n\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\n\nfunction isDocumentString(str) {\n  if (typeof str !== 'string') {\n    return false;\n  } // XXX: is-valid-path or is-glob treat SDL as a valid path\n  // (`scalar Date` for example)\n  // this why checking the extension is fast enough\n  // and prevent from parsing the string in order to find out\n  // if the string is a SDL\n\n\n  if (invalidDocRegex.test(str)) {\n    return false;\n  }\n\n  try {\n    parse(str);\n    return true;\n  } catch (e) {}\n\n  return false;\n}\n\nconst invalidPathRegex = /[‘“!%&^<=>`]/;\n\nfunction isValidPath(str) {\n  return typeof str === 'string' && !invalidPathRegex.test(str);\n}\n\nfunction compareStrings(a, b) {\n  if (String(a) < String(b)) {\n    return -1;\n  }\n\n  if (String(a) > String(b)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction nodeToString(a) {\n  var _a, _b;\n\n  let name;\n\n  if ('alias' in a) {\n    name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n  }\n\n  if (name == null && 'name' in a) {\n    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n  }\n\n  if (name == null) {\n    name = a.kind;\n  }\n\n  return name;\n}\n\nfunction compareNodes(a, b, customFn) {\n  const aStr = nodeToString(a);\n  const bStr = nodeToString(b);\n\n  if (typeof customFn === 'function') {\n    return customFn(aStr, bStr);\n  }\n\n  return compareStrings(aStr, bStr);\n}\n\nfunction isSome(input) {\n  return input != null;\n}\n\nfunction assertSome(input) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Value should be something';\n\n  if (input == null) {\n    throw new Error(message);\n  }\n}\n\nlet AggregateErrorImpl = globalThis.AggregateError;\n\nif (typeof AggregateErrorImpl === 'undefined') {\n  class AggregateErrorClass extends Error {\n    constructor(errors) {\n      let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      super(message);\n      this.errors = errors;\n      this.name = 'AggregateError';\n      Error.captureStackTrace(this, AggregateErrorClass);\n    }\n\n  }\n\n  AggregateErrorImpl = function (errors, message) {\n    return new AggregateErrorClass(errors, message);\n  };\n}\n\nfunction isAggregateError(error) {\n  return 'errors' in error && Array.isArray(error['errors']);\n} // Taken from graphql-js\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? `[function ${value.name}]` : '[function]';\n\n    case 'object':\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatError(value) {\n  if (value instanceof GraphQLError) {\n    return value.toString();\n  }\n\n  return `${value.name}: ${value.message};\\n ${value.stack}`;\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (value === null) {\n    return 'null';\n  }\n\n  if (value instanceof Error) {\n    if (isAggregateError(value)) {\n      return formatError(value) + '\\n' + formatArray(value.errors, previouslySeenValues);\n    }\n\n    return formatError(value);\n  }\n\n  if (previouslySeenValues.includes(value)) {\n    return '[Circular]';\n  }\n\n  const seenValues = [...previouslySeenValues, value];\n\n  if (isJSONable(value)) {\n    const jsonValue = value.toJSON(); // check for infinite recursion\n\n    if (jsonValue !== value) {\n      return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction isJSONable(value) {\n  return typeof value.toJSON === 'function';\n}\n\nfunction formatObject(object, seenValues) {\n  const entries = Object.entries(object);\n\n  if (entries.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  const properties = entries.map(_ref => {\n    let [key, value] = _ref;\n    return key + ': ' + formatValue(value, seenValues);\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getObjectTag(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    const name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getArgumentValues(def, node) {\n  let variableValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  const variableMap = Object.entries(variableValues).reduce((prev, _ref2) => {\n    let [key, value] = _ref2;\n    return { ...prev,\n      [key]: value\n    };\n  }, {});\n  const coercedValues = {}; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n  const argNodeMap = argumentNodes.reduce((prev, arg) => ({ ...prev,\n    [arg.name.value]: arg\n  }), {});\n\n  for (const {\n    name,\n    type: argType,\n    defaultValue\n  } of def.args) {\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (defaultValue !== undefined) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (variableValues == null || !variableMap[variableName]) {\n        if (defaultValue !== undefined) {\n          coercedValues[name] = defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(`Argument \"${name}\" has invalid value ${print(valueNode)}.`, valueNode);\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n\nfunction getDirectivesInExtensions(node) {\n  let pathToDirectivesInExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['directives'];\n  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);\n}\n\nfunction _getDirectiveInExtensions(directivesInExtensions, directiveName) {\n  const directiveInExtensions = directivesInExtensions.filter(directiveAnnotation => directiveAnnotation.name === directiveName);\n\n  if (!directiveInExtensions.length) {\n    return undefined;\n  }\n\n  return directiveInExtensions.map(directive => {\n    var _a;\n\n    return (_a = directive.args) !== null && _a !== void 0 ? _a : {};\n  });\n}\n\nfunction getDirectiveInExtensions(node, directiveName) {\n  let pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);\n\n  if (directivesInExtensions === undefined) {\n    return undefined;\n  }\n\n  if (Array.isArray(directivesInExtensions)) {\n    return _getDirectiveInExtensions(directivesInExtensions, directiveName);\n  } // Support condensed format by converting to longer format\n  // The condensed format does not preserve ordering of directives when  repeatable directives are used.\n  // See https://github.com/ardatan/graphql-tools/issues/2534\n\n\n  const reformattedDirectivesInExtensions = [];\n\n  for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {\n    if (Array.isArray(argsOrArrayOfArgs)) {\n      for (const args of argsOrArrayOfArgs) {\n        reformattedDirectivesInExtensions.push({\n          name,\n          args\n        });\n      }\n    } else {\n      reformattedDirectivesInExtensions.push({\n        name,\n        args: argsOrArrayOfArgs\n      });\n    }\n  }\n\n  return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);\n}\n\nfunction getDirectives(schema, node) {\n  let pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n\n  if (directivesInExtensions != null && directivesInExtensions.length > 0) {\n    return directivesInExtensions;\n  }\n\n  const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n  const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n    schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n    return schemaDirectiveMap;\n  }, {});\n  let astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [...astNodes, ...node.extensionASTNodes];\n  }\n\n  const result = [];\n\n  for (const astNode of astNodes) {\n    if (astNode.directives) {\n      for (const directiveNode of astNode.directives) {\n        const schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n\n        if (schemaDirective) {\n          result.push({\n            name: directiveNode.name.value,\n            args: getArgumentValues(schemaDirective, directiveNode)\n          });\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getDirective(schema, node, directiveName) {\n  let pathToDirectivesInExtensions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['directives'];\n  const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);\n\n  if (directiveInExtensions != null) {\n    return directiveInExtensions;\n  }\n\n  const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;\n\n  if (schemaDirective == null) {\n    return undefined;\n  }\n\n  let astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [...astNodes, ...node.extensionASTNodes];\n  }\n\n  const result = [];\n\n  for (const astNode of astNodes) {\n    if (astNode.directives) {\n      for (const directiveNode of astNode.directives) {\n        if (directiveNode.name.value === directiveName) {\n          result.push(getArgumentValues(schemaDirective, directiveNode));\n        }\n      }\n    }\n  }\n\n  if (!result.length) {\n    return undefined;\n  }\n\n  return result;\n}\n\nfunction parseDirectiveValue(value) {\n  switch (value.kind) {\n    case Kind.INT:\n      return parseInt(value.value);\n\n    case Kind.FLOAT:\n      return parseFloat(value.value);\n\n    case Kind.BOOLEAN:\n      return Boolean(value.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n      return value.value;\n\n    case Kind.LIST:\n      return value.values.map(v => parseDirectiveValue(v));\n\n    case Kind.OBJECT:\n      return value.fields.reduce((prev, v) => ({ ...prev,\n        [v.name.value]: parseDirectiveValue(v.value)\n      }), {});\n\n    case Kind.NULL:\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction getFieldsWithDirectives(documentNode) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = {};\n  let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n\n  if (options.includeInputTypes) {\n    selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n  }\n\n  const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n\n  for (const type of allTypes) {\n    const typeName = type.name.value;\n\n    if (type.fields == null) {\n      continue;\n    }\n\n    for (const field of type.fields) {\n      if (field.directives && field.directives.length > 0) {\n        const fieldName = field.name.value;\n        const key = `${typeName}.${fieldName}`;\n        const directives = field.directives.map(d => ({\n          name: d.name.value,\n          args: (d.arguments || []).reduce((prev, arg) => ({ ...prev,\n            [arg.name.value]: parseDirectiveValue(arg.value)\n          }), {})\n        }));\n        result[key] = directives;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n  const allTypesMap = schema.getTypeMap();\n  const result = [];\n\n  for (const graphqlTypeName in allTypesMap) {\n    const graphqlType = allTypesMap[graphqlTypeName];\n\n    if (isObjectType(graphqlType)) {\n      const allInterfaces = graphqlType.getInterfaces();\n\n      if (allInterfaces.find(int => int.name === interfaceName)) {\n        result.push(graphqlType.name);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction astFromType(type) {\n  if (isNonNullType(type)) {\n    const innerType = astFromType(type.ofType);\n\n    if (innerType.kind === Kind.NON_NULL_TYPE) {\n      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n    }\n\n    return {\n      kind: Kind.NON_NULL_TYPE,\n      type: innerType\n    };\n  } else if (isListType(type)) {\n    return {\n      kind: Kind.LIST_TYPE,\n      type: astFromType(type.ofType)\n    };\n  }\n\n  return {\n    kind: Kind.NAMED_TYPE,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    }\n  };\n}\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\n\n\nfunction astFromValueUntyped(value) {\n  // only explicit null, not undefined, NaN\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if (Array.isArray(value)) {\n    const valuesNodes = [];\n\n    for (const item of value) {\n      const itemNode = astFromValueUntyped(item);\n\n      if (itemNode != null) {\n        valuesNodes.push(itemNode);\n      }\n    }\n\n    return {\n      kind: Kind.LIST,\n      values: valuesNodes\n    };\n  }\n\n  if (typeof value === 'object') {\n    const fieldNodes = [];\n\n    for (const fieldName in value) {\n      const fieldValue = value[fieldName];\n      const ast = astFromValueUntyped(fieldValue);\n\n      if (ast) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: fieldName\n          },\n          value: ast\n        });\n      }\n    }\n\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n  if (typeof value === 'boolean') {\n    return {\n      kind: Kind.BOOLEAN,\n      value\n    };\n  } // JavaScript numbers can be Int or Float values.\n\n\n  if (typeof value === 'number' && isFinite(value)) {\n    const stringNum = String(value);\n    return integerStringRegExp.test(stringNum) ? {\n      kind: Kind.INT,\n      value: stringNum\n    } : {\n      kind: Kind.FLOAT,\n      value: stringNum\n    };\n  }\n\n  if (typeof value === 'string') {\n    return {\n      kind: Kind.STRING,\n      value\n    };\n  }\n\n  throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\n\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n\nfunction memoize1(fn) {\n  const memoize1cache = new WeakMap();\n  return function memoized(a1) {\n    const cachedValue = memoize1cache.get(a1);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1);\n      memoize1cache.set(a1, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize2(fn) {\n  const memoize2cache = new WeakMap();\n  return function memoized(a1, a2) {\n    let cache2 = memoize2cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2cache.set(a1, cache2);\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize3(fn) {\n  const memoize3Cache = new WeakMap();\n  return function memoized(a1, a2, a3) {\n    let cache2 = memoize3Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize3Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache3.get(a3);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize4(fn) {\n  const memoize4Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4) {\n    let cache2 = memoize4Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize4Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache4.get(a4);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize5(fn) {\n  const memoize5Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4, a5) {\n    let cache2 = memoize5Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize5Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache5 = cache4.get(a4);\n\n    if (!cache5) {\n      cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache5.get(a5);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nconst memoize2of4cache = new WeakMap();\n\nfunction memoize2of4(fn) {\n  return function memoized(a1, a2, a3, a4) {\n    let cache2 = memoize2of4cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2of4cache.set(a1, cache2);\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction getDefinedRootType(schema, operation) {\n  const rootTypeMap = getRootTypeMap(schema);\n  const rootType = rootTypeMap.get(operation);\n\n  if (rootType == null) {\n    throw new Error(`Root type for operation \"${operation}\" not defined by the given schema.`);\n  }\n\n  return rootType;\n}\n\nconst getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n  const rootTypes = getRootTypes(schema);\n  return new Set([...rootTypes].map(type => type.name));\n});\nconst getRootTypes = memoize1(function getRootTypes(schema) {\n  const rootTypeMap = getRootTypeMap(schema);\n  return new Set(rootTypeMap.values());\n});\nconst getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n  const rootTypeMap = new Map();\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    rootTypeMap.set('query', queryType);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    rootTypeMap.set('mutation', mutationType);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    rootTypeMap.set('subscription', subscriptionType);\n  }\n\n  return rootTypeMap;\n});\n\nfunction getDocumentNodeFromSchema(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n  const typesMap = schema.getTypeMap();\n  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n  const definitions = schemaNode != null ? [schemaNode] : [];\n  const directives = schema.getDirectives();\n\n  for (const directive of directives) {\n    if (isSpecifiedDirective(directive)) {\n      continue;\n    }\n\n    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n  }\n\n  for (const typeName in typesMap) {\n    const type = typesMap[typeName];\n    const isPredefinedScalar = isSpecifiedScalarType(type);\n    const isIntrospection = isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    }\n\n    if (isObjectType(type)) {\n      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (isInterfaceType(type)) {\n      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n    } else if (isUnionType(type)) {\n      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n    } else if (isInputObjectType(type)) {\n      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (isEnumType(type)) {\n      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n    } else if (isScalarType(type)) {\n      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n    } else {\n      throw new Error(`Unknown type ${type}.`);\n    }\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions\n  };\n} // this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\n\n\nfunction printSchemaWithDirectives(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const documentNode = getDocumentNodeFromSchema(schema, options);\n  return print(documentNode);\n}\n\nfunction astFromSchema(schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  const operationTypeMap = new Map([['query', undefined], ['mutation', undefined], ['subscription', undefined]]);\n  const nodes = [];\n\n  if (schema.astNode != null) {\n    nodes.push(schema.astNode);\n  }\n\n  if (schema.extensionASTNodes != null) {\n    for (const extensionASTNode of schema.extensionASTNodes) {\n      nodes.push(extensionASTNode);\n    }\n  }\n\n  for (const node of nodes) {\n    if (node.operationTypes) {\n      for (const operationTypeDefinitionNode of node.operationTypes) {\n        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n      }\n    }\n  }\n\n  const rootTypeMap = getRootTypeMap(schema);\n\n  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n    const rootType = rootTypeMap.get(operationTypeNode);\n\n    if (rootType != null) {\n      const rootTypeAST = astFromType(rootType);\n\n      if (operationTypeDefinitionNode != null) {\n        operationTypeDefinitionNode.type = rootTypeAST;\n      } else {\n        operationTypeMap.set(operationTypeNode, {\n          kind: Kind.OPERATION_TYPE_DEFINITION,\n          operation: operationTypeNode,\n          type: rootTypeAST\n        });\n      }\n    }\n  }\n\n  const operationTypes = [...operationTypeMap.values()].filter(isSome);\n  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n\n  if (!operationTypes.length && !directives.length) {\n    return null;\n  }\n\n  const schemaNode = {\n    kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,\n    operationTypes,\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  }; // This code is so weird because it needs to support GraphQL.js 14\n  // In GraphQL.js 14 there is no `description` value on schemaNode\n\n  schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {\n    kind: Kind.STRING,\n    value: schema.description,\n    block: true\n  } : undefined;\n  return schemaNode;\n}\n\nfunction astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c, _d;\n\n  return {\n    kind: Kind.DIRECTIVE_DEFINITION,\n    description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {\n      kind: Kind.STRING,\n      value: directive.description\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: directive.name\n    },\n    arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n    repeatable: directive.isRepeatable,\n    locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map(location => ({\n      kind: Kind.NAME,\n      value: location\n    }))) || []\n  };\n}\n\nfunction getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  let nodes = [];\n\n  if (entity.astNode != null) {\n    nodes.push(entity.astNode);\n  }\n\n  if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n    nodes = nodes.concat(entity.extensionASTNodes);\n  }\n\n  let directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = [];\n\n    for (const node of nodes) {\n      if (node.directives) {\n        directives.push(...node.directives);\n      }\n    }\n  }\n\n  return directives;\n}\n\nfunction getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  let directiveNodesBesidesDeprecated = [];\n  let deprecatedDirectiveNode = null;\n  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  let directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n  }\n\n  if (directives != null) {\n    directiveNodesBesidesDeprecated = directives.filter(directive => directive.name.value !== 'deprecated');\n\n    if (entity.deprecationReason != null) {\n      deprecatedDirectiveNode = (_b = directives.filter(directive => directive.name.value === 'deprecated')) === null || _b === void 0 ? void 0 : _b[0];\n    }\n  }\n\n  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {\n    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n  }\n\n  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\n\nfunction astFromArg(arg, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {\n      kind: Kind.STRING,\n      value: arg.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: arg.name\n    },\n    type: astFromType(arg.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    defaultValue: arg.defaultValue !== undefined ? (_c = astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,\n    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n    interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  const node = {\n    kind: Kind.INTERFACE_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n\n  if ('getInterfaces' in type) {\n    node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n  }\n\n  return node;\n}\n\nfunction astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.UNION_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    types: type.getTypes().map(type => astFromType(type))\n  };\n}\n\nfunction astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.ENUM_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n  const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];\n  const specifiedByValue = type['specifiedByUrl'] || type['specifiedByURL'];\n\n  if (specifiedByValue && !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n    const specifiedByArgs = {\n      url: specifiedByValue\n    };\n    directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n  }\n\n  return {\n    kind: Kind.SCALAR_TYPE_DEFINITION,\n    description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  };\n}\n\nfunction astFromField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.FIELD_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: field.name\n    },\n    arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInputField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: field.name\n    },\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    defaultValue: (_c = astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined\n  };\n}\n\nfunction astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.ENUM_VALUE_DEFINITION,\n    description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {\n      kind: Kind.STRING,\n      value: value.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: value.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction makeDeprecatedDirective(deprecationReason) {\n  return makeDirectiveNode('deprecated', {\n    reason: deprecationReason\n  }, GraphQLDeprecatedDirective);\n}\n\nfunction makeDirectiveNode(name, args, directive) {\n  const directiveArguments = [];\n\n  if (directive != null) {\n    for (const arg of directive.args) {\n      const argName = arg.name;\n      const argValue = args[argName];\n\n      if (argValue !== undefined) {\n        const value = astFromValue(argValue, arg.type);\n\n        if (value) {\n          directiveArguments.push({\n            kind: Kind.ARGUMENT,\n            name: {\n              kind: Kind.NAME,\n              value: argName\n            },\n            value\n          });\n        }\n      }\n    }\n  } else {\n    for (const argName in args) {\n      const argValue = args[argName];\n      const value = astFromValueUntyped(argValue);\n\n      if (value) {\n        directiveArguments.push({\n          kind: Kind.ARGUMENT,\n          name: {\n            kind: Kind.NAME,\n            value: argName\n          },\n          value\n        });\n      }\n    }\n  }\n\n  return {\n    kind: Kind.DIRECTIVE,\n    name: {\n      kind: Kind.NAME,\n      value: name\n    },\n    arguments: directiveArguments\n  };\n}\n\nfunction makeDirectiveNodes(schema, directiveValues) {\n  const directiveNodes = [];\n\n  for (const directiveName in directiveValues) {\n    const arrayOrSingleValue = directiveValues[directiveName];\n    const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n\n    if (Array.isArray(arrayOrSingleValue)) {\n      for (const value of arrayOrSingleValue) {\n        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n      }\n    } else {\n      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n    }\n  }\n\n  return directiveNodes;\n}\n\nasync function validateGraphQlDocuments(schema, documentFiles) {\n  let effectiveRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createDefaultRules();\n  const allFragmentMap = new Map();\n  const documentFileObjectsToValidate = [];\n\n  for (const documentFile of documentFiles) {\n    if (documentFile.document) {\n      const definitionsToValidate = [];\n\n      for (const definitionNode of documentFile.document.definitions) {\n        if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {\n          allFragmentMap.set(definitionNode.name.value, definitionNode);\n        } else {\n          definitionsToValidate.push(definitionNode);\n        }\n      }\n\n      documentFileObjectsToValidate.push({\n        location: documentFile.location,\n        document: {\n          kind: Kind.DOCUMENT,\n          definitions: definitionsToValidate\n        }\n      });\n    }\n  }\n\n  const allErrors = [];\n  const allFragmentsDocument = {\n    kind: Kind.DOCUMENT,\n    definitions: [...allFragmentMap.values()]\n  };\n  await Promise.all(documentFileObjectsToValidate.map(async documentFile => {\n    const documentToValidate = concatAST([allFragmentsDocument, documentFile.document]);\n    const errors = validate(schema, documentToValidate, effectiveRules);\n\n    if (errors.length > 0) {\n      allErrors.push({\n        filePath: documentFile.location,\n        errors\n      });\n    }\n  }));\n  return allErrors;\n}\n\nfunction checkValidationErrors(loadDocumentErrors) {\n  if (loadDocumentErrors.length > 0) {\n    const errors = [];\n\n    for (const loadDocumentError of loadDocumentErrors) {\n      for (const graphQLError of loadDocumentError.errors) {\n        const error = new Error();\n        error.name = 'GraphQLDocumentError';\n        error.message = `${error.name}: ${graphQLError.message}`;\n        error.stack = error.message;\n\n        if (graphQLError.locations) {\n          for (const location of graphQLError.locations) {\n            error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;\n          }\n        }\n\n        errors.push(error);\n      }\n    }\n\n    throw new AggregateErrorImpl(errors, `GraphQL Document Validation failed with ${errors.length} errors;\n  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join('\\n\\n')}`);\n  }\n}\n\nfunction createDefaultRules() {\n  let ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n\n  if (versionInfo.major < 15) {\n    ignored = ignored.map(rule => rule.replace(/Rule$/, ''));\n  }\n\n  return specifiedRules.filter(f => !ignored.includes(f.name));\n}\n\nfunction stripBOM(content) {\n  content = content.toString(); // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n\n  if (content.charCodeAt(0) === 0xfeff) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n\nfunction parseBOM(content) {\n  return JSON.parse(stripBOM(content));\n}\n\nfunction parseGraphQLJSON(location, jsonContent, options) {\n  let parsedJson = parseBOM(jsonContent);\n\n  if (parsedJson.data) {\n    parsedJson = parsedJson.data;\n  }\n\n  if (parsedJson.kind === 'Document') {\n    return {\n      location,\n      document: parsedJson\n    };\n  } else if (parsedJson.__schema) {\n    const schema = buildClientSchema(parsedJson, options);\n    return {\n      location,\n      schema\n    };\n  } else if (typeof parsedJson === 'string') {\n    return {\n      location,\n      rawSDL: parsedJson\n    };\n  }\n\n  throw new Error(`Not valid JSON content`);\n}\n\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\n\nfunction resetComments() {\n  commentsRegistry = {};\n}\n\nfunction collectComment(node) {\n  var _a;\n\n  const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n\n  if (entityName == null) {\n    return;\n  }\n\n  pushComment(node, entityName);\n\n  switch (node.kind) {\n    case 'EnumTypeDefinition':\n      if (node.values) {\n        for (const value of node.values) {\n          pushComment(value, entityName, value.name.value);\n        }\n      }\n\n      break;\n\n    case 'ObjectTypeDefinition':\n    case 'InputObjectTypeDefinition':\n    case 'InterfaceTypeDefinition':\n      if (node.fields) {\n        for (const field of node.fields) {\n          pushComment(field, entityName, field.name.value);\n\n          if (isFieldDefinitionNode(field) && field.arguments) {\n            for (const arg of field.arguments) {\n              pushComment(arg, entityName, field.name.value, arg.name.value);\n            }\n          }\n        }\n      }\n\n      break;\n  }\n}\n\nfunction pushComment(node, entity, field, argument) {\n  const comment = getComment(node);\n\n  if (typeof comment !== 'string' || comment.length === 0) {\n    return;\n  }\n\n  const keys = [entity];\n\n  if (field) {\n    keys.push(field);\n\n    if (argument) {\n      keys.push(argument);\n    }\n  }\n\n  const path = keys.join('.');\n\n  if (!commentsRegistry[path]) {\n    commentsRegistry[path] = [];\n  }\n\n  commentsRegistry[path].push(comment);\n}\n\nfunction printComment(comment) {\n  return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _a;\n\n  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\n\nfunction addDescription(cb) {\n  return (node, _key, _parent, path, ancestors) => {\n    var _a;\n\n    const keys = [];\n    const parent = path.reduce((prev, key) => {\n      if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n        keys.push(prev.name.value);\n      }\n\n      return prev[key];\n    }, ancestors[0]);\n    const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n    const items = [];\n\n    if (node.kind.includes('Definition') && commentsRegistry[key]) {\n      items.push(...commentsRegistry[key]);\n    }\n\n    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n  };\n}\n\nfunction indent(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value) {\n  let isDescription = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\n\nconst printDocASTReducer = {\n  Name: {\n    leave: node => node.value\n  },\n  Variable: {\n    leave: node => '$' + node.name\n  },\n  // Document\n  Document: {\n    leave: node => join(node.definitions, '\\n\\n')\n  },\n  OperationDefinition: {\n    leave: node => {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' '); // the query short form.\n\n      return prefix + ' ' + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: _ref3 => {\n      let {\n        variable,\n        type,\n        defaultValue,\n        directives\n      } = _ref3;\n      return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n    }\n  },\n  SelectionSet: {\n    leave: _ref4 => {\n      let {\n        selections\n      } = _ref4;\n      return block(selections);\n    }\n  },\n  Field: {\n    leave(_ref5) {\n      let {\n        alias,\n        name,\n        arguments: args,\n        directives,\n        selectionSet\n      } = _ref5;\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n\n  },\n  Argument: {\n    leave: _ref6 => {\n      let {\n        name,\n        value\n      } = _ref6;\n      return name + ': ' + value;\n    }\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: _ref7 => {\n      let {\n        name,\n        directives\n      } = _ref7;\n      return '...' + name + wrap(' ', join(directives, ' '));\n    }\n  },\n  InlineFragment: {\n    leave: _ref8 => {\n      let {\n        typeCondition,\n        directives,\n        selectionSet\n      } = _ref8;\n      return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  FragmentDefinition: {\n    leave: _ref9 => {\n      let {\n        name,\n        typeCondition,\n        variableDefinitions,\n        directives,\n        selectionSet\n      } = _ref9;\n      return (// Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` + selectionSet\n      );\n    }\n  },\n  // Value\n  IntValue: {\n    leave: _ref10 => {\n      let {\n        value\n      } = _ref10;\n      return value;\n    }\n  },\n  FloatValue: {\n    leave: _ref11 => {\n      let {\n        value\n      } = _ref11;\n      return value;\n    }\n  },\n  StringValue: {\n    leave: _ref12 => {\n      let {\n        value,\n        block: isBlockString\n      } = _ref12;\n\n      if (isBlockString) {\n        return printBlockString(value);\n      }\n\n      return JSON.stringify(value);\n    }\n  },\n  BooleanValue: {\n    leave: _ref13 => {\n      let {\n        value\n      } = _ref13;\n      return value ? 'true' : 'false';\n    }\n  },\n  NullValue: {\n    leave: () => 'null'\n  },\n  EnumValue: {\n    leave: _ref14 => {\n      let {\n        value\n      } = _ref14;\n      return value;\n    }\n  },\n  ListValue: {\n    leave: _ref15 => {\n      let {\n        values\n      } = _ref15;\n      return '[' + join(values, ', ') + ']';\n    }\n  },\n  ObjectValue: {\n    leave: _ref16 => {\n      let {\n        fields\n      } = _ref16;\n      return '{' + join(fields, ', ') + '}';\n    }\n  },\n  ObjectField: {\n    leave: _ref17 => {\n      let {\n        name,\n        value\n      } = _ref17;\n      return name + ': ' + value;\n    }\n  },\n  // Directive\n  Directive: {\n    leave: _ref18 => {\n      let {\n        name,\n        arguments: args\n      } = _ref18;\n      return '@' + name + wrap('(', join(args, ', '), ')');\n    }\n  },\n  // Type\n  NamedType: {\n    leave: _ref19 => {\n      let {\n        name\n      } = _ref19;\n      return name;\n    }\n  },\n  ListType: {\n    leave: _ref20 => {\n      let {\n        type\n      } = _ref20;\n      return '[' + type + ']';\n    }\n  },\n  NonNullType: {\n    leave: _ref21 => {\n      let {\n        type\n      } = _ref21;\n      return type + '!';\n    }\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: _ref22 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref22;\n      return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  OperationTypeDefinition: {\n    leave: _ref23 => {\n      let {\n        operation,\n        type\n      } = _ref23;\n      return operation + ': ' + type;\n    }\n  },\n  ScalarTypeDefinition: {\n    leave: _ref24 => {\n      let {\n        name,\n        directives\n      } = _ref24;\n      return join(['scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeDefinition: {\n    leave: _ref25 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref25;\n      return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  FieldDefinition: {\n    leave: _ref26 => {\n      let {\n        name,\n        arguments: args,\n        type,\n        directives\n      } = _ref26;\n      return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n    }\n  },\n  InputValueDefinition: {\n    leave: _ref27 => {\n      let {\n        name,\n        type,\n        defaultValue,\n        directives\n      } = _ref27;\n      return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n    }\n  },\n  InterfaceTypeDefinition: {\n    leave: _ref28 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref28;\n      return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeDefinition: {\n    leave: _ref29 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref29;\n      return join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeDefinition: {\n    leave: _ref30 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref30;\n      return join(['enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  EnumValueDefinition: {\n    leave: _ref31 => {\n      let {\n        name,\n        directives\n      } = _ref31;\n      return join([name, join(directives, ' ')], ' ');\n    }\n  },\n  InputObjectTypeDefinition: {\n    leave: _ref32 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref32;\n      return join(['input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  DirectiveDefinition: {\n    leave: _ref33 => {\n      let {\n        name,\n        arguments: args,\n        repeatable,\n        locations\n      } = _ref33;\n      return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n    }\n  },\n  SchemaExtension: {\n    leave: _ref34 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref34;\n      return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  ScalarTypeExtension: {\n    leave: _ref35 => {\n      let {\n        name,\n        directives\n      } = _ref35;\n      return join(['extend scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeExtension: {\n    leave: _ref36 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref36;\n      return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  InterfaceTypeExtension: {\n    leave: _ref37 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref37;\n      return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeExtension: {\n    leave: _ref38 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref38;\n      return join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeExtension: {\n    leave: _ref39 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref39;\n      return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  InputObjectTypeExtension: {\n    leave: _ref40 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref40;\n      return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  }\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({ ...prev,\n  [key]: {\n    leave: addDescription(printDocASTReducer[key].leave)\n  }\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nfunction printWithComments(ast) {\n  return visit(ast, printDocASTReducerWithComments);\n}\n\nfunction isFieldDefinitionNode(node) {\n  return node.kind === 'FieldDefinition';\n} // graphql < v13 and > v15 does not export getDescription\n\n\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n    return getComment(node);\n  }\n}\n\nfunction getComment(node) {\n  const rawValue = getLeadingCommentBlock(node);\n\n  if (rawValue !== undefined) {\n    return dedentBlockStringValue(`\\n${rawValue}`);\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  const comments = [];\n  let token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  let commonIndent = null;\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  let i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let document;\n\n  try {\n    if (options.commentDescriptions && rawSDL.includes('#')) {\n      document = transformCommentsToDescriptions(rawSDL, options); // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n      // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n      // into descriptions.\n\n      if (options.noLocation) {\n        document = parse(print(document), options);\n      }\n    } else {\n      document = parse(new Source(rawSDL, location), options);\n    }\n  } catch (e) {\n    if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n      document = {\n        kind: Kind.DOCUMENT,\n        definitions: []\n      };\n    } else {\n      throw e;\n    }\n  }\n\n  return {\n    location,\n    document\n  };\n}\n\nfunction transformCommentsToDescriptions(sourceSdl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parsedDoc = parse(sourceSdl, { ...options,\n    noLocation: false\n  });\n  const modifiedDoc = visit(parsedDoc, {\n    leave: node => {\n      if (isDescribable(node)) {\n        const rawValue = getLeadingCommentBlock(node);\n\n        if (rawValue !== undefined) {\n          const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n          const isBlock = commentsBlock.includes('\\n');\n\n          if (!node.description) {\n            return { ...node,\n              description: {\n                kind: Kind.STRING,\n                value: commentsBlock,\n                block: isBlock\n              }\n            };\n          } else {\n            return { ...node,\n              description: { ...node.description,\n                value: node.description.value + '\\n' + commentsBlock,\n                block: true\n              }\n            };\n          }\n        }\n      }\n    }\n  });\n  return modifiedDoc;\n}\n\nfunction isDescribable(node) {\n  return isTypeSystemDefinitionNode(node) || node.kind === Kind.FIELD_DEFINITION || node.kind === Kind.INPUT_VALUE_DEFINITION || node.kind === Kind.ENUM_VALUE_DEFINITION;\n}\n\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\n\nfunction addOperationVariable(variable) {\n  operationVariables.push(variable);\n}\n\nfunction resetOperationVariables() {\n  operationVariables = [];\n}\n\nfunction resetFieldMap() {\n  fieldTypeMap = new Map();\n}\n\nfunction buildOperationNodeForField(_ref41) {\n  let {\n    schema,\n    kind,\n    field,\n    models,\n    ignore = [],\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields = true\n  } = _ref41;\n  resetOperationVariables();\n  resetFieldMap();\n  const rootTypeNames = getRootTypeNames(schema);\n  const operationNode = buildOperationAndCollectVariables({\n    schema,\n    fieldName: field,\n    kind,\n    models: models || [],\n    ignore,\n    depthLimit: depthLimit || Infinity,\n    circularReferenceDepth: circularReferenceDepth || 1,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  }); // attach variables\n\n  operationNode.variableDefinitions = [...operationVariables];\n  resetOperationVariables();\n  resetFieldMap();\n  return operationNode;\n}\n\nfunction buildOperationAndCollectVariables(_ref42) {\n  let {\n    schema,\n    fieldName,\n    kind,\n    models,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref42;\n  const type = getDefinedRootType(schema, kind);\n  const field = type.getFields()[fieldName];\n  const operationName = `${fieldName}_${kind}`;\n\n  if (field.args) {\n    for (const arg of field.args) {\n      const argName = arg.name;\n\n      if (!argNames || argNames.includes(argName)) {\n        addOperationVariable(resolveVariable(arg, argName));\n      }\n    }\n  }\n\n  return {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: kind,\n    name: {\n      kind: Kind.NAME,\n      value: operationName\n    },\n    variableDefinitions: [],\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [resolveField({\n        type,\n        field,\n        models,\n        firstCall: true,\n        path: [],\n        ancestors: [],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: 0,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      })]\n    }\n  };\n}\n\nfunction resolveSelectionSet(_ref43) {\n  let {\n    parent,\n    type,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref43;\n\n  if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n    return;\n  }\n\n  if (isUnionType(type)) {\n    const types = type.getTypes();\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (isInterfaceType(type)) {\n    const types = Object.values(schema.getTypeMap()).filter(t => isObjectType(t) && t.getInterfaces().includes(type));\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (isObjectType(type) && !rootTypeNames.has(type.name)) {\n    const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n    const isModel = models.includes(type.name);\n\n    if (!firstCall && isModel && !isIgnored) {\n      return {\n        kind: Kind.SELECTION_SET,\n        selections: [{\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: 'id'\n          }\n        }]\n      };\n    }\n\n    const fields = type.getFields();\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: Object.keys(fields).filter(fieldName => {\n        return !hasCircularRef([...ancestors, getNamedType(fields[fieldName].type)], {\n          depth: circularReferenceDepth\n        });\n      }).map(fieldName => {\n        const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n\n        if (selectedSubFields) {\n          return resolveField({\n            type: type,\n            field: fields[fieldName],\n            models,\n            path: [...path, fieldName],\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields: selectedSubFields,\n            rootTypeNames\n          });\n        }\n\n        return null;\n      }).filter(f => {\n        var _a, _b;\n\n        if (f == null) {\n          return false;\n        } else if ('selectionSet' in f) {\n          return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n        }\n\n        return true;\n      })\n    };\n  }\n}\n\nfunction resolveVariable(arg, name) {\n  function resolveVariableType(type) {\n    if (isListType(type)) {\n      return {\n        kind: Kind.LIST_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    if (isNonNullType(type)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        // for v16 compatibility\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: type.name\n      }\n    };\n  }\n\n  return {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: name || arg.name\n      }\n    },\n    type: resolveVariableType(arg.type)\n  };\n}\n\nfunction getArgumentName(name, path) {\n  return [...path, name].join('_');\n}\n\nfunction resolveField(_ref44) {\n  let {\n    type,\n    field,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref44;\n  const namedType = getNamedType(field.type);\n  let args = [];\n  let removeField = false;\n\n  if (field.args && field.args.length) {\n    args = field.args.map(arg => {\n      const argumentName = getArgumentName(arg.name, path);\n\n      if (argNames && !argNames.includes(argumentName)) {\n        if (isNonNullType(arg.type)) {\n          removeField = true;\n        }\n\n        return null;\n      }\n\n      if (!firstCall) {\n        addOperationVariable(resolveVariable(arg, argumentName));\n      }\n\n      return {\n        kind: Kind.ARGUMENT,\n        name: {\n          kind: Kind.NAME,\n          value: arg.name\n        },\n        value: {\n          kind: Kind.VARIABLE,\n          name: {\n            kind: Kind.NAME,\n            value: getArgumentName(arg.name, path)\n          }\n        }\n      };\n    }).filter(Boolean);\n  }\n\n  if (removeField) {\n    return null;\n  }\n\n  const fieldPath = [...path, field.name];\n  const fieldPathStr = fieldPath.join('.');\n  let fieldName = field.name;\n\n  if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n    fieldName += field.type.toString().replace('!', 'NonNull');\n  }\n\n  fieldTypeMap.set(fieldPathStr, field.type.toString());\n\n  if (!isScalarType(namedType) && !isEnumType(namedType)) {\n    return {\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: field.name\n      },\n      ...(fieldName !== field.name && {\n        alias: {\n          kind: Kind.NAME,\n          value: fieldName\n        }\n      }),\n      selectionSet: resolveSelectionSet({\n        parent: type,\n        type: namedType,\n        models,\n        firstCall,\n        path: fieldPath,\n        ancestors: [...ancestors, type],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: depth + 1,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      }) || undefined,\n      arguments: args\n    };\n  }\n\n  return {\n    kind: Kind.FIELD,\n    name: {\n      kind: Kind.NAME,\n      value: field.name\n    },\n    ...(fieldName !== field.name && {\n      alias: {\n        kind: Kind.NAME,\n        value: fieldName\n      }\n    }),\n    arguments: args\n  };\n}\n\nfunction hasCircularRef(types) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    depth: 1\n  };\n  const type = types[types.length - 1];\n\n  if (isScalarType(type)) {\n    return false;\n  }\n\n  const size = types.filter(t => t.name === type.name).length;\n  return size > config.depth;\n}\n\nvar MapperKind;\n\n(function (MapperKind) {\n  MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n  MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n  MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n  MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n  MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n  MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n  MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n  MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n  MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n  MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n  MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n  MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n  MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n  MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n  MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n  MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n  MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n  MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n  MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n  MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n  MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n  MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n  MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n  MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n  MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n\nfunction getObjectTypeFromTypeMap(typeMap, type) {\n  if (type) {\n    const maybeObjectType = typeMap[type.name];\n\n    if (isObjectType(maybeObjectType)) {\n      return maybeObjectType;\n    }\n  }\n}\n\nfunction createNamedStub(name, type) {\n  let constructor;\n\n  if (type === 'object') {\n    constructor = GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = GraphQLInterfaceType;\n  } else {\n    constructor = GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name,\n    fields: {\n      _fake: {\n        type: GraphQLString\n      }\n    }\n  });\n}\n\nfunction createStub(node, type) {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      return new GraphQLList(createStub(node.type, type));\n\n    case Kind.NON_NULL_TYPE:\n      return new GraphQLNonNull(createStub(node.type, type));\n\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nfunction isNamedStub(type) {\n  if ('getFields' in type) {\n    const fields = type.getFields(); // eslint-disable-next-line no-unreachable-loop\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      return field.name === '_fake';\n    }\n  }\n\n  return false;\n}\n\nfunction getBuiltInForStub(type) {\n  switch (type.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n\n    case GraphQLString.name:\n      return GraphQLString;\n\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n\n    case GraphQLID.name:\n      return GraphQLID;\n\n    default:\n      return type;\n  }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n  const referenceTypeMap = Object.create(null);\n\n  for (const typeName in originalTypeMap) {\n    referenceTypeMap[typeName] = originalTypeMap[typeName];\n  }\n\n  const newTypeMap = Object.create(null);\n\n  for (const typeName in referenceTypeMap) {\n    const namedType = referenceTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n\n    const newName = namedType.name;\n\n    if (newName.startsWith('__')) {\n      continue;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n\n    newTypeMap[newName] = namedType;\n  }\n\n  for (const typeName in newTypeMap) {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  }\n\n  const newDirectives = directives.map(directive => rewireDirective(directive));\n  return {\n    typeMap: newTypeMap,\n    directives: newDirectives\n  };\n\n  function rewireDirective(directive) {\n    if (isSpecifiedDirective(directive)) {\n      return directive;\n    }\n\n    const directiveConfig = directive.toConfig();\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(args) {\n    const rewiredArgs = {};\n\n    for (const argName in args) {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    }\n\n    return rewiredArgs;\n  }\n\n  function rewireNamedType(type) {\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields),\n        interfaces: () => rewireNamedTypes(config.interfaces)\n      };\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields)\n      };\n\n      if ('interfaces' in newConfig) {\n        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n      }\n\n      return new GraphQLInterfaceType(newConfig);\n    } else if (isUnionType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        types: () => rewireNamedTypes(config.types)\n      };\n      return new GraphQLUnionType(newConfig);\n    } else if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireInputFields(config.fields)\n      };\n      return new GraphQLInputObjectType(newConfig);\n    } else if (isEnumType(type)) {\n      const enumConfig = type.toConfig();\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type)) {\n      if (isSpecifiedScalarType(type)) {\n        return type;\n      }\n\n      const scalarConfig = type.toConfig();\n      return new GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function rewireFields(fields) {\n    const rewiredFields = {};\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null && field.args) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireInputFields(fields) {\n    const rewiredFields = {};\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes(namedTypes) {\n    const rewiredTypes = [];\n\n    for (const namedType of namedTypes) {\n      const rewiredType = rewireType(namedType);\n\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    }\n\n    return rewiredTypes;\n  }\n\n  function rewireType(type) {\n    if (isListType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new GraphQLList(rewiredType) : null;\n    } else if (isNonNullType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n    } else if (isNamedType(type)) {\n      let rewiredType = referenceTypeMap[type.name];\n\n      if (rewiredType === undefined) {\n        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n      }\n\n      return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n    }\n\n    return null;\n  }\n}\n\nfunction transformInputValue(type, value) {\n  let inputLeafValueTransformer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let inputObjectValueTransformer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = getNullableType(type);\n\n  if (isLeafType(nullableType)) {\n    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n  } else if (isListType(nullableType)) {\n    return value.map(listMember => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n  } else if (isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    const newValue = {};\n\n    for (const key in value) {\n      const field = fields[key];\n\n      if (field != null) {\n        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n      }\n    }\n\n    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n  } // unreachable, no other possible return value\n\n}\n\nfunction serializeInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\n\nfunction parseInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\n\nfunction parseInputValueLiteral(type, value) {\n  return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n\nfunction mapSchema(schema) {\n  let schemaMapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n  const originalDirectives = schema.getDirectives();\n  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(newTypeMap, newDirectives);\n  return new GraphQLSchema({ ...schema.toConfig(),\n    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n    types: Object.values(typeMap),\n    directives\n  });\n}\n\nfunction mapTypes(originalTypeMap, schema, schemaMapper) {\n  let testFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const maybeNewType = typeMapper(originalType, schema);\n\n      if (maybeNewType === undefined) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      newTypeMap[typeName] = maybeNewType;\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  const enumValueMapper = getEnumValueMapper(schemaMapper);\n\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n\n  return mapTypes(originalTypeMap, schema, {\n    [MapperKind.ENUM_TYPE]: type => {\n      const config = type.toConfig();\n      const originalEnumValueConfigMap = config.values;\n      const newEnumValueConfigMap = {};\n\n      for (const externalValue in originalEnumValueConfigMap) {\n        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n\n        if (mappedEnumValue === undefined) {\n          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n        } else if (Array.isArray(mappedEnumValue)) {\n          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n        } else if (mappedEnumValue !== null) {\n          newEnumValueConfigMap[externalValue] = mappedEnumValue;\n        }\n      }\n\n      return correctASTNodes(new GraphQLEnumType({ ...config,\n        values: newEnumValueConfigMap\n      }));\n    }\n  }, type => isEnumType(type));\n}\n\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  const newTypeMap = mapArguments(originalTypeMap, schema, {\n    [MapperKind.ARGUMENT]: argumentConfig => {\n      if (argumentConfig.defaultValue === undefined) {\n        return argumentConfig;\n      }\n\n      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...argumentConfig,\n          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n        };\n      }\n    }\n  });\n  return mapFields(newTypeMap, schema, {\n    [MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n      if (inputFieldConfig.defaultValue === undefined) {\n        return inputFieldConfig;\n      }\n\n      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...inputFieldConfig,\n          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n        };\n      }\n    }\n  });\n}\n\nfunction getNewType(newTypeMap, type) {\n  if (isListType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new GraphQLList(newType) : null;\n  } else if (isNonNullType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new GraphQLNonNull(newType) : null;\n  } else if (isNamedType(type)) {\n    const newType = newTypeMap[type.name];\n    return newType != null ? newType : null;\n  }\n\n  return null;\n}\n\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n\n        if (mappedField === undefined) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          const [newFieldName, newFieldConfig] = mappedField;\n\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = { ...newFieldConfig.astNode,\n              name: { ...newFieldConfig.astNode.name,\n                value: newFieldName\n              }\n            };\n          }\n\n          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      }\n\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const argumentMapper = getArgumentMapper(schemaMapper);\n\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const originalArgumentConfigMap = originalFieldConfig.args;\n\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        const argumentNames = Object.keys(originalArgumentConfigMap);\n\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        const newArgumentConfigMap = {};\n\n        for (const argumentName of argumentNames) {\n          const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n\n          if (mappedArgument === undefined) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            const [newArgumentName, newArgumentConfig] = mappedArgument;\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        }\n\n        newFieldConfigMap[fieldName] = { ...originalFieldConfig,\n          args: newArgumentConfigMap\n        };\n      }\n\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = new GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else {\n        newTypeMap[typeName] = new GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  const directiveMapper = getDirectiveMapper(schemaMapper);\n\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n\n  const newDirectives = [];\n\n  for (const directive of originalDirectives) {\n    const mappedDirective = directiveMapper(directive, schema);\n\n    if (mappedDirective === undefined) {\n      newDirectives.push(directive);\n    } else if (mappedDirective !== null) {\n      newDirectives.push(mappedDirective);\n    }\n  }\n\n  return newDirectives;\n}\n\nfunction getTypeSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  const type = schema.getType(typeName);\n  const specifiers = [MapperKind.TYPE];\n\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputObjectType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n  } else if (isUnionType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n  } else if (isEnumType(type)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  const specifiers = getTypeSpecifiers(schema, typeName);\n  let typeMapper;\n  const stack = [...specifiers];\n\n  while (!typeMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n\n  return typeMapper != null ? typeMapper : null;\n}\n\nfunction getFieldSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  const type = schema.getType(typeName);\n  const specifiers = [MapperKind.FIELD];\n\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if (isInterfaceType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n  } else if (isInputObjectType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n  }\n\n  return specifiers;\n}\n\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  const specifiers = getFieldSpecifiers(schema, typeName);\n  let fieldMapper;\n  const stack = [...specifiers];\n\n  while (!fieldMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop(); // TODO: fix this as unknown cast\n\n    fieldMapper = schemaMapper[next];\n  }\n\n  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\n\nfunction getArgumentMapper(schemaMapper) {\n  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\n\nfunction getDirectiveMapper(schemaMapper) {\n  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\n\nfunction getEnumValueMapper(schemaMapper) {\n  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\n\nfunction correctASTNodes(type) {\n  if (isObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: Kind.OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new GraphQLObjectType(config);\n  } else if (isInterfaceType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: Kind.INTERFACE_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new GraphQLInterfaceType(config);\n  } else if (isInputObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new GraphQLInputObjectType(config);\n  } else if (isEnumType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const values = [];\n\n      for (const enumKey in config.values) {\n        const enumValueConfig = config.values[enumKey];\n\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        values\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        values: undefined\n      }));\n    }\n\n    return new GraphQLEnumType(config);\n  } else {\n    return type;\n  }\n}\n\nfunction filterSchema(_ref45) {\n  let {\n    schema,\n    typeFilter = () => true,\n    fieldFilter = undefined,\n    rootFieldFilter = undefined,\n    objectFieldFilter = undefined,\n    interfaceFieldFilter = undefined,\n    inputObjectFieldFilter = undefined,\n    argumentFilter = undefined\n  } = _ref45;\n  const filteredSchema = mapSchema(schema, {\n    [MapperKind.QUERY]: type => filterRootFields(type, 'Query', rootFieldFilter, argumentFilter),\n    [MapperKind.MUTATION]: type => filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter),\n    [MapperKind.SUBSCRIPTION]: type => filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter),\n    [MapperKind.OBJECT_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,\n    [MapperKind.INTERFACE_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,\n    [MapperKind.INPUT_OBJECT_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,\n    [MapperKind.UNION_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.ENUM_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.SCALAR_TYPE]: type => typeFilter(type.name, type) ? undefined : null\n  });\n  return filteredSchema;\n}\n\nfunction filterRootFields(type, operation, rootFieldFilter, argumentFilter) {\n  if (rootFieldFilter || argumentFilter) {\n    const config = type.toConfig();\n\n    for (const fieldName in config.fields) {\n      const field = config.fields[fieldName];\n\n      if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && field.args) {\n        for (const argName in field.args) {\n          if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new GraphQLObjectType(config);\n  }\n\n  return type;\n}\n\nfunction filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {\n  if (fieldFilter || argumentFilter) {\n    const config = type.toConfig();\n\n    for (const fieldName in config.fields) {\n      const field = config.fields[fieldName];\n\n      if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && 'args' in field) {\n        for (const argName in field.args) {\n          if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new ElementConstructor(config);\n  }\n} // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\n\n\nfunction healSchema(schema) {\n  healTypes(schema.getTypeMap(), schema.getDirectives());\n  return schema;\n}\n\nfunction healTypes(originalTypeMap, directives) {\n  const actualNamedTypeMap = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n\n    const actualName = namedType.name;\n\n    if (actualName.startsWith('__')) {\n      continue;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(`Duplicate schema type name ${actualName}`);\n    }\n\n    actualNamedTypeMap[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  } // Now add back every named type by its actual name.\n\n\n  for (const typeName in actualNamedTypeMap) {\n    const namedType = actualNamedTypeMap[typeName];\n    originalTypeMap[typeName] = namedType;\n  } // Directive declaration argument types can refer to named types.\n\n\n  for (const decl of directives) {\n    decl.args = decl.args.filter(arg => {\n      arg.type = healType(arg.type);\n      return arg.type !== null;\n    });\n  }\n\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName]; // Heal all named types, except for dangling references, kept only to redirect.\n\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  }\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      delete originalTypeMap[typeName];\n    }\n  }\n\n  function healNamedType(type) {\n    if (isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (isInterfaceType(type)) {\n      healFields(type);\n\n      if ('getInterfaces' in type) {\n        healInterfaces(type);\n      }\n\n      return;\n    } else if (isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function healFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.args.map(arg => {\n        arg.type = healType(arg.type);\n        return arg.type === null ? null : arg;\n      }).filter(Boolean);\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healInterfaces(type) {\n    if ('getInterfaces' in type) {\n      const interfaces = type.getInterfaces();\n      interfaces.push(...interfaces.splice(0).map(iface => healType(iface)).filter(Boolean));\n    }\n  }\n\n  function healInputFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healUnderlyingTypes(type) {\n    const types = type.getTypes();\n    types.push(...types.splice(0).map(t => healType(t)).filter(Boolean));\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (isListType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLList(healedType) : null;\n    } else if (isNonNullType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLNonNull(healedType) : null;\n    } else if (isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      const officialType = originalTypeMap[type.name];\n\n      if (officialType && type !== officialType) {\n        return officialType;\n      }\n    }\n\n    return type;\n  }\n}\n\nfunction getResolversFromSchema(schema) {\n  var _a, _b;\n\n  const resolvers = Object.create(null);\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    if (!typeName.startsWith('__')) {\n      const type = typeMap[typeName];\n\n      if (isScalarType(type)) {\n        if (!isSpecifiedScalarType(type)) {\n          const config = type.toConfig();\n          delete config.astNode; // avoid AST duplication elsewhere\n\n          resolvers[typeName] = new GraphQLScalarType(config);\n        }\n      } else if (isEnumType(type)) {\n        resolvers[typeName] = {};\n        const values = type.getValues();\n\n        for (const value of values) {\n          resolvers[typeName][value.name] = value.value;\n        }\n      } else if (isInterfaceType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (isUnionType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (isObjectType(type)) {\n        resolvers[typeName] = {};\n\n        if (type.isTypeOf != null) {\n          resolvers[typeName].__isTypeOf = type.isTypeOf;\n        }\n\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n\n          if (field.subscribe != null) {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].subscribe = field.subscribe;\n          }\n\n          if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== 'defaultFieldResolver' && ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== 'defaultMergedResolver') {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].resolve = field.resolve;\n          }\n        }\n      }\n    }\n  }\n\n  return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName]; // TODO: maybe have an option to include these?\n\n    if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n      const fields = type.getFields();\n\n      for (const fieldName in fields) {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      }\n    }\n  }\n}\n\nfunction forEachDefaultValue(schema, fn) {\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName];\n\n    if (!getNamedType(type).name.startsWith('__')) {\n      if (isObjectType(type)) {\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n\n          for (const arg of field.args) {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          }\n        }\n      } else if (isInputObjectType(type)) {\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        }\n      }\n    }\n  }\n} // addTypes uses toConfig to create a new schema with a new or replaced\n\n\nfunction addTypes(schema, newTypesOrDirectives) {\n  const config = schema.toConfig();\n  const originalTypeMap = {};\n\n  for (const type of config.types) {\n    originalTypeMap[type.name] = type;\n  }\n\n  const originalDirectiveMap = {};\n\n  for (const directive of config.directives) {\n    originalDirectiveMap[directive.name] = directive;\n  }\n\n  for (const newTypeOrDirective of newTypesOrDirectives) {\n    if (isNamedType(newTypeOrDirective)) {\n      originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n    } else if (isDirective(newTypeOrDirective)) {\n      originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n    }\n  }\n\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));\n  return new GraphQLSchema({ ...config,\n    query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),\n    mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),\n    subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),\n    types: Object.values(typeMap),\n    directives\n  });\n}\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\n\n\nfunction pruneSchema(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pruningContext = {\n    schema,\n    unusedTypes: Object.create(null),\n    implementations: Object.create(null)\n  };\n\n  for (const typeName in schema.getTypeMap()) {\n    const type = schema.getType(typeName);\n\n    if (type && 'getInterfaces' in type) {\n      for (const iface of type.getInterfaces()) {\n        const implementations = getImplementations(pruningContext, iface);\n\n        if (implementations == null) {\n          pruningContext.implementations[iface.name] = Object.create(null);\n        }\n\n        pruningContext.implementations[iface.name][type.name] = true;\n      }\n    }\n  }\n\n  visitTypes(pruningContext, schema);\n  return mapSchema(schema, {\n    [MapperKind.TYPE]: type => {\n      // If we should NOT prune the type, return it immediately as unmodified\n      if (options.skipPruning && options.skipPruning(type)) {\n        return type;\n      }\n\n      if (isObjectType(type) || isInputObjectType(type)) {\n        if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else if (isUnionType(type)) {\n        if (!type.getTypes().length && !options.skipEmptyUnionPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else if (isInterfaceType(type)) {\n        const implementations = getImplementations(pruningContext, type);\n\n        if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || implementations && !Object.keys(implementations).length && !options.skipUnimplementedInterfacesPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else {\n        if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      }\n    }\n  });\n}\n\nfunction visitOutputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  visitedTypes[type.name] = true;\n  pruningContext.unusedTypes[type.name] = false;\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const fields = type.getFields();\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const namedType = getNamedType(field.type);\n      visitOutputType(visitedTypes, pruningContext, namedType);\n\n      for (const arg of field.args) {\n        const type = getNamedType(arg.type);\n        visitInputType(visitedTypes, pruningContext, type);\n      }\n    }\n\n    if (isInterfaceType(type)) {\n      const implementations = getImplementations(pruningContext, type);\n\n      if (implementations) {\n        for (const typeName in implementations) {\n          visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));\n        }\n      }\n    }\n\n    if ('getInterfaces' in type) {\n      for (const iFace of type.getInterfaces()) {\n        visitOutputType(visitedTypes, pruningContext, iFace);\n      }\n    }\n  } else if (isUnionType(type)) {\n    const types = type.getTypes();\n\n    for (const type of types) {\n      visitOutputType(visitedTypes, pruningContext, type);\n    }\n  }\n}\n/**\n * Get the implementations of an interface. May return undefined.\n */\n\n\nfunction getImplementations(pruningContext, type) {\n  return pruningContext.implementations[type.name];\n}\n\nfunction visitInputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  pruningContext.unusedTypes[type.name] = false;\n  visitedTypes[type.name] = true;\n\n  if (isInputObjectType(type)) {\n    const fields = type.getFields();\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const namedType = getNamedType(field.type);\n      visitInputType(visitedTypes, pruningContext, namedType);\n    }\n  }\n}\n\nfunction visitTypes(pruningContext, schema) {\n  for (const typeName in schema.getTypeMap()) {\n    if (!typeName.startsWith('__')) {\n      pruningContext.unusedTypes[typeName] = true;\n    }\n  }\n\n  const visitedTypes = Object.create(null);\n  const rootTypes = getRootTypes(schema);\n\n  for (const rootType of rootTypes) {\n    visitOutputType(visitedTypes, pruningContext, rootType);\n  }\n\n  for (const directive of schema.getDirectives()) {\n    for (const arg of directive.args) {\n      const type = getNamedType(arg.type);\n      visitInputType(visitedTypes, pruningContext, type);\n    }\n  }\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nfunction mergeDeep(sources) {\n  let respectPrototype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const target = sources[0] || {};\n  const output = {};\n\n  if (respectPrototype) {\n    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));\n  }\n\n  for (const source of sources) {\n    if (isObject(target) && isObject(source)) {\n      if (respectPrototype) {\n        const outputPrototype = Object.getPrototypeOf(output);\n        const sourcePrototype = Object.getPrototypeOf(source);\n\n        if (sourcePrototype) {\n          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n\n            if (isSome(descriptor)) {\n              Object.defineProperty(outputPrototype, key, descriptor);\n            }\n          }\n        }\n      }\n\n      for (const key in source) {\n        if (isObject(source[key])) {\n          if (!(key in output)) {\n            Object.assign(output, {\n              [key]: source[key]\n            });\n          } else {\n            output[key] = mergeDeep([output[key], source[key]], respectPrototype);\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction parseSelectionSet(selectionSet, options) {\n  const query = parse(selectionSet, options).definitions[0];\n  return query.selectionSet;\n}\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\n\n\nfunction getResponseKeyFromInfo(info) {\n  return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n  if (schema.getType(typeName) == null) {\n    return addTypes(schema, [new GraphQLObjectType({\n      name: typeName,\n      fields: additionalFields\n    })]);\n  }\n\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n        }\n\n        for (const fieldName in additionalFields) {\n          newFieldConfigMap[fieldName] = additionalFields[fieldName];\n        }\n\n        return correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n}\n\nfunction removeObjectFields(schema, typeName, testFn) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        }\n\n        return correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction selectObjectFields(schema, typeName, testFn) {\n  const selectedFields = {};\n  mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            selectedFields[fieldName] = originalFieldConfig;\n          }\n        }\n      }\n\n      return undefined;\n    }\n  });\n  return selectedFields;\n}\n\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        }\n\n        for (const fieldName in newFields) {\n          const fieldConfig = newFields[fieldName];\n          newFieldConfigMap[fieldName] = fieldConfig;\n        }\n\n        return correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n  if (isObjectType(type)) {\n    return new GraphQLObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isInterfaceType(type)) {\n    return new GraphQLInterfaceType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isUnionType(type)) {\n    return new GraphQLUnionType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isScalarType(type)) {\n    return new GraphQLScalarType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  }\n\n  throw new Error(`Unknown type ${type}.`);\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\n\n\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  let $return;\n  let abruptClose;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = error => {\n      const rethrow = () => Promise.reject(error);\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  let mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    const reject = rejectCallback;\n\n    mapReject = error => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n  }\n\n  return {\n    next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n\n    return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(resolve => resolve(callback(value)));\n}\n\nfunction iteratorResult(value) {\n  return {\n    value,\n    done: false\n  };\n}\n\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {\n  argumentNodes[argName] = {\n    kind: Kind.ARGUMENT,\n    name: {\n      kind: Kind.NAME,\n      value: argName\n    },\n    value: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    }\n  };\n  variableDefinitionsMap[varName] = {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    },\n    type: astFromType(type)\n  };\n\n  if (value !== undefined) {\n    variableValues[varName] = value;\n    return;\n  } // including the variable in the map with value of `undefined`\n  // will actually be translated by graphql-js into `null`\n  // see https://github.com/graphql/graphql-js/issues/2533\n\n\n  if (varName in variableValues) {\n    delete variableValues[varName];\n  }\n}\n\nfunction createVariableNameGenerator(variableDefinitionMap) {\n  let varCounter = 0;\n  return argName => {\n    let varName;\n\n    do {\n      varName = `_v${(varCounter++).toString()}_${argName}`;\n    } while (varName in variableDefinitionMap);\n\n    return varName;\n  };\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n  if (typeB == null || typeA == null) {\n    return false;\n  } else if (typeA === typeB) {\n    return true;\n  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n    return doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n\nfunction relocatedError(originalError, path) {\n  return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction observableToAsyncIterable(observable) {\n  const pullQueue = [];\n  const pushQueue = [];\n  let listening = true;\n\n  const pushValue = value => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value,\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value,\n        done: false\n      });\n    }\n  };\n\n  const pushError = error => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    }\n  };\n\n  const pushDone = () => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        done: true\n      });\n    } else {\n      pushQueue.push({\n        done: true\n      });\n    }\n  };\n\n  const pullValue = () => new Promise(resolve => {\n    if (pushQueue.length !== 0) {\n      const element = pushQueue.shift(); // either {value: {errors: [...]}} or {value: ...}\n\n      resolve(element);\n    } else {\n      pullQueue.push(resolve);\n    }\n  });\n\n  const subscription = observable.subscribe({\n    next(value) {\n      pushValue(value);\n    },\n\n    error(err) {\n      pushError(err);\n    },\n\n    complete() {\n      pushDone();\n    }\n\n  });\n\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n\n      for (const resolve of pullQueue) {\n        resolve({\n          value: undefined,\n          done: true\n        });\n      }\n\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return {\n    next() {\n      // return is a defined method, so it is safe to call it.\n      return listening ? pullValue() : this.return();\n    },\n\n    return() {\n      emptyQueue();\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction getOperationASTFromDocument(documentNode, operationName) {\n  const doc = getOperationAST(documentNode, operationName);\n\n  if (!doc) {\n    throw new Error(`Cannot infer operation ${operationName || ''}`);\n  }\n\n  return doc;\n}\n\nconst getOperationASTFromRequest = memoize1(function getOperationASTFromRequest(request) {\n  return getOperationASTFromDocument(request.document, request.operationName);\n}); // Taken from GraphQL-JS v16 for backwards compat\n\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          const name = getFieldEntryKey(selection);\n          const fieldList = fields.get(name);\n\n          if (fieldList !== undefined) {\n            fieldList.push(selection);\n          } else {\n            fields.set(name, [selection]);\n          }\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n\n          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames.add(fragName);\n          const fragment = fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    const possibleTypes = schema.getPossibleTypes(conditionalType);\n    return possibleTypes.includes(type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n\nconst collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const fieldNode of fieldNodes) {\n    if (fieldNode.selectionSet) {\n      collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n});\n\nfunction visitData(data, enter, leave) {\n  if (Array.isArray(data)) {\n    return data.map(value => visitData(value, enter, leave));\n  } else if (typeof data === 'object') {\n    const newData = enter != null ? enter(data) : data;\n\n    if (newData != null) {\n      for (const key in newData) {\n        const value = newData[key];\n        Object.defineProperty(newData, key, {\n          value: visitData(value, enter, leave)\n        });\n      }\n    }\n\n    return leave != null ? leave(newData) : newData;\n  }\n\n  return data;\n}\n\nfunction visitErrors(errors, visitor) {\n  return errors.map(error => visitor(error));\n}\n\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n  const fragments = request.document.definitions.reduce((acc, def) => {\n    if (def.kind === Kind.FRAGMENT_DEFINITION) {\n      acc[def.name.value] = def;\n    }\n\n    return acc;\n  }, {});\n  const variableValues = request.variables || {};\n  const errorInfo = {\n    segmentInfoMap: new Map(),\n    unpathedErrors: new Set()\n  };\n  const data = result.data;\n  const errors = result.errors;\n  const visitingErrors = errors != null && errorVisitorMap != null;\n  const operationDocumentNode = getOperationASTFromRequest(request);\n\n  if (data != null && operationDocumentNode != null) {\n    result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n  }\n\n  if (errors != null && errorVisitorMap) {\n    result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n  }\n\n  return result;\n}\n\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n  const segmentInfoMap = errorInfo.segmentInfoMap;\n  const unpathedErrors = errorInfo.unpathedErrors;\n  const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n  return errors.map(originalError => {\n    const pathSegmentsInfo = segmentInfoMap.get(originalError);\n    const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n      const typeName = segmentInfo.type.name;\n      const typeVisitorMap = errorVisitorMap[typeName];\n\n      if (typeVisitorMap == null) {\n        return acc;\n      }\n\n      const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n      return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n    }, originalError);\n\n    if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n      return unpathedErrorVisitor(newError);\n    }\n\n    return newError;\n  });\n}\n\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n  const operationRootType = getOperationRootType(schema, operation);\n  const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n  return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\n\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  const fieldMap = type.getFields();\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n  const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n  const newObject = enterObject != null ? enterObject(object) : object;\n  let sortedErrors;\n  let errorMap = null;\n\n  if (errors != null) {\n    sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n    errorMap = sortedErrors.errorMap;\n\n    for (const error of sortedErrors.unpathedErrors) {\n      errorInfo.unpathedErrors.add(error);\n    }\n  }\n\n  for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n    const fieldName = subFieldNodes[0].name.value;\n    const fieldType = fieldName === '__typename' ? TypeNameMetaFieldDef.type : fieldMap[fieldName].type;\n    const newPathIndex = pathIndex + 1;\n    let fieldErrors;\n\n    if (errorMap) {\n      fieldErrors = errorMap[responseKey];\n\n      if (fieldErrors != null) {\n        delete errorMap[responseKey];\n      }\n\n      addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n    }\n\n    const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n    updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n  }\n\n  const oldTypename = newObject.__typename;\n\n  if (oldTypename != null) {\n    updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n  }\n\n  if (errorMap) {\n    for (const errorsKey in errorMap) {\n      const errors = errorMap[errorsKey];\n\n      for (const error of errors) {\n        errorInfo.unpathedErrors.add(error);\n      }\n    }\n  }\n\n  const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n  return leaveObject != null ? leaveObject(newObject) : newObject;\n}\n\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n  if (typeVisitorMap == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const fieldVisitor = typeVisitorMap[fieldName];\n\n  if (fieldVisitor == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const visitedValue = fieldVisitor(newValue);\n\n  if (visitedValue === undefined) {\n    delete object[responseKey];\n    return;\n  }\n\n  object[responseKey] = visitedValue;\n}\n\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\n\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex) {\n  let errors = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  let errorInfo = arguments.length > 9 ? arguments[9] : undefined;\n\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = getNullableType(returnType);\n\n  if (isListType(nullableType)) {\n    return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (isAbstractType(nullableType)) {\n    const finalType = schema.getType(value.__typename);\n    const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);\n    return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (isObjectType(nullableType)) {\n    const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);\n    return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  }\n\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n\n  if (typeVisitorMap == null) {\n    return value;\n  }\n\n  const visitedValue = typeVisitorMap(value);\n  return visitedValue === undefined ? value : visitedValue;\n}\n\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n  var _a;\n\n  const errorMap = Object.create(null);\n  const unpathedErrors = new Set();\n\n  for (const error of errors) {\n    const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n\n    if (pathSegment == null) {\n      unpathedErrors.add(error);\n      continue;\n    }\n\n    if (pathSegment in errorMap) {\n      errorMap[pathSegment].push(error);\n    } else {\n      errorMap[pathSegment] = [error];\n    }\n  }\n\n  return {\n    errorMap,\n    unpathedErrors\n  };\n}\n\nfunction addPathSegmentInfo(type, fieldName, pathIndex) {\n  let errors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let errorInfo = arguments.length > 4 ? arguments[4] : undefined;\n\n  for (const error of errors) {\n    const segmentInfo = {\n      type,\n      fieldName,\n      pathIndex\n    };\n    const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n\n    if (pathSegmentsInfo == null) {\n      errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n    } else {\n      pathSegmentsInfo.push(segmentInfo);\n    }\n  }\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n  if (value == null) {\n    return value === criteria;\n  } else if (Array.isArray(value)) {\n    return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n  } else if (typeof value === 'object') {\n    return typeof criteria === 'object' && criteria && Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName]));\n  } else if (criteria instanceof RegExp) {\n    return criteria.test(value);\n  }\n\n  return value === criteria;\n}\n\nfunction isAsyncIterable(value) {\n  return typeof value === 'object' && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === 'function';\n}\n\nfunction isDocumentNode(object) {\n  return object && typeof object === 'object' && 'kind' in object && object.kind === Kind.DOCUMENT;\n}\n\nfunction withCancel(asyncIteratorLike, onCancel) {\n  const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();\n\n  if (!asyncIterator.return) {\n    asyncIterator.return = () => Promise.resolve({\n      value: undefined,\n      done: true\n    });\n  }\n\n  const savedReturn = asyncIterator.return.bind(asyncIterator);\n\n  asyncIterator.return = () => {\n    onCancel();\n    return savedReturn();\n  };\n\n  return asyncIterator;\n}\n\nfunction buildFixedSchema(schema, options) {\n  const document = getDocumentNodeFromSchema(schema);\n  return buildASTSchema(document, { ...(options || {})\n  });\n}\n\nfunction fixSchemaAst(schema, options) {\n  // eslint-disable-next-line no-undef-init\n  let schemaWithValidAst = undefined;\n\n  if (!schema.astNode || !schema.extensionASTNodes) {\n    schemaWithValidAst = buildFixedSchema(schema, options);\n  }\n\n  if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.astNode = schemaWithValidAst.astNode;\n  }\n\n  if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n  }\n\n  return schema;\n}\n\nexport { AggregateErrorImpl as AggregateError, MapperKind, addTypes, appendObjectFields, asArray, assertSome, astFromArg, astFromDirective, astFromEnumType, astFromEnumValue, astFromField, astFromInputField, astFromInputObjectType, astFromInterfaceType, astFromObjectType, astFromScalarType, astFromSchema, astFromUnionType, astFromValueUntyped, buildOperationNodeForField, checkValidationErrors, collectComment, collectFields, collectSubFields, compareNodes, compareStrings, correctASTNodes, createDefaultRules, createNamedStub, createStub, createVariableNameGenerator, dedentBlockStringValue, filterSchema, fixSchemaAst, forEachDefaultValue, forEachField, getArgumentValues, getBlockStringIndentation, getBuiltInForStub, getComment, getDefinedRootType, getDeprecatableDirectiveNodes, getDescription, getDirective, getDirectiveInExtensions, getDirectiveNodes, getDirectives, getDirectivesInExtensions, getDocumentNodeFromSchema, getFieldsWithDirectives, getImplementingTypes, getLeadingCommentBlock, getOperationASTFromDocument, getOperationASTFromRequest, getResolversFromSchema, getResponseKeyFromInfo, getRootTypeMap, getRootTypeNames, getRootTypes, healSchema, healTypes, implementsAbstractType, inspect, isAggregateError, isAsyncIterable, isDescribable, isDocumentNode, isDocumentString, isNamedStub, isSome, isValidPath, makeDeprecatedDirective, makeDirectiveNode, makeDirectiveNodes, mapAsyncIterator, mapSchema, memoize1, memoize2, memoize2of4, memoize3, memoize4, memoize5, mergeDeep, modifyObjectFields, nodeToString, observableToAsyncIterable, parseGraphQLJSON, parseGraphQLSDL, parseInputValue, parseInputValueLiteral, parseSelectionSet, printComment, printSchemaWithDirectives, printWithComments, pruneSchema, pushComment, relocatedError, removeObjectFields, renameType, resetComments, rewireTypes, selectObjectFields, serializeInputValue, transformCommentsToDescriptions, transformInputValue, updateArgument, validateGraphQlDocuments, valueMatchesCriteria, visitData, visitErrors, visitResult, withCancel };","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/@graphql-tools/utils/index.mjs"],"names":["parse","GraphQLError","isNonNullType","Kind","valueFromAST","print","isObjectType","isListType","isSpecifiedDirective","astFromValue","isSpecifiedScalarType","isIntrospectionType","isInterfaceType","isUnionType","isInputObjectType","isEnumType","isScalarType","GraphQLDeprecatedDirective","specifiedRules","concatAST","validate","versionInfo","buildClientSchema","visit","TokenKind","Source","isTypeSystemDefinitionNode","getNamedType","GraphQLString","GraphQLNonNull","GraphQLList","GraphQLID","GraphQLBoolean","GraphQLFloat","GraphQLInt","GraphQLObjectType","GraphQLInterfaceType","GraphQLInputObjectType","GraphQLDirective","GraphQLUnionType","GraphQLEnumType","GraphQLScalarType","isNamedType","getNullableType","isLeafType","GraphQLSchema","isDirective","isCompositeType","doTypesOverlap","getOperationAST","getDirectiveValues","GraphQLSkipDirective","GraphQLIncludeDirective","typeFromAST","isAbstractType","getOperationRootType","TypeNameMetaFieldDef","buildASTSchema","asArray","fns","Array","isArray","invalidDocRegex","isDocumentString","str","test","e","invalidPathRegex","isValidPath","compareStrings","a","b","String","nodeToString","_a","_b","name","alias","value","kind","compareNodes","customFn","aStr","bStr","isSome","input","assertSome","message","Error","AggregateErrorImpl","globalThis","AggregateError","AggregateErrorClass","constructor","errors","captureStackTrace","isAggregateError","error","MAX_ARRAY_LENGTH","MAX_RECURSIVE_DEPTH","inspect","formatValue","seenValues","JSON","stringify","formatObjectValue","formatError","toString","stack","previouslySeenValues","formatArray","includes","isJSONable","jsonValue","toJSON","formatObject","object","entries","Object","length","getObjectTag","properties","map","key","join","array","len","Math","min","remaining","items","i","push","tag","prototype","call","replace","getArgumentValues","def","node","variableValues","variableMap","reduce","prev","coercedValues","argumentNodes","arguments","argNodeMap","arg","type","argType","defaultValue","args","argumentNode","undefined","valueNode","isNull","NULL","VARIABLE","variableName","coercedValue","getDirectivesInExtensions","pathToDirectivesInExtensions","acc","pathSegment","extensions","_getDirectiveInExtensions","directivesInExtensions","directiveName","directiveInExtensions","filter","directiveAnnotation","directive","getDirectiveInExtensions","reformattedDirectivesInExtensions","argsOrArrayOfArgs","getDirectives","schema","schemaDirectives","schemaDirectiveMap","schemaDirective","astNodes","astNode","extensionASTNodes","result","directives","directiveNode","getDirective","parseDirectiveValue","INT","parseInt","FLOAT","parseFloat","BOOLEAN","Boolean","STRING","ENUM","LIST","values","v","OBJECT","fields","getFieldsWithDirectives","documentNode","options","selected","includeInputTypes","allTypes","definitions","obj","typeName","field","fieldName","d","getImplementingTypes","interfaceName","allTypesMap","getTypeMap","graphqlTypeName","graphqlType","allInterfaces","getInterfaces","find","int","astFromType","innerType","ofType","NON_NULL_TYPE","LIST_TYPE","NAMED_TYPE","NAME","astFromValueUntyped","valuesNodes","item","itemNode","fieldNodes","fieldValue","ast","OBJECT_FIELD","isFinite","stringNum","integerStringRegExp","TypeError","memoize1","fn","memoize1cache","WeakMap","memoized","a1","cachedValue","get","newValue","set","memoize2","memoize2cache","a2","cache2","memoize3","memoize3Cache","a3","cache3","memoize4","memoize4Cache","a4","cache4","memoize5","memoize5Cache","a5","cache5","memoize2of4cache","memoize2of4","getDefinedRootType","operation","rootTypeMap","getRootTypeMap","rootType","getRootTypeNames","rootTypes","getRootTypes","Set","Map","queryType","getQueryType","mutationType","getMutationType","subscriptionType","getSubscriptionType","getDocumentNodeFromSchema","typesMap","schemaNode","astFromSchema","astFromDirective","isPredefinedScalar","isIntrospection","astFromObjectType","astFromInterfaceType","astFromUnionType","astFromInputObjectType","astFromEnumType","astFromScalarType","DOCUMENT","printSchemaWithDirectives","operationTypeMap","nodes","extensionASTNode","operationTypes","operationTypeDefinitionNode","operationTypeNode","rootTypeAST","OPERATION_TYPE_DEFINITION","getDirectiveNodes","SCHEMA_DEFINITION","SCHEMA_EXTENSION","description","block","_c","_d","DIRECTIVE_DEFINITION","astFromArg","repeatable","isRepeatable","locations","location","entity","concat","makeDirectiveNodes","getDeprecatableDirectiveNodes","directiveNodesBesidesDeprecated","deprecatedDirectiveNode","deprecationReason","makeDeprecatedDirective","INPUT_VALUE_DEFINITION","OBJECT_TYPE_DEFINITION","getFields","astFromField","interfaces","iFace","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","types","getTypes","INPUT_OBJECT_TYPE_DEFINITION","astFromInputField","ENUM_TYPE_DEFINITION","getValues","astFromEnumValue","specifiedByValue","some","specifiedByArgs","url","makeDirectiveNode","SCALAR_TYPE_DEFINITION","FIELD_DEFINITION","ENUM_VALUE_DEFINITION","reason","directiveArguments","argName","argValue","ARGUMENT","DIRECTIVE","directiveValues","directiveNodes","arrayOrSingleValue","validateGraphQlDocuments","documentFiles","effectiveRules","createDefaultRules","allFragmentMap","documentFileObjectsToValidate","documentFile","document","definitionsToValidate","definitionNode","FRAGMENT_DEFINITION","allErrors","allFragmentsDocument","Promise","all","documentToValidate","filePath","checkValidationErrors","loadDocumentErrors","loadDocumentError","graphQLError","line","column","index","ignored","major","rule","f","stripBOM","content","charCodeAt","slice","parseBOM","parseGraphQLJSON","jsonContent","parsedJson","data","__schema","rawSDL","MAX_LINE_LENGTH","commentsRegistry","resetComments","collectComment","entityName","pushComment","isFieldDefinitionNode","argument","comment","getComment","keys","path","printComment","maybeArray","separator","x","hasMultilineItems","addDescription","cb","_key","_parent","ancestors","parent","indent","maybeString","wrap","start","end","printBlockString","isDescription","escaped","indexOf","printDocASTReducer","Name","leave","Variable","Document","OperationDefinition","varDefs","variableDefinitions","prefix","selectionSet","VariableDefinition","variable","SelectionSet","selections","Field","argsLine","Argument","FragmentSpread","InlineFragment","typeCondition","FragmentDefinition","IntValue","FloatValue","StringValue","isBlockString","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","printDocASTReducerWithComments","printWithComments","getDescription","commentDescriptions","rawValue","getLeadingCommentBlock","dedentBlockStringValue","loc","comments","token","startToken","COMMENT","next","reverse","rawString","lines","split","commonIndent","getBlockStringIndentation","isBlank","shift","pop","leadingWhitespace","parseGraphQLSDL","transformCommentsToDescriptions","noLocation","trim","sourceSdl","parsedDoc","modifiedDoc","isDescribable","commentsBlock","isBlock","operationVariables","fieldTypeMap","addOperationVariable","resetOperationVariables","resetFieldMap","buildOperationNodeForField","models","ignore","depthLimit","circularReferenceDepth","argNames","selectedFields","rootTypeNames","operationNode","buildOperationAndCollectVariables","Infinity","operationName","resolveVariable","OPERATION_DEFINITION","SELECTION_SET","resolveField","firstCall","depth","resolveSelectionSet","t","hasCircularRef","INLINE_FRAGMENT","fragmentNode","has","isIgnored","isModel","FIELD","selectedSubFields","resolveVariableType","VARIABLE_DEFINITION","getArgumentName","namedType","removeField","argumentName","fieldPath","fieldPathStr","config","size","MapperKind","getObjectTypeFromTypeMap","typeMap","maybeObjectType","createNamedStub","_fake","createStub","isNamedStub","getBuiltInForStub","rewireTypes","originalTypeMap","referenceTypeMap","create","newTypeMap","startsWith","newName","rewireNamedType","newDirectives","rewireDirective","directiveConfig","toConfig","rewireArgs","rewiredArgs","rewiredArgType","rewireType","newConfig","rewireFields","rewireNamedTypes","rewireInputFields","enumConfig","scalarConfig","rewiredFields","rewiredFieldType","namedTypes","rewiredTypes","rewiredType","transformInputValue","inputLeafValueTransformer","inputObjectValueTransformer","nullableType","listMember","serializeInputValue","serialize","parseInputValue","parseValue","parseInputValueLiteral","parseLiteral","mapSchema","schemaMapper","mapArguments","mapFields","mapTypes","mapDefaultValues","mapEnumValues","originalDirectives","mapDirectives","query","mutation","subscription","testFn","originalType","typeMapper","getTypeMapper","maybeNewType","enumValueMapper","getEnumValueMapper","ENUM_TYPE","originalEnumValueConfigMap","newEnumValueConfigMap","externalValue","originalEnumValueConfig","mappedEnumValue","newExternalValue","newEnumValueConfig","correctASTNodes","argumentConfig","getNewType","INPUT_OBJECT_FIELD","inputFieldConfig","newType","fieldMapper","getFieldMapper","originalFieldConfigMap","newFieldConfigMap","originalFieldConfig","mappedField","newFieldName","newFieldConfig","argumentMapper","getArgumentMapper","originalArgumentConfigMap","argumentNames","newArgumentConfigMap","originalArgumentConfig","mappedArgument","newArgumentName","newArgumentConfig","directiveMapper","getDirectiveMapper","mappedDirective","getTypeSpecifiers","getType","specifiers","TYPE","COMPOSITE_TYPE","OBJECT_TYPE","ROOT_OBJECT","QUERY","MUTATION","SUBSCRIPTION","INPUT_OBJECT_TYPE","ABSTRACT_TYPE","INTERFACE_TYPE","UNION_TYPE","SCALAR_TYPE","getFieldSpecifiers","COMPOSITE_FIELD","ROOT_FIELD","QUERY_ROOT_FIELD","MUTATION_ROOT_FIELD","SUBSCRIPTION_ROOT_FIELD","INTERFACE_FIELD","ENUM_VALUE","fieldConfig","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","enumKey","enumValueConfig","filterSchema","typeFilter","fieldFilter","rootFieldFilter","objectFieldFilter","interfaceFieldFilter","inputObjectFieldFilter","argumentFilter","filteredSchema","filterRootFields","filterElementFields","ElementConstructor","healSchema","healTypes","actualNamedTypeMap","actualName","decl","healType","healNamedType","healFields","healInterfaces","healUnderlyingTypes","healInputFields","fieldMap","splice","iface","healedType","officialType","getResolversFromSchema","resolvers","resolveType","__resolveType","isTypeOf","__isTypeOf","subscribe","resolve","forEachField","forEachDefaultValue","addTypes","newTypesOrDirectives","originalDirectiveMap","newTypeOrDirective","pruneSchema","pruningContext","unusedTypes","implementations","getImplementations","visitTypes","skipPruning","skipEmptyCompositeTypePruning","skipUnusedTypesPruning","skipEmptyUnionPruning","skipUnimplementedInterfacesPruning","visitOutputType","visitedTypes","visitInputType","mergeDeep","sources","respectPrototype","target","output","setPrototypeOf","getPrototypeOf","source","isObject","outputPrototype","sourcePrototype","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","defineProperty","assign","parseSelectionSet","getResponseKeyFromInfo","info","appendObjectFields","additionalFields","removeObjectFields","removedFields","newSchema","selectObjectFields","modifyObjectFields","newFields","renameType","newTypeName","mapAsyncIterator","iterator","callback","rejectCallback","$return","abruptClose","return","rethrow","reject","then","mapResult","done","asyncMapValue","iteratorResult","mapReject","throw","catch","Symbol","asyncIterator","updateArgument","variableDefinitionsMap","varName","createVariableNameGenerator","variableDefinitionMap","varCounter","implementsAbstractType","typeA","typeB","relocatedError","originalError","positions","observableToAsyncIterable","observable","pullQueue","pushQueue","listening","pushValue","pushError","pushDone","pullValue","element","err","complete","emptyQueue","unsubscribe","getOperationASTFromDocument","doc","getOperationASTFromRequest","request","collectFields","fragments","runtimeType","visitedFragmentNames","selection","shouldIncludeNode","getFieldEntryKey","fieldList","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","add","fragment","skip","include","typeConditionNode","conditionalType","possibleTypes","getPossibleTypes","collectSubFields","subFieldNodes","fieldNode","visitData","enter","newData","visitErrors","visitor","visitResult","resultVisitorMap","errorVisitorMap","variables","errorInfo","segmentInfoMap","unpathedErrors","visitingErrors","operationDocumentNode","visitRoot","visitErrorsByType","unpathedErrorVisitor","pathSegmentsInfo","newError","reduceRight","segmentInfo","typeVisitorMap","errorVisitor","pathIndex","root","operationRootType","collectedFields","visitObjectValue","fieldNodeMap","enterObject","__enter","newObject","sortedErrors","errorMap","sortErrorsByPathSegment","responseKey","fieldType","newPathIndex","fieldErrors","addPathSegmentInfo","visitFieldValue","updateObject","oldTypename","__typename","errorsKey","leaveObject","__leave","fieldVisitor","visitedValue","visitListValue","list","returnType","finalType","valueMatchesCriteria","criteria","every","val","propertyName","RegExp","isAsyncIterable","isDocumentNode","withCancel","asyncIteratorLike","onCancel","savedReturn","bind","buildFixedSchema","fixSchemaAst","schemaWithValidAst"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,YAAhB,EAA8BC,aAA9B,EAA6CC,IAA7C,EAAmDC,YAAnD,EAAiEC,KAAjE,EAAwEC,YAAxE,EAAsFC,UAAtF,EAAkGC,oBAAlG,EAAwHC,YAAxH,EAAsIC,qBAAtI,EAA6JC,mBAA7J,EAAkLC,eAAlL,EAAmMC,WAAnM,EAAgNC,iBAAhN,EAAmOC,UAAnO,EAA+OC,YAA/O,EAA6PC,0BAA7P,EAAyRC,cAAzR,EAAySC,SAAzS,EAAoTC,QAApT,EAA8TC,WAA9T,EAA2UC,iBAA3U,EAA8VC,KAA9V,EAAqWC,SAArW,EAAgXC,MAAhX,EAAwXC,0BAAxX,EAAoZC,YAApZ,EAAkaC,aAAla,EAAibC,cAAjb,EAAicC,WAAjc,EAA8cC,SAA9c,EAAydC,cAAzd,EAAyeC,YAAze,EAAufC,UAAvf,EAAmgBC,iBAAngB,EAAshBC,oBAAthB,EAA4iBC,sBAA5iB,EAAokBC,gBAApkB,EAAslBC,gBAAtlB,EAAwmBC,eAAxmB,EAAynBC,iBAAznB,EAA4oBC,WAA5oB,EAAypBC,eAAzpB,EAA0qBC,UAA1qB,EAAsrBC,aAAtrB,EAAqsBC,WAArsB,EAAktBC,eAAltB,EAAmuBC,cAAnuB,EAAmvBC,eAAnvB,EAAowBC,kBAApwB,EAAwxBC,oBAAxxB,EAA8yBC,uBAA9yB,EAAu0BC,WAAv0B,EAAo1BC,cAAp1B,EAAo2BC,oBAAp2B,EAA03BC,oBAA13B,EAAg5BC,cAAh5B,QAAs6B,SAAt6B;;AAEA,MAAMC,OAAO,GAAIC,GAAD,IAAUC,KAAK,CAACC,OAAN,CAAcF,GAAd,IAAqBA,GAArB,GAA2BA,GAAG,GAAG,CAACA,GAAD,CAAH,GAAW,EAAnE;;AACA,MAAMG,eAAe,GAAG,eAAxB;;AACA,SAASC,gBAAT,CAA0BC,GAA1B,EAA+B;AAC3B,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzB,WAAO,KAAP;AACH,GAH0B,CAI3B;AACA;AACA;AACA;AACA;;;AACA,MAAIF,eAAe,CAACG,IAAhB,CAAqBD,GAArB,CAAJ,EAA+B;AAC3B,WAAO,KAAP;AACH;;AACD,MAAI;AACAhE,IAAAA,KAAK,CAACgE,GAAD,CAAL;AACA,WAAO,IAAP;AACH,GAHD,CAIA,OAAOE,CAAP,EAAU,CAAG;;AACb,SAAO,KAAP;AACH;;AACD,MAAMC,gBAAgB,GAAG,cAAzB;;AACA,SAASC,WAAT,CAAqBJ,GAArB,EAA0B;AACtB,SAAO,OAAOA,GAAP,KAAe,QAAf,IAA2B,CAACG,gBAAgB,CAACF,IAAjB,CAAsBD,GAAtB,CAAnC;AACH;;AACD,SAASK,cAAT,CAAwBC,CAAxB,EAA2BC,CAA3B,EAA8B;AAC1B,MAAIC,MAAM,CAACF,CAAD,CAAN,GAAYE,MAAM,CAACD,CAAD,CAAtB,EAA2B;AACvB,WAAO,CAAC,CAAR;AACH;;AACD,MAAIC,MAAM,CAACF,CAAD,CAAN,GAAYE,MAAM,CAACD,CAAD,CAAtB,EAA2B;AACvB,WAAO,CAAP;AACH;;AACD,SAAO,CAAP;AACH;;AACD,SAASE,YAAT,CAAsBH,CAAtB,EAAyB;AACrB,MAAII,EAAJ,EAAQC,EAAR;;AACA,MAAIC,IAAJ;;AACA,MAAI,WAAWN,CAAf,EAAkB;AACdM,IAAAA,IAAI,GAAG,CAACF,EAAE,GAAGJ,CAAC,CAACO,KAAR,MAAmB,IAAnB,IAA2BH,EAAE,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,EAAE,CAACI,KAA9D;AACH;;AACD,MAAIF,IAAI,IAAI,IAAR,IAAgB,UAAUN,CAA9B,EAAiC;AAC7BM,IAAAA,IAAI,GAAG,CAACD,EAAE,GAAGL,CAAC,CAACM,IAAR,MAAkB,IAAlB,IAA0BD,EAAE,KAAK,KAAK,CAAtC,GAA0C,KAAK,CAA/C,GAAmDA,EAAE,CAACG,KAA7D;AACH;;AACD,MAAIF,IAAI,IAAI,IAAZ,EAAkB;AACdA,IAAAA,IAAI,GAAGN,CAAC,CAACS,IAAT;AACH;;AACD,SAAOH,IAAP;AACH;;AACD,SAASI,YAAT,CAAsBV,CAAtB,EAAyBC,CAAzB,EAA4BU,QAA5B,EAAsC;AAClC,QAAMC,IAAI,GAAGT,YAAY,CAACH,CAAD,CAAzB;AACA,QAAMa,IAAI,GAAGV,YAAY,CAACF,CAAD,CAAzB;;AACA,MAAI,OAAOU,QAAP,KAAoB,UAAxB,EAAoC;AAChC,WAAOA,QAAQ,CAACC,IAAD,EAAOC,IAAP,CAAf;AACH;;AACD,SAAOd,cAAc,CAACa,IAAD,EAAOC,IAAP,CAArB;AACH;;AACD,SAASC,MAAT,CAAgBC,KAAhB,EAAuB;AACnB,SAAOA,KAAK,IAAI,IAAhB;AACH;;AACD,SAASC,UAAT,CAAoBD,KAApB,EAAkE;AAAA,MAAvCE,OAAuC,uEAA7B,2BAA6B;;AAC9D,MAAIF,KAAK,IAAI,IAAb,EAAmB;AACf,UAAM,IAAIG,KAAJ,CAAUD,OAAV,CAAN;AACH;AACJ;;AAED,IAAIE,kBAAkB,GAAGC,UAAU,CAACC,cAApC;;AACA,IAAI,OAAOF,kBAAP,KAA8B,WAAlC,EAA+C;AAC3C,QAAMG,mBAAN,SAAkCJ,KAAlC,CAAwC;AACpCK,IAAAA,WAAW,CAACC,MAAD,EAAuB;AAAA,UAAdP,OAAc,uEAAJ,EAAI;AAC9B,YAAMA,OAAN;AACA,WAAKO,MAAL,GAAcA,MAAd;AACA,WAAKlB,IAAL,GAAY,gBAAZ;AACAY,MAAAA,KAAK,CAACO,iBAAN,CAAwB,IAAxB,EAA8BH,mBAA9B;AACH;;AANmC;;AAQxCH,EAAAA,kBAAkB,GAAG,UAAUK,MAAV,EAAkBP,OAAlB,EAA2B;AAC5C,WAAO,IAAIK,mBAAJ,CAAwBE,MAAxB,EAAgCP,OAAhC,CAAP;AACH,GAFD;AAGH;;AACD,SAASS,gBAAT,CAA0BC,KAA1B,EAAiC;AAC7B,SAAO,YAAYA,KAAZ,IAAqBrC,KAAK,CAACC,OAAN,CAAcoC,KAAK,CAAC,QAAD,CAAnB,CAA5B;AACH,C,CAED;;AACA;;;AACA,MAAMC,gBAAgB,GAAG,EAAzB;AACA,MAAMC,mBAAmB,GAAG,CAA5B;AACA;AACA;AACA;;AACA,SAASC,OAAT,CAAiBtB,KAAjB,EAAwB;AACpB,SAAOuB,WAAW,CAACvB,KAAD,EAAQ,EAAR,CAAlB;AACH;;AACD,SAASuB,WAAT,CAAqBvB,KAArB,EAA4BwB,UAA5B,EAAwC;AACpC,UAAQ,OAAOxB,KAAf;AACI,SAAK,QAAL;AACI,aAAOyB,IAAI,CAACC,SAAL,CAAe1B,KAAf,CAAP;;AACJ,SAAK,UAAL;AACI,aAAOA,KAAK,CAACF,IAAN,GAAc,aAAYE,KAAK,CAACF,IAAK,GAArC,GAA0C,YAAjD;;AACJ,SAAK,QAAL;AACI,aAAO6B,iBAAiB,CAAC3B,KAAD,EAAQwB,UAAR,CAAxB;;AACJ;AACI,aAAO9B,MAAM,CAACM,KAAD,CAAb;AARR;AAUH;;AACD,SAAS4B,WAAT,CAAqB5B,KAArB,EAA4B;AACxB,MAAIA,KAAK,YAAY7E,YAArB,EAAmC;AAC/B,WAAO6E,KAAK,CAAC6B,QAAN,EAAP;AACH;;AACD,SAAQ,GAAE7B,KAAK,CAACF,IAAK,KAAIE,KAAK,CAACS,OAAQ,OAAMT,KAAK,CAAC8B,KAAM,EAAzD;AACH;;AACD,SAASH,iBAAT,CAA2B3B,KAA3B,EAAkC+B,oBAAlC,EAAwD;AACpD,MAAI/B,KAAK,KAAK,IAAd,EAAoB;AAChB,WAAO,MAAP;AACH;;AACD,MAAIA,KAAK,YAAYU,KAArB,EAA4B;AACxB,QAAIQ,gBAAgB,CAAClB,KAAD,CAApB,EAA6B;AACzB,aAAO4B,WAAW,CAAC5B,KAAD,CAAX,GAAqB,IAArB,GAA4BgC,WAAW,CAAChC,KAAK,CAACgB,MAAP,EAAee,oBAAf,CAA9C;AACH;;AACD,WAAOH,WAAW,CAAC5B,KAAD,CAAlB;AACH;;AACD,MAAI+B,oBAAoB,CAACE,QAArB,CAA8BjC,KAA9B,CAAJ,EAA0C;AACtC,WAAO,YAAP;AACH;;AACD,QAAMwB,UAAU,GAAG,CAAC,GAAGO,oBAAJ,EAA0B/B,KAA1B,CAAnB;;AACA,MAAIkC,UAAU,CAAClC,KAAD,CAAd,EAAuB;AACnB,UAAMmC,SAAS,GAAGnC,KAAK,CAACoC,MAAN,EAAlB,CADmB,CAEnB;;AACA,QAAID,SAAS,KAAKnC,KAAlB,EAAyB;AACrB,aAAO,OAAOmC,SAAP,KAAqB,QAArB,GAAgCA,SAAhC,GAA4CZ,WAAW,CAACY,SAAD,EAAYX,UAAZ,CAA9D;AACH;AACJ,GAND,MAOK,IAAI1C,KAAK,CAACC,OAAN,CAAciB,KAAd,CAAJ,EAA0B;AAC3B,WAAOgC,WAAW,CAAChC,KAAD,EAAQwB,UAAR,CAAlB;AACH;;AACD,SAAOa,YAAY,CAACrC,KAAD,EAAQwB,UAAR,CAAnB;AACH;;AACD,SAASU,UAAT,CAAoBlC,KAApB,EAA2B;AACvB,SAAO,OAAOA,KAAK,CAACoC,MAAb,KAAwB,UAA/B;AACH;;AACD,SAASC,YAAT,CAAsBC,MAAtB,EAA8Bd,UAA9B,EAA0C;AACtC,QAAMe,OAAO,GAAGC,MAAM,CAACD,OAAP,CAAeD,MAAf,CAAhB;;AACA,MAAIC,OAAO,CAACE,MAAR,KAAmB,CAAvB,EAA0B;AACtB,WAAO,IAAP;AACH;;AACD,MAAIjB,UAAU,CAACiB,MAAX,GAAoBpB,mBAAxB,EAA6C;AACzC,WAAO,MAAMqB,YAAY,CAACJ,MAAD,CAAlB,GAA6B,GAApC;AACH;;AACD,QAAMK,UAAU,GAAGJ,OAAO,CAACK,GAAR,CAAY;AAAA,QAAC,CAACC,GAAD,EAAM7C,KAAN,CAAD;AAAA,WAAkB6C,GAAG,GAAG,IAAN,GAAatB,WAAW,CAACvB,KAAD,EAAQwB,UAAR,CAA1C;AAAA,GAAZ,CAAnB;AACA,SAAO,OAAOmB,UAAU,CAACG,IAAX,CAAgB,IAAhB,CAAP,GAA+B,IAAtC;AACH;;AACD,SAASd,WAAT,CAAqBe,KAArB,EAA4BvB,UAA5B,EAAwC;AACpC,MAAIuB,KAAK,CAACN,MAAN,KAAiB,CAArB,EAAwB;AACpB,WAAO,IAAP;AACH;;AACD,MAAIjB,UAAU,CAACiB,MAAX,GAAoBpB,mBAAxB,EAA6C;AACzC,WAAO,SAAP;AACH;;AACD,QAAM2B,GAAG,GAAGC,IAAI,CAACC,GAAL,CAAS9B,gBAAT,EAA2B2B,KAAK,CAACN,MAAjC,CAAZ;AACA,QAAMU,SAAS,GAAGJ,KAAK,CAACN,MAAN,GAAeO,GAAjC;AACA,QAAMI,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyB,EAAEK,CAA3B,EAA8B;AAC1BD,IAAAA,KAAK,CAACE,IAAN,CAAW/B,WAAW,CAACwB,KAAK,CAACM,CAAD,CAAN,EAAW7B,UAAX,CAAtB;AACH;;AACD,MAAI2B,SAAS,KAAK,CAAlB,EAAqB;AACjBC,IAAAA,KAAK,CAACE,IAAN,CAAW,iBAAX;AACH,GAFD,MAGK,IAAIH,SAAS,GAAG,CAAhB,EAAmB;AACpBC,IAAAA,KAAK,CAACE,IAAN,CAAY,OAAMH,SAAU,aAA5B;AACH;;AACD,SAAO,MAAMC,KAAK,CAACN,IAAN,CAAW,IAAX,CAAN,GAAyB,GAAhC;AACH;;AACD,SAASJ,YAAT,CAAsBJ,MAAtB,EAA8B;AAC1B,QAAMiB,GAAG,GAAGf,MAAM,CAACgB,SAAP,CAAiB3B,QAAjB,CACP4B,IADO,CACFnB,MADE,EAEPoB,OAFO,CAEC,YAFD,EAEe,EAFf,EAGPA,OAHO,CAGC,IAHD,EAGO,EAHP,CAAZ;;AAIA,MAAIH,GAAG,KAAK,QAAR,IAAoB,OAAOjB,MAAM,CAACvB,WAAd,KAA8B,UAAtD,EAAkE;AAC9D,UAAMjB,IAAI,GAAGwC,MAAM,CAACvB,WAAP,CAAmBjB,IAAhC;;AACA,QAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,EAAzC,EAA6C;AACzC,aAAOA,IAAP;AACH;AACJ;;AACD,SAAOyD,GAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,iBAAT,CAA2BC,GAA3B,EAAgCC,IAAhC,EAA2D;AAAA,MAArBC,cAAqB,uEAAJ,EAAI;;AACvD,MAAIlE,EAAJ;;AACA,QAAMmE,WAAW,GAAGvB,MAAM,CAACD,OAAP,CAAeuB,cAAf,EAA+BE,MAA/B,CAAsC,CAACC,IAAD;AAAA,QAAO,CAACpB,GAAD,EAAM7C,KAAN,CAAP;AAAA,WAAyB,EAC/E,GAAGiE,IAD4E;AAE/E,OAACpB,GAAD,GAAO7C;AAFwE,KAAzB;AAAA,GAAtC,EAGhB,EAHgB,CAApB;AAIA,QAAMkE,aAAa,GAAG,EAAtB,CANuD,CAOvD;;AACA,QAAMC,aAAa,GAAG,CAACvE,EAAE,GAAGiE,IAAI,CAACO,SAAX,MAA0B,IAA1B,IAAkCxE,EAAE,KAAK,KAAK,CAA9C,GAAkDA,EAAlD,GAAuD,EAA7E;AACA,QAAMyE,UAAU,GAAGF,aAAa,CAACH,MAAd,CAAqB,CAACC,IAAD,EAAOK,GAAP,MAAgB,EACpD,GAAGL,IADiD;AAEpD,KAACK,GAAG,CAACxE,IAAJ,CAASE,KAAV,GAAkBsE;AAFkC,GAAhB,CAArB,EAGf,EAHe,CAAnB;;AAIA,OAAK,MAAM;AAAExE,IAAAA,IAAF;AAAQyE,IAAAA,IAAI,EAAEC,OAAd;AAAuBC,IAAAA;AAAvB,GAAX,IAAoDb,GAAG,CAACc,IAAxD,EAA8D;AAC1D,UAAMC,YAAY,GAAGN,UAAU,CAACvE,IAAD,CAA/B;;AACA,QAAI,CAAC6E,YAAL,EAAmB;AACf,UAAIF,YAAY,KAAKG,SAArB,EAAgC;AAC5BV,QAAAA,aAAa,CAACpE,IAAD,CAAb,GAAsB2E,YAAtB;AACH,OAFD,MAGK,IAAIrJ,aAAa,CAACoJ,OAAD,CAAjB,EAA4B;AAC7B,cAAM,IAAIrJ,YAAJ,CAAkB,aAAY2E,IAAK,uBAAsBwB,OAAO,CAACkD,OAAD,CAAU,IAAzD,GAA+D,mBAAhF,EAAqGX,IAArG,CAAN;AACH;;AACD;AACH;;AACD,UAAMgB,SAAS,GAAGF,YAAY,CAAC3E,KAA/B;AACA,QAAI8E,MAAM,GAAGD,SAAS,CAAC5E,IAAV,KAAmB5E,IAAI,CAAC0J,IAArC;;AACA,QAAIF,SAAS,CAAC5E,IAAV,KAAmB5E,IAAI,CAAC2J,QAA5B,EAAsC;AAClC,YAAMC,YAAY,GAAGJ,SAAS,CAAC/E,IAAV,CAAeE,KAApC;;AACA,UAAI8D,cAAc,IAAI,IAAlB,IAA0B,CAACC,WAAW,CAACkB,YAAD,CAA1C,EAA0D;AACtD,YAAIR,YAAY,KAAKG,SAArB,EAAgC;AAC5BV,UAAAA,aAAa,CAACpE,IAAD,CAAb,GAAsB2E,YAAtB;AACH,SAFD,MAGK,IAAIrJ,aAAa,CAACoJ,OAAD,CAAjB,EAA4B;AAC7B,gBAAM,IAAIrJ,YAAJ,CAAkB,aAAY2E,IAAK,uBAAsBwB,OAAO,CAACkD,OAAD,CAAU,IAAzD,GAClB,+BAA8BS,YAAa,2CAD1C,EACsFJ,SADtF,CAAN;AAEH;;AACD;AACH;;AACDC,MAAAA,MAAM,GAAGhB,cAAc,CAACmB,YAAD,CAAd,IAAgC,IAAzC;AACH;;AACD,QAAIH,MAAM,IAAI1J,aAAa,CAACoJ,OAAD,CAA3B,EAAsC;AAClC,YAAM,IAAIrJ,YAAJ,CAAkB,aAAY2E,IAAK,uBAAsBwB,OAAO,CAACkD,OAAD,CAAU,IAAzD,GAA+D,mBAAhF,EAAqGK,SAArG,CAAN;AACH;;AACD,UAAMK,YAAY,GAAG5J,YAAY,CAACuJ,SAAD,EAAYL,OAAZ,EAAqBV,cAArB,CAAjC;;AACA,QAAIoB,YAAY,KAAKN,SAArB,EAAgC;AAC5B;AACA;AACA;AACA,YAAM,IAAIzJ,YAAJ,CAAkB,aAAY2E,IAAK,uBAAsBvE,KAAK,CAACsJ,SAAD,CAAY,GAA1E,EAA8EA,SAA9E,CAAN;AACH;;AACDX,IAAAA,aAAa,CAACpE,IAAD,CAAb,GAAsBoF,YAAtB;AACH;;AACD,SAAOhB,aAAP;AACH;;AAED,SAASiB,yBAAT,CAAmCtB,IAAnC,EAAwF;AAAA,MAA/CuB,4BAA+C,uEAAhB,CAAC,YAAD,CAAgB;AACpF,SAAOA,4BAA4B,CAACpB,MAA7B,CAAoC,CAACqB,GAAD,EAAMC,WAAN,KAAuBD,GAAG,IAAI,IAAP,GAAcA,GAAd,GAAoBA,GAAG,CAACC,WAAD,CAAlF,EAAkGzB,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAAC0B,UAAnJ,CAAP;AACH;;AACD,SAASC,yBAAT,CAAmCC,sBAAnC,EAA2DC,aAA3D,EAA0E;AACtE,QAAMC,qBAAqB,GAAGF,sBAAsB,CAACG,MAAvB,CAA8BC,mBAAmB,IAAIA,mBAAmB,CAAC/F,IAApB,KAA6B4F,aAAlF,CAA9B;;AACA,MAAI,CAACC,qBAAqB,CAAClD,MAA3B,EAAmC;AAC/B,WAAOmC,SAAP;AACH;;AACD,SAAOe,qBAAqB,CAAC/C,GAAtB,CAA0BkD,SAAS,IAAI;AAAE,QAAIlG,EAAJ;;AAAQ,WAAO,CAACA,EAAE,GAAGkG,SAAS,CAACpB,IAAhB,MAA0B,IAA1B,IAAkC9E,EAAE,KAAK,KAAK,CAA9C,GAAkDA,EAAlD,GAAuD,EAA9D;AAAmE,GAApH,CAAP;AACH;;AACD,SAASmG,wBAAT,CAAkClC,IAAlC,EAAwC6B,aAAxC,EAAsG;AAAA,MAA/CN,4BAA+C,uEAAhB,CAAC,YAAD,CAAgB;AAClG,QAAMK,sBAAsB,GAAGL,4BAA4B,CAACpB,MAA7B,CAAoC,CAACqB,GAAD,EAAMC,WAAN,KAAuBD,GAAG,IAAI,IAAP,GAAcA,GAAd,GAAoBA,GAAG,CAACC,WAAD,CAAlF,EAAkGzB,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAAC0B,UAAnJ,CAA/B;;AACA,MAAIE,sBAAsB,KAAKb,SAA/B,EAA0C;AACtC,WAAOA,SAAP;AACH;;AACD,MAAI9F,KAAK,CAACC,OAAN,CAAc0G,sBAAd,CAAJ,EAA2C;AACvC,WAAOD,yBAAyB,CAACC,sBAAD,EAAyBC,aAAzB,CAAhC;AACH,GAPiG,CAQlG;AACA;AACA;;;AACA,QAAMM,iCAAiC,GAAG,EAA1C;;AACA,OAAK,MAAM,CAAClG,IAAD,EAAOmG,iBAAP,CAAX,IAAwCzD,MAAM,CAACD,OAAP,CAAekD,sBAAf,CAAxC,EAAgF;AAC5E,QAAI3G,KAAK,CAACC,OAAN,CAAckH,iBAAd,CAAJ,EAAsC;AAClC,WAAK,MAAMvB,IAAX,IAAmBuB,iBAAnB,EAAsC;AAClCD,QAAAA,iCAAiC,CAAC1C,IAAlC,CAAuC;AAAExD,UAAAA,IAAF;AAAQ4E,UAAAA;AAAR,SAAvC;AACH;AACJ,KAJD,MAKK;AACDsB,MAAAA,iCAAiC,CAAC1C,IAAlC,CAAuC;AAAExD,QAAAA,IAAF;AAAQ4E,QAAAA,IAAI,EAAEuB;AAAd,OAAvC;AACH;AACJ;;AACD,SAAOT,yBAAyB,CAACQ,iCAAD,EAAoCN,aAApC,CAAhC;AACH;;AACD,SAASQ,aAAT,CAAuBC,MAAvB,EAA+BtC,IAA/B,EAAoF;AAAA,MAA/CuB,4BAA+C,uEAAhB,CAAC,YAAD,CAAgB;AAChF,QAAMK,sBAAsB,GAAGN,yBAAyB,CAACtB,IAAD,EAAOuB,4BAAP,CAAxD;;AACA,MAAIK,sBAAsB,IAAI,IAA1B,IAAkCA,sBAAsB,CAAChD,MAAvB,GAAgC,CAAtE,EAAyE;AACrE,WAAOgD,sBAAP;AACH;;AACD,QAAMW,gBAAgB,GAAGD,MAAM,IAAIA,MAAM,CAACD,aAAjB,GAAiCC,MAAM,CAACD,aAAP,EAAjC,GAA0D,EAAnF;AACA,QAAMG,kBAAkB,GAAGD,gBAAgB,CAACpC,MAAjB,CAAwB,CAACqC,kBAAD,EAAqBC,eAArB,KAAyC;AACxFD,IAAAA,kBAAkB,CAACC,eAAe,CAACxG,IAAjB,CAAlB,GAA2CwG,eAA3C;AACA,WAAOD,kBAAP;AACH,GAH0B,EAGxB,EAHwB,CAA3B;AAIA,MAAIE,QAAQ,GAAG,EAAf;;AACA,MAAI1C,IAAI,CAAC2C,OAAT,EAAkB;AACdD,IAAAA,QAAQ,CAACjD,IAAT,CAAcO,IAAI,CAAC2C,OAAnB;AACH;;AACD,MAAI,uBAAuB3C,IAAvB,IAA+BA,IAAI,CAAC4C,iBAAxC,EAA2D;AACvDF,IAAAA,QAAQ,GAAG,CAAC,GAAGA,QAAJ,EAAc,GAAG1C,IAAI,CAAC4C,iBAAtB,CAAX;AACH;;AACD,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMF,OAAX,IAAsBD,QAAtB,EAAgC;AAC5B,QAAIC,OAAO,CAACG,UAAZ,EAAwB;AACpB,WAAK,MAAMC,aAAX,IAA4BJ,OAAO,CAACG,UAApC,EAAgD;AAC5C,cAAML,eAAe,GAAGD,kBAAkB,CAACO,aAAa,CAAC9G,IAAd,CAAmBE,KAApB,CAA1C;;AACA,YAAIsG,eAAJ,EAAqB;AACjBI,UAAAA,MAAM,CAACpD,IAAP,CAAY;AAAExD,YAAAA,IAAI,EAAE8G,aAAa,CAAC9G,IAAd,CAAmBE,KAA3B;AAAkC0E,YAAAA,IAAI,EAAEf,iBAAiB,CAAC2C,eAAD,EAAkBM,aAAlB;AAAzD,WAAZ;AACH;AACJ;AACJ;AACJ;;AACD,SAAOF,MAAP;AACH;;AACD,SAASG,YAAT,CAAsBV,MAAtB,EAA8BtC,IAA9B,EAAoC6B,aAApC,EAAkG;AAAA,MAA/CN,4BAA+C,uEAAhB,CAAC,YAAD,CAAgB;AAC9F,QAAMO,qBAAqB,GAAGI,wBAAwB,CAAClC,IAAD,EAAO6B,aAAP,EAAsBN,4BAAtB,CAAtD;;AACA,MAAIO,qBAAqB,IAAI,IAA7B,EAAmC;AAC/B,WAAOA,qBAAP;AACH;;AACD,QAAMW,eAAe,GAAGH,MAAM,IAAIA,MAAM,CAACU,YAAjB,GAAgCV,MAAM,CAACU,YAAP,CAAoBnB,aAApB,CAAhC,GAAqEd,SAA7F;;AACA,MAAI0B,eAAe,IAAI,IAAvB,EAA6B;AACzB,WAAO1B,SAAP;AACH;;AACD,MAAI2B,QAAQ,GAAG,EAAf;;AACA,MAAI1C,IAAI,CAAC2C,OAAT,EAAkB;AACdD,IAAAA,QAAQ,CAACjD,IAAT,CAAcO,IAAI,CAAC2C,OAAnB;AACH;;AACD,MAAI,uBAAuB3C,IAAvB,IAA+BA,IAAI,CAAC4C,iBAAxC,EAA2D;AACvDF,IAAAA,QAAQ,GAAG,CAAC,GAAGA,QAAJ,EAAc,GAAG1C,IAAI,CAAC4C,iBAAtB,CAAX;AACH;;AACD,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMF,OAAX,IAAsBD,QAAtB,EAAgC;AAC5B,QAAIC,OAAO,CAACG,UAAZ,EAAwB;AACpB,WAAK,MAAMC,aAAX,IAA4BJ,OAAO,CAACG,UAApC,EAAgD;AAC5C,YAAIC,aAAa,CAAC9G,IAAd,CAAmBE,KAAnB,KAA6B0F,aAAjC,EAAgD;AAC5CgB,UAAAA,MAAM,CAACpD,IAAP,CAAYK,iBAAiB,CAAC2C,eAAD,EAAkBM,aAAlB,CAA7B;AACH;AACJ;AACJ;AACJ;;AACD,MAAI,CAACF,MAAM,CAACjE,MAAZ,EAAoB;AAChB,WAAOmC,SAAP;AACH;;AACD,SAAO8B,MAAP;AACH;;AAED,SAASI,mBAAT,CAA6B9G,KAA7B,EAAoC;AAChC,UAAQA,KAAK,CAACC,IAAd;AACI,SAAK5E,IAAI,CAAC0L,GAAV;AACI,aAAOC,QAAQ,CAAChH,KAAK,CAACA,KAAP,CAAf;;AACJ,SAAK3E,IAAI,CAAC4L,KAAV;AACI,aAAOC,UAAU,CAAClH,KAAK,CAACA,KAAP,CAAjB;;AACJ,SAAK3E,IAAI,CAAC8L,OAAV;AACI,aAAOC,OAAO,CAACpH,KAAK,CAACA,KAAP,CAAd;;AACJ,SAAK3E,IAAI,CAACgM,MAAV;AACA,SAAKhM,IAAI,CAACiM,IAAV;AACI,aAAOtH,KAAK,CAACA,KAAb;;AACJ,SAAK3E,IAAI,CAACkM,IAAV;AACI,aAAOvH,KAAK,CAACwH,MAAN,CAAa5E,GAAb,CAAiB6E,CAAC,IAAIX,mBAAmB,CAACW,CAAD,CAAzC,CAAP;;AACJ,SAAKpM,IAAI,CAACqM,MAAV;AACI,aAAO1H,KAAK,CAAC2H,MAAN,CAAa3D,MAAb,CAAoB,CAACC,IAAD,EAAOwD,CAAP,MAAc,EAAE,GAAGxD,IAAL;AAAW,SAACwD,CAAC,CAAC3H,IAAF,CAAOE,KAAR,GAAgB8G,mBAAmB,CAACW,CAAC,CAACzH,KAAH;AAA9C,OAAd,CAApB,EAA8F,EAA9F,CAAP;;AACJ,SAAK3E,IAAI,CAAC0J,IAAV;AACI,aAAO,IAAP;;AACJ;AACI,aAAO,IAAP;AAjBR;AAmBH;;AACD,SAAS6C,uBAAT,CAAiCC,YAAjC,EAA6D;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AACzD,QAAMpB,MAAM,GAAG,EAAf;AACA,MAAIqB,QAAQ,GAAG,CAAC,sBAAD,EAAyB,qBAAzB,CAAf;;AACA,MAAID,OAAO,CAACE,iBAAZ,EAA+B;AAC3BD,IAAAA,QAAQ,GAAG,CAAC,GAAGA,QAAJ,EAAc,2BAAd,EAA2C,0BAA3C,CAAX;AACH;;AACD,QAAME,QAAQ,GAAGJ,YAAY,CAACK,WAAb,CAAyBtC,MAAzB,CAAgCuC,GAAG,IAAIJ,QAAQ,CAAC9F,QAAT,CAAkBkG,GAAG,CAAClI,IAAtB,CAAvC,CAAjB;;AACA,OAAK,MAAMsE,IAAX,IAAmB0D,QAAnB,EAA6B;AACzB,UAAMG,QAAQ,GAAG7D,IAAI,CAACzE,IAAL,CAAUE,KAA3B;;AACA,QAAIuE,IAAI,CAACoD,MAAL,IAAe,IAAnB,EAAyB;AACrB;AACH;;AACD,SAAK,MAAMU,KAAX,IAAoB9D,IAAI,CAACoD,MAAzB,EAAiC;AAC7B,UAAIU,KAAK,CAAC1B,UAAN,IAAoB0B,KAAK,CAAC1B,UAAN,CAAiBlE,MAAjB,GAA0B,CAAlD,EAAqD;AACjD,cAAM6F,SAAS,GAAGD,KAAK,CAACvI,IAAN,CAAWE,KAA7B;AACA,cAAM6C,GAAG,GAAI,GAAEuF,QAAS,IAAGE,SAAU,EAArC;AACA,cAAM3B,UAAU,GAAG0B,KAAK,CAAC1B,UAAN,CAAiB/D,GAAjB,CAAqB2F,CAAC,KAAK;AAC1CzI,UAAAA,IAAI,EAAEyI,CAAC,CAACzI,IAAF,CAAOE,KAD6B;AAE1C0E,UAAAA,IAAI,EAAE,CAAC6D,CAAC,CAACnE,SAAF,IAAe,EAAhB,EAAoBJ,MAApB,CAA2B,CAACC,IAAD,EAAOK,GAAP,MAAgB,EAAE,GAAGL,IAAL;AAAW,aAACK,GAAG,CAACxE,IAAJ,CAASE,KAAV,GAAkB8G,mBAAmB,CAACxC,GAAG,CAACtE,KAAL;AAAhD,WAAhB,CAA3B,EAA2G,EAA3G;AAFoC,SAAL,CAAtB,CAAnB;AAIA0G,QAAAA,MAAM,CAAC7D,GAAD,CAAN,GAAc8D,UAAd;AACH;AACJ;AACJ;;AACD,SAAOD,MAAP;AACH;;AAED,SAAS8B,oBAAT,CAA8BC,aAA9B,EAA6CtC,MAA7C,EAAqD;AACjD,QAAMuC,WAAW,GAAGvC,MAAM,CAACwC,UAAP,EAApB;AACA,QAAMjC,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMkC,eAAX,IAA8BF,WAA9B,EAA2C;AACvC,UAAMG,WAAW,GAAGH,WAAW,CAACE,eAAD,CAA/B;;AACA,QAAIpN,YAAY,CAACqN,WAAD,CAAhB,EAA+B;AAC3B,YAAMC,aAAa,GAAGD,WAAW,CAACE,aAAZ,EAAtB;;AACA,UAAID,aAAa,CAACE,IAAd,CAAmBC,GAAG,IAAIA,GAAG,CAACnJ,IAAJ,KAAa2I,aAAvC,CAAJ,EAA2D;AACvD/B,QAAAA,MAAM,CAACpD,IAAP,CAAYuF,WAAW,CAAC/I,IAAxB;AACH;AACJ;AACJ;;AACD,SAAO4G,MAAP;AACH;;AAED,SAASwC,WAAT,CAAqB3E,IAArB,EAA2B;AACvB,MAAInJ,aAAa,CAACmJ,IAAD,CAAjB,EAAyB;AACrB,UAAM4E,SAAS,GAAGD,WAAW,CAAC3E,IAAI,CAAC6E,MAAN,CAA7B;;AACA,QAAID,SAAS,CAAClJ,IAAV,KAAmB5E,IAAI,CAACgO,aAA5B,EAA2C;AACvC,YAAM,IAAI3I,KAAJ,CAAW,qBAAoBY,OAAO,CAACiD,IAAD,CAAO,0DAA7C,CAAN;AACH;;AACD,WAAO;AACHtE,MAAAA,IAAI,EAAE5E,IAAI,CAACgO,aADR;AAEH9E,MAAAA,IAAI,EAAE4E;AAFH,KAAP;AAIH,GATD,MAUK,IAAI1N,UAAU,CAAC8I,IAAD,CAAd,EAAsB;AACvB,WAAO;AACHtE,MAAAA,IAAI,EAAE5E,IAAI,CAACiO,SADR;AAEH/E,MAAAA,IAAI,EAAE2E,WAAW,CAAC3E,IAAI,CAAC6E,MAAN;AAFd,KAAP;AAIH;;AACD,SAAO;AACHnJ,IAAAA,IAAI,EAAE5E,IAAI,CAACkO,UADR;AAEHzJ,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV;AAFH,GAAP;AAOH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS2J,mBAAT,CAA6BzJ,KAA7B,EAAoC;AAChC;AACA,MAAIA,KAAK,KAAK,IAAd,EAAoB;AAChB,WAAO;AAAEC,MAAAA,IAAI,EAAE5E,IAAI,CAAC0J;AAAb,KAAP;AACH,GAJ+B,CAKhC;;;AACA,MAAI/E,KAAK,KAAK4E,SAAd,EAAyB;AACrB,WAAO,IAAP;AACH,GAR+B,CAShC;AACA;;;AACA,MAAI9F,KAAK,CAACC,OAAN,CAAciB,KAAd,CAAJ,EAA0B;AACtB,UAAM0J,WAAW,GAAG,EAApB;;AACA,SAAK,MAAMC,IAAX,IAAmB3J,KAAnB,EAA0B;AACtB,YAAM4J,QAAQ,GAAGH,mBAAmB,CAACE,IAAD,CAApC;;AACA,UAAIC,QAAQ,IAAI,IAAhB,EAAsB;AAClBF,QAAAA,WAAW,CAACpG,IAAZ,CAAiBsG,QAAjB;AACH;AACJ;;AACD,WAAO;AAAE3J,MAAAA,IAAI,EAAE5E,IAAI,CAACkM,IAAb;AAAmBC,MAAAA,MAAM,EAAEkC;AAA3B,KAAP;AACH;;AACD,MAAI,OAAO1J,KAAP,KAAiB,QAArB,EAA+B;AAC3B,UAAM6J,UAAU,GAAG,EAAnB;;AACA,SAAK,MAAMvB,SAAX,IAAwBtI,KAAxB,EAA+B;AAC3B,YAAM8J,UAAU,GAAG9J,KAAK,CAACsI,SAAD,CAAxB;AACA,YAAMyB,GAAG,GAAGN,mBAAmB,CAACK,UAAD,CAA/B;;AACA,UAAIC,GAAJ,EAAS;AACLF,QAAAA,UAAU,CAACvG,IAAX,CAAgB;AACZrD,UAAAA,IAAI,EAAE5E,IAAI,CAAC2O,YADC;AAEZlK,UAAAA,IAAI,EAAE;AAAEG,YAAAA,IAAI,EAAE5E,IAAI,CAACmO,IAAb;AAAmBxJ,YAAAA,KAAK,EAAEsI;AAA1B,WAFM;AAGZtI,UAAAA,KAAK,EAAE+J;AAHK,SAAhB;AAKH;AACJ;;AACD,WAAO;AAAE9J,MAAAA,IAAI,EAAE5E,IAAI,CAACqM,MAAb;AAAqBC,MAAAA,MAAM,EAAEkC;AAA7B,KAAP;AACH,GAnC+B,CAoChC;;;AACA,MAAI,OAAO7J,KAAP,KAAiB,SAArB,EAAgC;AAC5B,WAAO;AAAEC,MAAAA,IAAI,EAAE5E,IAAI,CAAC8L,OAAb;AAAsBnH,MAAAA;AAAtB,KAAP;AACH,GAvC+B,CAwChC;;;AACA,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BiK,QAAQ,CAACjK,KAAD,CAAzC,EAAkD;AAC9C,UAAMkK,SAAS,GAAGxK,MAAM,CAACM,KAAD,CAAxB;AACA,WAAOmK,mBAAmB,CAAChL,IAApB,CAAyB+K,SAAzB,IACD;AAAEjK,MAAAA,IAAI,EAAE5E,IAAI,CAAC0L,GAAb;AAAkB/G,MAAAA,KAAK,EAAEkK;AAAzB,KADC,GAED;AAAEjK,MAAAA,IAAI,EAAE5E,IAAI,CAAC4L,KAAb;AAAoBjH,MAAAA,KAAK,EAAEkK;AAA3B,KAFN;AAGH;;AACD,MAAI,OAAOlK,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAO;AAAEC,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MAAb;AAAqBrH,MAAAA;AAArB,KAAP;AACH;;AACD,QAAM,IAAIoK,SAAJ,CAAe,gCAA+BpK,KAAM,GAApD,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,MAAMmK,mBAAmB,GAAG,uBAA5B;;AAEA,SAASE,QAAT,CAAkBC,EAAlB,EAAsB;AAClB,QAAMC,aAAa,GAAG,IAAIC,OAAJ,EAAtB;AACA,SAAO,SAASC,QAAT,CAAkBC,EAAlB,EAAsB;AACzB,UAAMC,WAAW,GAAGJ,aAAa,CAACK,GAAd,CAAkBF,EAAlB,CAApB;;AACA,QAAIC,WAAW,KAAK/F,SAApB,EAA+B;AAC3B,YAAMiG,QAAQ,GAAGP,EAAE,CAACI,EAAD,CAAnB;AACAH,MAAAA,aAAa,CAACO,GAAd,CAAkBJ,EAAlB,EAAsBG,QAAtB;AACA,aAAOA,QAAP;AACH;;AACD,WAAOF,WAAP;AACH,GARD;AASH;;AACD,SAASI,QAAT,CAAkBT,EAAlB,EAAsB;AAClB,QAAMU,aAAa,GAAG,IAAIR,OAAJ,EAAtB;AACA,SAAO,SAASC,QAAT,CAAkBC,EAAlB,EAAsBO,EAAtB,EAA0B;AAC7B,QAAIC,MAAM,GAAGF,aAAa,CAACJ,GAAd,CAAkBF,EAAlB,CAAb;;AACA,QAAI,CAACQ,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAIV,OAAJ,EAAT;AACAQ,MAAAA,aAAa,CAACF,GAAd,CAAkBJ,EAAlB,EAAsBQ,MAAtB;AACA,YAAML,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,CAAnB;AACAC,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeJ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,UAAMF,WAAW,GAAGO,MAAM,CAACN,GAAP,CAAWK,EAAX,CAApB;;AACA,QAAIN,WAAW,KAAK/F,SAApB,EAA+B;AAC3B,YAAMiG,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,CAAnB;AACAC,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeJ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,WAAOF,WAAP;AACH,GAhBD;AAiBH;;AACD,SAASQ,QAAT,CAAkBb,EAAlB,EAAsB;AAClB,QAAMc,aAAa,GAAG,IAAIZ,OAAJ,EAAtB;AACA,SAAO,SAASC,QAAT,CAAkBC,EAAlB,EAAsBO,EAAtB,EAA0BI,EAA1B,EAA8B;AACjC,QAAIH,MAAM,GAAGE,aAAa,CAACR,GAAd,CAAkBF,EAAlB,CAAb;;AACA,QAAI,CAACQ,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAIV,OAAJ,EAAT;AACAY,MAAAA,aAAa,CAACN,GAAd,CAAkBJ,EAAlB,EAAsBQ,MAAtB;AACA,YAAMI,MAAM,GAAG,IAAId,OAAJ,EAAf;AACAU,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeK,MAAf;AACA,YAAMT,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,CAAnB;AACAC,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeR,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,QAAIS,MAAM,GAAGJ,MAAM,CAACN,GAAP,CAAWK,EAAX,CAAb;;AACA,QAAI,CAACK,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAId,OAAJ,EAAT;AACAU,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeK,MAAf;AACA,YAAMT,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,CAAnB;AACAC,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeR,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,UAAMF,WAAW,GAAGW,MAAM,CAACV,GAAP,CAAWS,EAAX,CAApB;;AACA,QAAIV,WAAW,KAAK/F,SAApB,EAA+B;AAC3B,YAAMiG,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,CAAnB;AACAC,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeR,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,WAAOF,WAAP;AACH,GA1BD;AA2BH;;AACD,SAASY,QAAT,CAAkBjB,EAAlB,EAAsB;AAClB,QAAMkB,aAAa,GAAG,IAAIhB,OAAJ,EAAtB;AACA,SAAO,SAASC,QAAT,CAAkBC,EAAlB,EAAsBO,EAAtB,EAA0BI,EAA1B,EAA8BI,EAA9B,EAAkC;AACrC,QAAIP,MAAM,GAAGM,aAAa,CAACZ,GAAd,CAAkBF,EAAlB,CAAb;;AACA,QAAI,CAACQ,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAIV,OAAJ,EAAT;AACAgB,MAAAA,aAAa,CAACV,GAAd,CAAkBJ,EAAlB,EAAsBQ,MAAtB;AACA,YAAMI,MAAM,GAAG,IAAId,OAAJ,EAAf;AACAU,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeK,MAAf;AACA,YAAMI,MAAM,GAAG,IAAIlB,OAAJ,EAAf;AACAc,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeK,MAAf;AACA,YAAMb,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,CAAnB;AACAC,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeZ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,QAAIS,MAAM,GAAGJ,MAAM,CAACN,GAAP,CAAWK,EAAX,CAAb;;AACA,QAAI,CAACK,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAId,OAAJ,EAAT;AACAU,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeK,MAAf;AACA,YAAMI,MAAM,GAAG,IAAIlB,OAAJ,EAAf;AACAc,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeK,MAAf;AACA,YAAMb,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,CAAnB;AACAC,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeZ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,UAAMa,MAAM,GAAGJ,MAAM,CAACV,GAAP,CAAWS,EAAX,CAAf;;AACA,QAAI,CAACK,MAAL,EAAa;AACT,YAAMA,MAAM,GAAG,IAAIlB,OAAJ,EAAf;AACAc,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeK,MAAf;AACA,YAAMb,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,CAAnB;AACAC,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeZ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,UAAMF,WAAW,GAAGe,MAAM,CAACd,GAAP,CAAWa,EAAX,CAApB;;AACA,QAAId,WAAW,KAAK/F,SAApB,EAA+B;AAC3B,YAAMiG,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,CAAnB;AACAC,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeZ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,WAAOF,WAAP;AACH,GAtCD;AAuCH;;AACD,SAASgB,QAAT,CAAkBrB,EAAlB,EAAsB;AAClB,QAAMsB,aAAa,GAAG,IAAIpB,OAAJ,EAAtB;AACA,SAAO,SAASC,QAAT,CAAkBC,EAAlB,EAAsBO,EAAtB,EAA0BI,EAA1B,EAA8BI,EAA9B,EAAkCI,EAAlC,EAAsC;AACzC,QAAIX,MAAM,GAAGU,aAAa,CAAChB,GAAd,CAAkBF,EAAlB,CAAb;;AACA,QAAI,CAACQ,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAIV,OAAJ,EAAT;AACAoB,MAAAA,aAAa,CAACd,GAAd,CAAkBJ,EAAlB,EAAsBQ,MAAtB;AACA,YAAMI,MAAM,GAAG,IAAId,OAAJ,EAAf;AACAU,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeK,MAAf;AACA,YAAMI,MAAM,GAAG,IAAIlB,OAAJ,EAAf;AACAc,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeK,MAAf;AACA,YAAMI,MAAM,GAAG,IAAItB,OAAJ,EAAf;AACAkB,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeK,MAAf;AACA,YAAMjB,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,EAAiBI,EAAjB,CAAnB;AACAC,MAAAA,MAAM,CAAChB,GAAP,CAAWe,EAAX,EAAehB,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,QAAIS,MAAM,GAAGJ,MAAM,CAACN,GAAP,CAAWK,EAAX,CAAb;;AACA,QAAI,CAACK,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAId,OAAJ,EAAT;AACAU,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeK,MAAf;AACA,YAAMI,MAAM,GAAG,IAAIlB,OAAJ,EAAf;AACAc,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeK,MAAf;AACA,YAAMI,MAAM,GAAG,IAAItB,OAAJ,EAAf;AACAkB,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeK,MAAf;AACA,YAAMjB,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,EAAiBI,EAAjB,CAAnB;AACAC,MAAAA,MAAM,CAAChB,GAAP,CAAWe,EAAX,EAAehB,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,QAAIa,MAAM,GAAGJ,MAAM,CAACV,GAAP,CAAWS,EAAX,CAAb;;AACA,QAAI,CAACK,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAIlB,OAAJ,EAAT;AACAc,MAAAA,MAAM,CAACR,GAAP,CAAWO,EAAX,EAAeK,MAAf;AACA,YAAMI,MAAM,GAAG,IAAItB,OAAJ,EAAf;AACAkB,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeK,MAAf;AACA,YAAMjB,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,EAAiBI,EAAjB,CAAnB;AACAC,MAAAA,MAAM,CAAChB,GAAP,CAAWe,EAAX,EAAehB,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,QAAIiB,MAAM,GAAGJ,MAAM,CAACd,GAAP,CAAWa,EAAX,CAAb;;AACA,QAAI,CAACK,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAItB,OAAJ,EAAT;AACAkB,MAAAA,MAAM,CAACZ,GAAP,CAAWW,EAAX,EAAeK,MAAf;AACA,YAAMjB,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,EAAiBI,EAAjB,CAAnB;AACAC,MAAAA,MAAM,CAAChB,GAAP,CAAWe,EAAX,EAAehB,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,UAAMF,WAAW,GAAGmB,MAAM,CAAClB,GAAP,CAAWiB,EAAX,CAApB;;AACA,QAAIlB,WAAW,KAAK/F,SAApB,EAA+B;AAC3B,YAAMiG,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,EAAiBI,EAAjB,CAAnB;AACAC,MAAAA,MAAM,CAAChB,GAAP,CAAWe,EAAX,EAAehB,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,WAAOF,WAAP;AACH,GApDD;AAqDH;;AACD,MAAMoB,gBAAgB,GAAG,IAAIvB,OAAJ,EAAzB;;AACA,SAASwB,WAAT,CAAqB1B,EAArB,EAAyB;AACrB,SAAO,SAASG,QAAT,CAAkBC,EAAlB,EAAsBO,EAAtB,EAA0BI,EAA1B,EAA8BI,EAA9B,EAAkC;AACrC,QAAIP,MAAM,GAAGa,gBAAgB,CAACnB,GAAjB,CAAqBF,EAArB,CAAb;;AACA,QAAI,CAACQ,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,IAAIV,OAAJ,EAAT;AACAuB,MAAAA,gBAAgB,CAACjB,GAAjB,CAAqBJ,EAArB,EAAyBQ,MAAzB;AACA,YAAML,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,CAAnB;AACAP,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeJ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,UAAMF,WAAW,GAAGO,MAAM,CAACN,GAAP,CAAWK,EAAX,CAApB;;AACA,QAAIN,WAAW,KAAK/F,SAApB,EAA+B;AAC3B,YAAMiG,QAAQ,GAAGP,EAAE,CAACI,EAAD,EAAKO,EAAL,EAASI,EAAT,EAAaI,EAAb,CAAnB;AACAP,MAAAA,MAAM,CAACJ,GAAP,CAAWG,EAAX,EAAeJ,QAAf;AACA,aAAOA,QAAP;AACH;;AACD,WAAOF,WAAP;AACH,GAhBD;AAiBH;;AAED,SAASsB,kBAAT,CAA4B9F,MAA5B,EAAoC+F,SAApC,EAA+C;AAC3C,QAAMC,WAAW,GAAGC,cAAc,CAACjG,MAAD,CAAlC;AACA,QAAMkG,QAAQ,GAAGF,WAAW,CAACvB,GAAZ,CAAgBsB,SAAhB,CAAjB;;AACA,MAAIG,QAAQ,IAAI,IAAhB,EAAsB;AAClB,UAAM,IAAI3L,KAAJ,CAAW,4BAA2BwL,SAAU,oCAAhD,CAAN;AACH;;AACD,SAAOG,QAAP;AACH;;AACD,MAAMC,gBAAgB,GAAGjC,QAAQ,CAAC,SAASiC,gBAAT,CAA0BnG,MAA1B,EAAkC;AAChE,QAAMoG,SAAS,GAAGC,YAAY,CAACrG,MAAD,CAA9B;AACA,SAAO,IAAIsG,GAAJ,CAAQ,CAAC,GAAGF,SAAJ,EAAe3J,GAAf,CAAmB2B,IAAI,IAAIA,IAAI,CAACzE,IAAhC,CAAR,CAAP;AACH,CAHgC,CAAjC;AAIA,MAAM0M,YAAY,GAAGnC,QAAQ,CAAC,SAASmC,YAAT,CAAsBrG,MAAtB,EAA8B;AACxD,QAAMgG,WAAW,GAAGC,cAAc,CAACjG,MAAD,CAAlC;AACA,SAAO,IAAIsG,GAAJ,CAAQN,WAAW,CAAC3E,MAAZ,EAAR,CAAP;AACH,CAH4B,CAA7B;AAIA,MAAM4E,cAAc,GAAG/B,QAAQ,CAAC,SAAS+B,cAAT,CAAwBjG,MAAxB,EAAgC;AAC5D,QAAMgG,WAAW,GAAG,IAAIO,GAAJ,EAApB;AACA,QAAMC,SAAS,GAAGxG,MAAM,CAACyG,YAAP,EAAlB;;AACA,MAAID,SAAJ,EAAe;AACXR,IAAAA,WAAW,CAACrB,GAAZ,CAAgB,OAAhB,EAAyB6B,SAAzB;AACH;;AACD,QAAME,YAAY,GAAG1G,MAAM,CAAC2G,eAAP,EAArB;;AACA,MAAID,YAAJ,EAAkB;AACdV,IAAAA,WAAW,CAACrB,GAAZ,CAAgB,UAAhB,EAA4B+B,YAA5B;AACH;;AACD,QAAME,gBAAgB,GAAG5G,MAAM,CAAC6G,mBAAP,EAAzB;;AACA,MAAID,gBAAJ,EAAsB;AAClBZ,IAAAA,WAAW,CAACrB,GAAZ,CAAgB,cAAhB,EAAgCiC,gBAAhC;AACH;;AACD,SAAOZ,WAAP;AACH,CAf8B,CAA/B;;AAiBA,SAASc,yBAAT,CAAmC9G,MAAnC,EAAyD;AAAA,MAAd2B,OAAc,uEAAJ,EAAI;AACrD,QAAM1C,4BAA4B,GAAG0C,OAAO,CAAC1C,4BAA7C;AACA,QAAM8H,QAAQ,GAAG/G,MAAM,CAACwC,UAAP,EAAjB;AACA,QAAMwE,UAAU,GAAGC,aAAa,CAACjH,MAAD,EAASf,4BAAT,CAAhC;AACA,QAAM8C,WAAW,GAAGiF,UAAU,IAAI,IAAd,GAAqB,CAACA,UAAD,CAArB,GAAoC,EAAxD;AACA,QAAMxG,UAAU,GAAGR,MAAM,CAACD,aAAP,EAAnB;;AACA,OAAK,MAAMJ,SAAX,IAAwBa,UAAxB,EAAoC;AAChC,QAAIjL,oBAAoB,CAACoK,SAAD,CAAxB,EAAqC;AACjC;AACH;;AACDoC,IAAAA,WAAW,CAAC5E,IAAZ,CAAiB+J,gBAAgB,CAACvH,SAAD,EAAYK,MAAZ,EAAoBf,4BAApB,CAAjC;AACH;;AACD,OAAK,MAAMgD,QAAX,IAAuB8E,QAAvB,EAAiC;AAC7B,UAAM3I,IAAI,GAAG2I,QAAQ,CAAC9E,QAAD,CAArB;AACA,UAAMkF,kBAAkB,GAAG1R,qBAAqB,CAAC2I,IAAD,CAAhD;AACA,UAAMgJ,eAAe,GAAG1R,mBAAmB,CAAC0I,IAAD,CAA3C;;AACA,QAAI+I,kBAAkB,IAAIC,eAA1B,EAA2C;AACvC;AACH;;AACD,QAAI/R,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpB2D,MAAAA,WAAW,CAAC5E,IAAZ,CAAiBkK,iBAAiB,CAACjJ,IAAD,EAAO4B,MAAP,EAAef,4BAAf,CAAlC;AACH,KAFD,MAGK,IAAItJ,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5B2D,MAAAA,WAAW,CAAC5E,IAAZ,CAAiBmK,oBAAoB,CAAClJ,IAAD,EAAO4B,MAAP,EAAef,4BAAf,CAArC;AACH,KAFI,MAGA,IAAIrJ,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxB2D,MAAAA,WAAW,CAAC5E,IAAZ,CAAiBoK,gBAAgB,CAACnJ,IAAD,EAAO4B,MAAP,EAAef,4BAAf,CAAjC;AACH,KAFI,MAGA,IAAIpJ,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9B2D,MAAAA,WAAW,CAAC5E,IAAZ,CAAiBqK,sBAAsB,CAACpJ,IAAD,EAAO4B,MAAP,EAAef,4BAAf,CAAvC;AACH,KAFI,MAGA,IAAInJ,UAAU,CAACsI,IAAD,CAAd,EAAsB;AACvB2D,MAAAA,WAAW,CAAC5E,IAAZ,CAAiBsK,eAAe,CAACrJ,IAAD,EAAO4B,MAAP,EAAef,4BAAf,CAAhC;AACH,KAFI,MAGA,IAAIlJ,YAAY,CAACqI,IAAD,CAAhB,EAAwB;AACzB2D,MAAAA,WAAW,CAAC5E,IAAZ,CAAiBuK,iBAAiB,CAACtJ,IAAD,EAAO4B,MAAP,EAAef,4BAAf,CAAlC;AACH,KAFI,MAGA;AACD,YAAM,IAAI1E,KAAJ,CAAW,gBAAe6D,IAAK,GAA/B,CAAN;AACH;AACJ;;AACD,SAAO;AACHtE,IAAAA,IAAI,EAAE5E,IAAI,CAACyS,QADR;AAEH5F,IAAAA;AAFG,GAAP;AAIH,C,CACD;AACA;;;AACA,SAAS6F,yBAAT,CAAmC5H,MAAnC,EAAyD;AAAA,MAAd2B,OAAc,uEAAJ,EAAI;AACrD,QAAMD,YAAY,GAAGoF,yBAAyB,CAAC9G,MAAD,EAAS2B,OAAT,CAA9C;AACA,SAAOvM,KAAK,CAACsM,YAAD,CAAZ;AACH;;AACD,SAASuF,aAAT,CAAuBjH,MAAvB,EAA+Bf,4BAA/B,EAA6D;AACzD,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,QAAMmO,gBAAgB,GAAG,IAAItB,GAAJ,CAAQ,CAC7B,CAAC,OAAD,EAAU9H,SAAV,CAD6B,EAE7B,CAAC,UAAD,EAAaA,SAAb,CAF6B,EAG7B,CAAC,cAAD,EAAiBA,SAAjB,CAH6B,CAAR,CAAzB;AAKA,QAAMqJ,KAAK,GAAG,EAAd;;AACA,MAAI9H,MAAM,CAACK,OAAP,IAAkB,IAAtB,EAA4B;AACxByH,IAAAA,KAAK,CAAC3K,IAAN,CAAW6C,MAAM,CAACK,OAAlB;AACH;;AACD,MAAIL,MAAM,CAACM,iBAAP,IAA4B,IAAhC,EAAsC;AAClC,SAAK,MAAMyH,gBAAX,IAA+B/H,MAAM,CAACM,iBAAtC,EAAyD;AACrDwH,MAAAA,KAAK,CAAC3K,IAAN,CAAW4K,gBAAX;AACH;AACJ;;AACD,OAAK,MAAMrK,IAAX,IAAmBoK,KAAnB,EAA0B;AACtB,QAAIpK,IAAI,CAACsK,cAAT,EAAyB;AACrB,WAAK,MAAMC,2BAAX,IAA0CvK,IAAI,CAACsK,cAA/C,EAA+D;AAC3DH,QAAAA,gBAAgB,CAAClD,GAAjB,CAAqBsD,2BAA2B,CAAClC,SAAjD,EAA4DkC,2BAA5D;AACH;AACJ;AACJ;;AACD,QAAMjC,WAAW,GAAGC,cAAc,CAACjG,MAAD,CAAlC;;AACA,OAAK,MAAM,CAACkI,iBAAD,EAAoBD,2BAApB,CAAX,IAA+DJ,gBAA/D,EAAiF;AAC7E,UAAM3B,QAAQ,GAAGF,WAAW,CAACvB,GAAZ,CAAgByD,iBAAhB,CAAjB;;AACA,QAAIhC,QAAQ,IAAI,IAAhB,EAAsB;AAClB,YAAMiC,WAAW,GAAGpF,WAAW,CAACmD,QAAD,CAA/B;;AACA,UAAI+B,2BAA2B,IAAI,IAAnC,EAAyC;AACrCA,QAAAA,2BAA2B,CAAC7J,IAA5B,GAAmC+J,WAAnC;AACH,OAFD,MAGK;AACDN,QAAAA,gBAAgB,CAAClD,GAAjB,CAAqBuD,iBAArB,EAAwC;AACpCpO,UAAAA,IAAI,EAAE5E,IAAI,CAACkT,yBADyB;AAEpCrC,UAAAA,SAAS,EAAEmC,iBAFyB;AAGpC9J,UAAAA,IAAI,EAAE+J;AAH8B,SAAxC;AAKH;AACJ;AACJ;;AACD,QAAMH,cAAc,GAAG,CAAC,GAAGH,gBAAgB,CAACxG,MAAjB,EAAJ,EAA+B5B,MAA/B,CAAsCtF,MAAtC,CAAvB;AACA,QAAMqG,UAAU,GAAG6H,iBAAiB,CAACrI,MAAD,EAASA,MAAT,EAAiBf,4BAAjB,CAApC;;AACA,MAAI,CAAC+I,cAAc,CAAC1L,MAAhB,IAA0B,CAACkE,UAAU,CAAClE,MAA1C,EAAkD;AAC9C,WAAO,IAAP;AACH;;AACD,QAAM0K,UAAU,GAAG;AACflN,IAAAA,IAAI,EAAEkO,cAAc,IAAI,IAAlB,GAAyB9S,IAAI,CAACoT,iBAA9B,GAAkDpT,IAAI,CAACqT,gBAD9C;AAEfP,IAAAA,cAFe;AAGf;AACAxH,IAAAA,UAAU,EAAEA;AAJG,GAAnB,CA7CyD,CAmDzD;AACA;;AACAwG,EAAAA,UAAU,CAACwB,WAAX,GACI,CAAC,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAGuG,MAAM,CAACK,OAAb,MAA0B,IAA1B,IAAkC5G,EAAE,KAAK,KAAK,CAA9C,GAAkD,KAAK,CAAvD,GAA2DA,EAAE,CAAC+O,WAApE,MAAqF,IAArF,IAA6F9O,EAAE,KAAK,KAAK,CAAzG,GAA6GA,EAA7G,GAAkHsG,MAAM,CAACwI,WAAP,IAAsB,IAAzI,IACM;AACE1O,IAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,IAAAA,KAAK,EAAEmG,MAAM,CAACwI,WAFhB;AAGEC,IAAAA,KAAK,EAAE;AAHT,GADN,GAMMhK,SAPV;AAQA,SAAOuI,UAAP;AACH;;AACD,SAASE,gBAAT,CAA0BvH,SAA1B,EAAqCK,MAArC,EAA6Cf,4BAA7C,EAA2E;AACvE,MAAIxF,EAAJ,EAAQC,EAAR,EAAYgP,EAAZ,EAAgBC,EAAhB;;AACA,SAAO;AACH7O,IAAAA,IAAI,EAAE5E,IAAI,CAAC0T,oBADR;AAEHJ,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAGkG,SAAS,CAACU,OAAhB,MAA6B,IAA7B,IAAqC5G,EAAE,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,EAAE,CAAC+O,WAAvE,MAAwF,IAAxF,IAAgG9O,EAAE,KAAK,KAAK,CAA5G,GAAgHA,EAAhH,GAAsHiG,SAAS,CAAC6I,WAAV,GAC7H;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAE8F,SAAS,CAAC6I;AAFnB,KAD6H,GAK7H/J,SAPH;AAQH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAE8F,SAAS,CAAChG;AAFf,KARH;AAYHsE,IAAAA,SAAS,EAAE,CAACyK,EAAE,GAAG/I,SAAS,CAACpB,IAAhB,MAA0B,IAA1B,IAAkCmK,EAAE,KAAK,KAAK,CAA9C,GAAkD,KAAK,CAAvD,GAA2DA,EAAE,CAACjM,GAAH,CAAO0B,GAAG,IAAI0K,UAAU,CAAC1K,GAAD,EAAM6B,MAAN,EAAcf,4BAAd,CAAxB,CAZnE;AAaH6J,IAAAA,UAAU,EAAEnJ,SAAS,CAACoJ,YAbnB;AAcHC,IAAAA,SAAS,EAAE,CAAC,CAACL,EAAE,GAAGhJ,SAAS,CAACqJ,SAAhB,MAA+B,IAA/B,IAAuCL,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAAClM,GAAH,CAAOwM,QAAQ,KAAK;AAC5FnP,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADiF;AAE5FxJ,MAAAA,KAAK,EAAEoP;AAFqF,KAAL,CAAf,CAAjE,KAGH;AAjBL,GAAP;AAmBH;;AACD,SAASZ,iBAAT,CAA2Ba,MAA3B,EAAmClJ,MAAnC,EAA2Cf,4BAA3C,EAAyE;AACrE,QAAMK,sBAAsB,GAAGN,yBAAyB,CAACkK,MAAD,EAASjK,4BAAT,CAAxD;AACA,MAAI6I,KAAK,GAAG,EAAZ;;AACA,MAAIoB,MAAM,CAAC7I,OAAP,IAAkB,IAAtB,EAA4B;AACxByH,IAAAA,KAAK,CAAC3K,IAAN,CAAW+L,MAAM,CAAC7I,OAAlB;AACH;;AACD,MAAI,uBAAuB6I,MAAvB,IAAiCA,MAAM,CAAC5I,iBAAP,IAA4B,IAAjE,EAAuE;AACnEwH,IAAAA,KAAK,GAAGA,KAAK,CAACqB,MAAN,CAAaD,MAAM,CAAC5I,iBAApB,CAAR;AACH;;AACD,MAAIE,UAAJ;;AACA,MAAIlB,sBAAsB,IAAI,IAA9B,EAAoC;AAChCkB,IAAAA,UAAU,GAAG4I,kBAAkB,CAACpJ,MAAD,EAASV,sBAAT,CAA/B;AACH,GAFD,MAGK;AACDkB,IAAAA,UAAU,GAAG,EAAb;;AACA,SAAK,MAAM9C,IAAX,IAAmBoK,KAAnB,EAA0B;AACtB,UAAIpK,IAAI,CAAC8C,UAAT,EAAqB;AACjBA,QAAAA,UAAU,CAACrD,IAAX,CAAgB,GAAGO,IAAI,CAAC8C,UAAxB;AACH;AACJ;AACJ;;AACD,SAAOA,UAAP;AACH;;AACD,SAAS6I,6BAAT,CAAuCH,MAAvC,EAA+ClJ,MAA/C,EAAuDf,4BAAvD,EAAqF;AACjF,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,MAAI4P,+BAA+B,GAAG,EAAtC;AACA,MAAIC,uBAAuB,GAAG,IAA9B;AACA,QAAMjK,sBAAsB,GAAGN,yBAAyB,CAACkK,MAAD,EAASjK,4BAAT,CAAxD;AACA,MAAIuB,UAAJ;;AACA,MAAIlB,sBAAsB,IAAI,IAA9B,EAAoC;AAChCkB,IAAAA,UAAU,GAAG4I,kBAAkB,CAACpJ,MAAD,EAASV,sBAAT,CAA/B;AACH,GAFD,MAGK;AACDkB,IAAAA,UAAU,GAAG,CAAC/G,EAAE,GAAGyP,MAAM,CAAC7I,OAAb,MAA0B,IAA1B,IAAkC5G,EAAE,KAAK,KAAK,CAA9C,GAAkD,KAAK,CAAvD,GAA2DA,EAAE,CAAC+G,UAA3E;AACH;;AACD,MAAIA,UAAU,IAAI,IAAlB,EAAwB;AACpB8I,IAAAA,+BAA+B,GAAG9I,UAAU,CAACf,MAAX,CAAkBE,SAAS,IAAIA,SAAS,CAAChG,IAAV,CAAeE,KAAf,KAAyB,YAAxD,CAAlC;;AACA,QAAIqP,MAAM,CAACM,iBAAP,IAA4B,IAAhC,EAAsC;AAClCD,MAAAA,uBAAuB,GAAG,CAAC7P,EAAE,GAAG8G,UAAU,CAACf,MAAX,CAAkBE,SAAS,IAAIA,SAAS,CAAChG,IAAV,CAAeE,KAAf,KAAyB,YAAxD,CAAN,MAAiF,IAAjF,IAAyFH,EAAE,KAAK,KAAK,CAArG,GAAyG,KAAK,CAA9G,GAAkHA,EAAE,CAAC,CAAD,CAA9I;AACH;AACJ;;AACD,MAAIwP,MAAM,CAACM,iBAAP,IAA4B,IAA5B,IACAD,uBAAuB,IAAI,IAD/B,EACqC;AACjCA,IAAAA,uBAAuB,GAAGE,uBAAuB,CAACP,MAAM,CAACM,iBAAR,CAAjD;AACH;;AACD,SAAOD,uBAAuB,IAAI,IAA3B,GACDD,+BADC,GAED,CAACC,uBAAD,EAA0BJ,MAA1B,CAAiCG,+BAAjC,CAFN;AAGH;;AACD,SAAST,UAAT,CAAoB1K,GAApB,EAAyB6B,MAAzB,EAAiCf,4BAAjC,EAA+D;AAC3D,MAAIxF,EAAJ,EAAQC,EAAR,EAAYgP,EAAZ;;AACA,SAAO;AACH5O,IAAAA,IAAI,EAAE5E,IAAI,CAACwU,sBADR;AAEHlB,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAG0E,GAAG,CAACkC,OAAV,MAAuB,IAAvB,IAA+B5G,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAAC+O,WAAjE,MAAkF,IAAlF,IAA0F9O,EAAE,KAAK,KAAK,CAAtG,GAA0GA,EAA1G,GAAgHyE,GAAG,CAACqK,WAAJ,GACvH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEsE,GAAG,CAACqK,WAFb;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADuH,GAMvHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEsE,GAAG,CAACxE;AAFT,KATH;AAaHyE,IAAAA,IAAI,EAAE2E,WAAW,CAAC5E,GAAG,CAACC,IAAL,CAbd;AAcH;AACAE,IAAAA,YAAY,EAAEH,GAAG,CAACG,YAAJ,KAAqBG,SAArB,GAAiC,CAACiK,EAAE,GAAGlT,YAAY,CAAC2I,GAAG,CAACG,YAAL,EAAmBH,GAAG,CAACC,IAAvB,CAAlB,MAAoD,IAApD,IAA4DsK,EAAE,KAAK,KAAK,CAAxE,GAA4EA,EAA5E,GAAiFjK,SAAlH,GAA8HA,SAfzI;AAgBH+B,IAAAA,UAAU,EAAE6I,6BAA6B,CAAClL,GAAD,EAAM6B,MAAN,EAAcf,4BAAd;AAhBtC,GAAP;AAkBH;;AACD,SAASoI,iBAAT,CAA2BjJ,IAA3B,EAAiC4B,MAAjC,EAAyCf,4BAAzC,EAAuE;AACnE,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,SAAO;AACHI,IAAAA,IAAI,EAAE5E,IAAI,CAACyU,sBADR;AAEHnB,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAG2E,IAAI,CAACiC,OAAX,MAAwB,IAAxB,IAAgC5G,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC+O,WAAlE,MAAmF,IAAnF,IAA2F9O,EAAE,KAAK,KAAK,CAAvG,GAA2GA,EAA3G,GAAiH0E,IAAI,CAACoK,WAAL,GACxH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEuE,IAAI,CAACoK,WAFd;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADwH,GAMxHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV,KATH;AAaH6H,IAAAA,MAAM,EAAEnF,MAAM,CAACgF,MAAP,CAAcjD,IAAI,CAACwL,SAAL,EAAd,EAAgCnN,GAAhC,CAAoCyF,KAAK,IAAI2H,YAAY,CAAC3H,KAAD,EAAQlC,MAAR,EAAgBf,4BAAhB,CAAzD,CAbL;AAcH6K,IAAAA,UAAU,EAAEzN,MAAM,CAACgF,MAAP,CAAcjD,IAAI,CAACwE,aAAL,EAAd,EAAoCnG,GAApC,CAAwCsN,KAAK,IAAIhH,WAAW,CAACgH,KAAD,CAA5D,CAdT;AAeHvJ,IAAAA,UAAU,EAAE6H,iBAAiB,CAACjK,IAAD,EAAO4B,MAAP,EAAef,4BAAf;AAf1B,GAAP;AAiBH;;AACD,SAASqI,oBAAT,CAA8BlJ,IAA9B,EAAoC4B,MAApC,EAA4Cf,4BAA5C,EAA0E;AACtE,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,QAAMgE,IAAI,GAAG;AACT5D,IAAAA,IAAI,EAAE5E,IAAI,CAAC8U,yBADF;AAETxB,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAG2E,IAAI,CAACiC,OAAX,MAAwB,IAAxB,IAAgC5G,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC+O,WAAlE,MAAmF,IAAnF,IAA2F9O,EAAE,KAAK,KAAK,CAAvG,GAA2GA,EAA3G,GAAiH0E,IAAI,CAACoK,WAAL,GACxH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEuE,IAAI,CAACoK,WAFd;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADwH,GAMxHhK,SARG;AAST9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV,KATG;AAaT6H,IAAAA,MAAM,EAAEnF,MAAM,CAACgF,MAAP,CAAcjD,IAAI,CAACwL,SAAL,EAAd,EAAgCnN,GAAhC,CAAoCyF,KAAK,IAAI2H,YAAY,CAAC3H,KAAD,EAAQlC,MAAR,EAAgBf,4BAAhB,CAAzD,CAbC;AAcTuB,IAAAA,UAAU,EAAE6H,iBAAiB,CAACjK,IAAD,EAAO4B,MAAP,EAAef,4BAAf;AAdpB,GAAb;;AAgBA,MAAI,mBAAmBb,IAAvB,EAA6B;AACzBV,IAAAA,IAAI,CAACoM,UAAL,GAAkBzN,MAAM,CAACgF,MAAP,CAAcjD,IAAI,CAACwE,aAAL,EAAd,EAAoCnG,GAApC,CAAwCsN,KAAK,IAAIhH,WAAW,CAACgH,KAAD,CAA5D,CAAlB;AACH;;AACD,SAAOrM,IAAP;AACH;;AACD,SAAS6J,gBAAT,CAA0BnJ,IAA1B,EAAgC4B,MAAhC,EAAwCf,4BAAxC,EAAsE;AAClE,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,SAAO;AACHI,IAAAA,IAAI,EAAE5E,IAAI,CAAC+U,qBADR;AAEHzB,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAG2E,IAAI,CAACiC,OAAX,MAAwB,IAAxB,IAAgC5G,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC+O,WAAlE,MAAmF,IAAnF,IAA2F9O,EAAE,KAAK,KAAK,CAAvG,GAA2GA,EAA3G,GAAiH0E,IAAI,CAACoK,WAAL,GACxH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEuE,IAAI,CAACoK,WAFd;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADwH,GAMxHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV,KATH;AAaH;AACA6G,IAAAA,UAAU,EAAE6H,iBAAiB,CAACjK,IAAD,EAAO4B,MAAP,EAAef,4BAAf,CAd1B;AAeHiL,IAAAA,KAAK,EAAE9L,IAAI,CAAC+L,QAAL,GAAgB1N,GAAhB,CAAoB2B,IAAI,IAAI2E,WAAW,CAAC3E,IAAD,CAAvC;AAfJ,GAAP;AAiBH;;AACD,SAASoJ,sBAAT,CAAgCpJ,IAAhC,EAAsC4B,MAAtC,EAA8Cf,4BAA9C,EAA4E;AACxE,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,SAAO;AACHI,IAAAA,IAAI,EAAE5E,IAAI,CAACkV,4BADR;AAEH5B,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAG2E,IAAI,CAACiC,OAAX,MAAwB,IAAxB,IAAgC5G,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC+O,WAAlE,MAAmF,IAAnF,IAA2F9O,EAAE,KAAK,KAAK,CAAvG,GAA2GA,EAA3G,GAAiH0E,IAAI,CAACoK,WAAL,GACxH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEuE,IAAI,CAACoK,WAFd;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADwH,GAMxHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV,KATH;AAaH6H,IAAAA,MAAM,EAAEnF,MAAM,CAACgF,MAAP,CAAcjD,IAAI,CAACwL,SAAL,EAAd,EAAgCnN,GAAhC,CAAoCyF,KAAK,IAAImI,iBAAiB,CAACnI,KAAD,EAAQlC,MAAR,EAAgBf,4BAAhB,CAA9D,CAbL;AAcH;AACAuB,IAAAA,UAAU,EAAE6H,iBAAiB,CAACjK,IAAD,EAAO4B,MAAP,EAAef,4BAAf;AAf1B,GAAP;AAiBH;;AACD,SAASwI,eAAT,CAAyBrJ,IAAzB,EAA+B4B,MAA/B,EAAuCf,4BAAvC,EAAqE;AACjE,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,SAAO;AACHI,IAAAA,IAAI,EAAE5E,IAAI,CAACoV,oBADR;AAEH9B,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAG2E,IAAI,CAACiC,OAAX,MAAwB,IAAxB,IAAgC5G,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC+O,WAAlE,MAAmF,IAAnF,IAA2F9O,EAAE,KAAK,KAAK,CAAvG,GAA2GA,EAA3G,GAAiH0E,IAAI,CAACoK,WAAL,GACxH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEuE,IAAI,CAACoK,WAFd;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADwH,GAMxHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV,KATH;AAaH0H,IAAAA,MAAM,EAAEhF,MAAM,CAACgF,MAAP,CAAcjD,IAAI,CAACmM,SAAL,EAAd,EAAgC9N,GAAhC,CAAoC5C,KAAK,IAAI2Q,gBAAgB,CAAC3Q,KAAD,EAAQmG,MAAR,EAAgBf,4BAAhB,CAA7D,CAbL;AAcH;AACAuB,IAAAA,UAAU,EAAE6H,iBAAiB,CAACjK,IAAD,EAAO4B,MAAP,EAAef,4BAAf;AAf1B,GAAP;AAiBH;;AACD,SAASyI,iBAAT,CAA2BtJ,IAA3B,EAAiC4B,MAAjC,EAAyCf,4BAAzC,EAAuE;AACnE,MAAIxF,EAAJ,EAAQC,EAAR,EAAYgP,EAAZ;;AACA,QAAMpJ,sBAAsB,GAAGN,yBAAyB,CAACZ,IAAD,EAAOa,4BAAP,CAAxD;AACA,QAAMuB,UAAU,GAAGlB,sBAAsB,GACnC8J,kBAAkB,CAACpJ,MAAD,EAASV,sBAAT,CADiB,GAEnC,CAAC,CAAC7F,EAAE,GAAG2E,IAAI,CAACiC,OAAX,MAAwB,IAAxB,IAAgC5G,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC+G,UAA7D,KAA4E,EAFlF;AAGA,QAAMiK,gBAAgB,GAAIrM,IAAI,CAAC,gBAAD,CAAJ,IAA0BA,IAAI,CAAC,gBAAD,CAAxD;;AACA,MAAIqM,gBAAgB,IAAI,CAACjK,UAAU,CAACkK,IAAX,CAAgBjK,aAAa,IAAIA,aAAa,CAAC9G,IAAd,CAAmBE,KAAnB,KAA6B,aAA9D,CAAzB,EAAuG;AACnG,UAAM8Q,eAAe,GAAG;AACpBC,MAAAA,GAAG,EAAEH;AADe,KAAxB;AAGAjK,IAAAA,UAAU,CAACrD,IAAX,CAAgB0N,iBAAiB,CAAC,aAAD,EAAgBF,eAAhB,CAAjC;AACH;;AACD,SAAO;AACH7Q,IAAAA,IAAI,EAAE5E,IAAI,CAAC4V,sBADR;AAEHtC,IAAAA,WAAW,EAAE,CAACE,EAAE,GAAG,CAAChP,EAAE,GAAG0E,IAAI,CAACiC,OAAX,MAAwB,IAAxB,IAAgC3G,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC8O,WAAlE,MAAmF,IAAnF,IAA2FE,EAAE,KAAK,KAAK,CAAvG,GAA2GA,EAA3G,GAAiHtK,IAAI,CAACoK,WAAL,GACxH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEuE,IAAI,CAACoK,WAFd;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADwH,GAMxHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV,KATH;AAaH;AACA6G,IAAAA,UAAU,EAAEA;AAdT,GAAP;AAgBH;;AACD,SAASqJ,YAAT,CAAsB3H,KAAtB,EAA6BlC,MAA7B,EAAqCf,4BAArC,EAAmE;AAC/D,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,SAAO;AACHI,IAAAA,IAAI,EAAE5E,IAAI,CAAC6V,gBADR;AAEHvC,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAGyI,KAAK,CAAC7B,OAAZ,MAAyB,IAAzB,IAAiC5G,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAAC+O,WAAnE,MAAoF,IAApF,IAA4F9O,EAAE,KAAK,KAAK,CAAxG,GAA4GA,EAA5G,GAAkHwI,KAAK,CAACsG,WAAN,GACzH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEqI,KAAK,CAACsG,WAFf;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADyH,GAMzHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEqI,KAAK,CAACvI;AAFX,KATH;AAaHsE,IAAAA,SAAS,EAAEiE,KAAK,CAAC3D,IAAN,CAAW9B,GAAX,CAAe0B,GAAG,IAAI0K,UAAU,CAAC1K,GAAD,EAAM6B,MAAN,EAAcf,4BAAd,CAAhC,CAbR;AAcHb,IAAAA,IAAI,EAAE2E,WAAW,CAACb,KAAK,CAAC9D,IAAP,CAdd;AAeH;AACAoC,IAAAA,UAAU,EAAE6I,6BAA6B,CAACnH,KAAD,EAAQlC,MAAR,EAAgBf,4BAAhB;AAhBtC,GAAP;AAkBH;;AACD,SAASoL,iBAAT,CAA2BnI,KAA3B,EAAkClC,MAAlC,EAA0Cf,4BAA1C,EAAwE;AACpE,MAAIxF,EAAJ,EAAQC,EAAR,EAAYgP,EAAZ;;AACA,SAAO;AACH5O,IAAAA,IAAI,EAAE5E,IAAI,CAACwU,sBADR;AAEHlB,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAGyI,KAAK,CAAC7B,OAAZ,MAAyB,IAAzB,IAAiC5G,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAAC+O,WAAnE,MAAoF,IAApF,IAA4F9O,EAAE,KAAK,KAAK,CAAxG,GAA4GA,EAA5G,GAAkHwI,KAAK,CAACsG,WAAN,GACzH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEqI,KAAK,CAACsG,WAFf;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADyH,GAMzHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEqI,KAAK,CAACvI;AAFX,KATH;AAaHyE,IAAAA,IAAI,EAAE2E,WAAW,CAACb,KAAK,CAAC9D,IAAP,CAbd;AAcH;AACAoC,IAAAA,UAAU,EAAE6I,6BAA6B,CAACnH,KAAD,EAAQlC,MAAR,EAAgBf,4BAAhB,CAftC;AAgBHX,IAAAA,YAAY,EAAE,CAACoK,EAAE,GAAGlT,YAAY,CAAC0M,KAAK,CAAC5D,YAAP,EAAqB4D,KAAK,CAAC9D,IAA3B,CAAlB,MAAwD,IAAxD,IAAgEsK,EAAE,KAAK,KAAK,CAA5E,GAAgFA,EAAhF,GAAqFjK;AAhBhG,GAAP;AAkBH;;AACD,SAAS+L,gBAAT,CAA0B3Q,KAA1B,EAAiCmG,MAAjC,EAAyCf,4BAAzC,EAAuE;AACnE,MAAIxF,EAAJ,EAAQC,EAAR;;AACA,SAAO;AACHI,IAAAA,IAAI,EAAE5E,IAAI,CAAC8V,qBADR;AAEHxC,IAAAA,WAAW,EAAE,CAAC9O,EAAE,GAAG,CAACD,EAAE,GAAGI,KAAK,CAACwG,OAAZ,MAAyB,IAAzB,IAAiC5G,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAAC+O,WAAnE,MAAoF,IAApF,IAA4F9O,EAAE,KAAK,KAAK,CAAxG,GAA4GA,EAA5G,GAAkHG,KAAK,CAAC2O,WAAN,GACzH;AACE1O,MAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADb;AAEErH,MAAAA,KAAK,EAAEA,KAAK,CAAC2O,WAFf;AAGEC,MAAAA,KAAK,EAAE;AAHT,KADyH,GAMzHhK,SARH;AASH9E,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEA,KAAK,CAACF;AAFX,KATH;AAaH;AACA6G,IAAAA,UAAU,EAAE6H,iBAAiB,CAACxO,KAAD,EAAQmG,MAAR,EAAgBf,4BAAhB;AAd1B,GAAP;AAgBH;;AACD,SAASwK,uBAAT,CAAiCD,iBAAjC,EAAoD;AAChD,SAAOqB,iBAAiB,CAAC,YAAD,EAAe;AAAEI,IAAAA,MAAM,EAAEzB;AAAV,GAAf,EAA8CxT,0BAA9C,CAAxB;AACH;;AACD,SAAS6U,iBAAT,CAA2BlR,IAA3B,EAAiC4E,IAAjC,EAAuCoB,SAAvC,EAAkD;AAC9C,QAAMuL,kBAAkB,GAAG,EAA3B;;AACA,MAAIvL,SAAS,IAAI,IAAjB,EAAuB;AACnB,SAAK,MAAMxB,GAAX,IAAkBwB,SAAS,CAACpB,IAA5B,EAAkC;AAC9B,YAAM4M,OAAO,GAAGhN,GAAG,CAACxE,IAApB;AACA,YAAMyR,QAAQ,GAAG7M,IAAI,CAAC4M,OAAD,CAArB;;AACA,UAAIC,QAAQ,KAAK3M,SAAjB,EAA4B;AACxB,cAAM5E,KAAK,GAAGrE,YAAY,CAAC4V,QAAD,EAAWjN,GAAG,CAACC,IAAf,CAA1B;;AACA,YAAIvE,KAAJ,EAAW;AACPqR,UAAAA,kBAAkB,CAAC/N,IAAnB,CAAwB;AACpBrD,YAAAA,IAAI,EAAE5E,IAAI,CAACmW,QADS;AAEpB1R,YAAAA,IAAI,EAAE;AACFG,cAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,cAAAA,KAAK,EAAEsR;AAFL,aAFc;AAMpBtR,YAAAA;AANoB,WAAxB;AAQH;AACJ;AACJ;AACJ,GAlBD,MAmBK;AACD,SAAK,MAAMsR,OAAX,IAAsB5M,IAAtB,EAA4B;AACxB,YAAM6M,QAAQ,GAAG7M,IAAI,CAAC4M,OAAD,CAArB;AACA,YAAMtR,KAAK,GAAGyJ,mBAAmB,CAAC8H,QAAD,CAAjC;;AACA,UAAIvR,KAAJ,EAAW;AACPqR,QAAAA,kBAAkB,CAAC/N,IAAnB,CAAwB;AACpBrD,UAAAA,IAAI,EAAE5E,IAAI,CAACmW,QADS;AAEpB1R,UAAAA,IAAI,EAAE;AACFG,YAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,YAAAA,KAAK,EAAEsR;AAFL,WAFc;AAMpBtR,UAAAA;AANoB,SAAxB;AAQH;AACJ;AACJ;;AACD,SAAO;AACHC,IAAAA,IAAI,EAAE5E,IAAI,CAACoW,SADR;AAEH3R,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEF;AAFL,KAFH;AAMHsE,IAAAA,SAAS,EAAEiN;AANR,GAAP;AAQH;;AACD,SAAS9B,kBAAT,CAA4BpJ,MAA5B,EAAoCuL,eAApC,EAAqD;AACjD,QAAMC,cAAc,GAAG,EAAvB;;AACA,OAAK,MAAMjM,aAAX,IAA4BgM,eAA5B,EAA6C;AACzC,UAAME,kBAAkB,GAAGF,eAAe,CAAChM,aAAD,CAA1C;AACA,UAAMI,SAAS,GAAGK,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACU,YAAP,CAAoBnB,aAApB,CAAlE;;AACA,QAAI5G,KAAK,CAACC,OAAN,CAAc6S,kBAAd,CAAJ,EAAuC;AACnC,WAAK,MAAM5R,KAAX,IAAoB4R,kBAApB,EAAwC;AACpCD,QAAAA,cAAc,CAACrO,IAAf,CAAoB0N,iBAAiB,CAACtL,aAAD,EAAgB1F,KAAhB,EAAuB8F,SAAvB,CAArC;AACH;AACJ,KAJD,MAKK;AACD6L,MAAAA,cAAc,CAACrO,IAAf,CAAoB0N,iBAAiB,CAACtL,aAAD,EAAgBkM,kBAAhB,EAAoC9L,SAApC,CAArC;AACH;AACJ;;AACD,SAAO6L,cAAP;AACH;;AAED,eAAeE,wBAAf,CAAwC1L,MAAxC,EAAgD2L,aAAhD,EAAsG;AAAA,MAAvCC,cAAuC,uEAAtBC,kBAAkB,EAAI;AAClG,QAAMC,cAAc,GAAG,IAAIvF,GAAJ,EAAvB;AACA,QAAMwF,6BAA6B,GAAG,EAAtC;;AACA,OAAK,MAAMC,YAAX,IAA2BL,aAA3B,EAA0C;AACtC,QAAIK,YAAY,CAACC,QAAjB,EAA2B;AACvB,YAAMC,qBAAqB,GAAG,EAA9B;;AACA,WAAK,MAAMC,cAAX,IAA6BH,YAAY,CAACC,QAAb,CAAsBlK,WAAnD,EAAgE;AAC5D,YAAIoK,cAAc,CAACrS,IAAf,KAAwB5E,IAAI,CAACkX,mBAAjC,EAAsD;AAClDN,UAAAA,cAAc,CAACnH,GAAf,CAAmBwH,cAAc,CAACxS,IAAf,CAAoBE,KAAvC,EAA8CsS,cAA9C;AACH,SAFD,MAGK;AACDD,UAAAA,qBAAqB,CAAC/O,IAAtB,CAA2BgP,cAA3B;AACH;AACJ;;AACDJ,MAAAA,6BAA6B,CAAC5O,IAA9B,CAAmC;AAC/B8L,QAAAA,QAAQ,EAAE+C,YAAY,CAAC/C,QADQ;AAE/BgD,QAAAA,QAAQ,EAAE;AACNnS,UAAAA,IAAI,EAAE5E,IAAI,CAACyS,QADL;AAEN5F,UAAAA,WAAW,EAAEmK;AAFP;AAFqB,OAAnC;AAOH;AACJ;;AACD,QAAMG,SAAS,GAAG,EAAlB;AACA,QAAMC,oBAAoB,GAAG;AACzBxS,IAAAA,IAAI,EAAE5E,IAAI,CAACyS,QADc;AAEzB5F,IAAAA,WAAW,EAAE,CAAC,GAAG+J,cAAc,CAACzK,MAAf,EAAJ;AAFY,GAA7B;AAIA,QAAMkL,OAAO,CAACC,GAAR,CAAYT,6BAA6B,CAACtP,GAA9B,CAAkC,MAAOuP,YAAP,IAAwB;AACxE,UAAMS,kBAAkB,GAAGvW,SAAS,CAAC,CAACoW,oBAAD,EAAuBN,YAAY,CAACC,QAApC,CAAD,CAApC;AACA,UAAMpR,MAAM,GAAG1E,QAAQ,CAAC6J,MAAD,EAASyM,kBAAT,EAA6Bb,cAA7B,CAAvB;;AACA,QAAI/Q,MAAM,CAACyB,MAAP,GAAgB,CAApB,EAAuB;AACnB+P,MAAAA,SAAS,CAAClP,IAAV,CAAe;AACXuP,QAAAA,QAAQ,EAAEV,YAAY,CAAC/C,QADZ;AAEXpO,QAAAA;AAFW,OAAf;AAIH;AACJ,GATiB,CAAZ,CAAN;AAUA,SAAOwR,SAAP;AACH;;AACD,SAASM,qBAAT,CAA+BC,kBAA/B,EAAmD;AAC/C,MAAIA,kBAAkB,CAACtQ,MAAnB,GAA4B,CAAhC,EAAmC;AAC/B,UAAMzB,MAAM,GAAG,EAAf;;AACA,SAAK,MAAMgS,iBAAX,IAAgCD,kBAAhC,EAAoD;AAChD,WAAK,MAAME,YAAX,IAA2BD,iBAAiB,CAAChS,MAA7C,EAAqD;AACjD,cAAMG,KAAK,GAAG,IAAIT,KAAJ,EAAd;AACAS,QAAAA,KAAK,CAACrB,IAAN,GAAa,sBAAb;AACAqB,QAAAA,KAAK,CAACV,OAAN,GAAiB,GAAEU,KAAK,CAACrB,IAAK,KAAImT,YAAY,CAACxS,OAAQ,EAAvD;AACAU,QAAAA,KAAK,CAACW,KAAN,GAAcX,KAAK,CAACV,OAApB;;AACA,YAAIwS,YAAY,CAAC9D,SAAjB,EAA4B;AACxB,eAAK,MAAMC,QAAX,IAAuB6D,YAAY,CAAC9D,SAApC,EAA+C;AAC3ChO,YAAAA,KAAK,CAACW,KAAN,IAAgB,YAAWkR,iBAAiB,CAACH,QAAS,IAAGzD,QAAQ,CAAC8D,IAAK,IAAG9D,QAAQ,CAAC+D,MAAO,EAA1F;AACH;AACJ;;AACDnS,QAAAA,MAAM,CAACsC,IAAP,CAAYnC,KAAZ;AACH;AACJ;;AACD,UAAM,IAAIR,kBAAJ,CAAuBK,MAAvB,EAAgC,2CAA0CA,MAAM,CAACyB,MAAO;AACtG,IAAIzB,MAAM,CAAC4B,GAAP,CAAW,CAACzB,KAAD,EAAQiS,KAAR,KAAmB,SAAQA,KAAM,KAAIjS,KAAK,CAACW,KAAM,EAA5D,EAA+DgB,IAA/D,CAAoE,MAApE,CAA4E,EADlE,CAAN;AAEH;AACJ;;AACD,SAASkP,kBAAT,GAA8B;AAC1B,MAAIqB,OAAO,GAAG,CAAC,uBAAD,EAA0B,uBAA1B,EAAmD,qBAAnD,CAAd;;AACA,MAAI9W,WAAW,CAAC+W,KAAZ,GAAoB,EAAxB,EAA4B;AACxBD,IAAAA,OAAO,GAAGA,OAAO,CAACzQ,GAAR,CAAY2Q,IAAI,IAAIA,IAAI,CAAC7P,OAAL,CAAa,OAAb,EAAsB,EAAtB,CAApB,CAAV;AACH;;AACD,SAAOtH,cAAc,CAACwJ,MAAf,CAAuB4N,CAAD,IAAO,CAACH,OAAO,CAACpR,QAAR,CAAiBuR,CAAC,CAAC1T,IAAnB,CAA9B,CAAP;AACH;;AAED,SAAS2T,QAAT,CAAkBC,OAAlB,EAA2B;AACvBA,EAAAA,OAAO,GAAGA,OAAO,CAAC7R,QAAR,EAAV,CADuB,CAEvB;AACA;AACA;;AACA,MAAI6R,OAAO,CAACC,UAAR,CAAmB,CAAnB,MAA0B,MAA9B,EAAsC;AAClCD,IAAAA,OAAO,GAAGA,OAAO,CAACE,KAAR,CAAc,CAAd,CAAV;AACH;;AACD,SAAOF,OAAP;AACH;;AACD,SAASG,QAAT,CAAkBH,OAAlB,EAA2B;AACvB,SAAOjS,IAAI,CAACvG,KAAL,CAAWuY,QAAQ,CAACC,OAAD,CAAnB,CAAP;AACH;;AACD,SAASI,gBAAT,CAA0B1E,QAA1B,EAAoC2E,WAApC,EAAiDjM,OAAjD,EAA0D;AACtD,MAAIkM,UAAU,GAAGH,QAAQ,CAACE,WAAD,CAAzB;;AACA,MAAIC,UAAU,CAACC,IAAf,EAAqB;AACjBD,IAAAA,UAAU,GAAGA,UAAU,CAACC,IAAxB;AACH;;AACD,MAAID,UAAU,CAAC/T,IAAX,KAAoB,UAAxB,EAAoC;AAChC,WAAO;AACHmP,MAAAA,QADG;AAEHgD,MAAAA,QAAQ,EAAE4B;AAFP,KAAP;AAIH,GALD,MAMK,IAAIA,UAAU,CAACE,QAAf,EAAyB;AAC1B,UAAM/N,MAAM,GAAG3J,iBAAiB,CAACwX,UAAD,EAAalM,OAAb,CAAhC;AACA,WAAO;AACHsH,MAAAA,QADG;AAEHjJ,MAAAA;AAFG,KAAP;AAIH,GANI,MAOA,IAAI,OAAO6N,UAAP,KAAsB,QAA1B,EAAoC;AACrC,WAAO;AACH5E,MAAAA,QADG;AAEH+E,MAAAA,MAAM,EAAEH;AAFL,KAAP;AAIH;;AACD,QAAM,IAAItT,KAAJ,CAAW,wBAAX,CAAN;AACH;;AAED,MAAM0T,eAAe,GAAG,EAAxB;AACA,IAAIC,gBAAgB,GAAG,EAAvB;;AACA,SAASC,aAAT,GAAyB;AACrBD,EAAAA,gBAAgB,GAAG,EAAnB;AACH;;AACD,SAASE,cAAT,CAAwB1Q,IAAxB,EAA8B;AAC1B,MAAIjE,EAAJ;;AACA,QAAM4U,UAAU,GAAG,CAAC5U,EAAE,GAAGiE,IAAI,CAAC/D,IAAX,MAAqB,IAArB,IAA6BF,EAAE,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,EAAE,CAACI,KAA5E;;AACA,MAAIwU,UAAU,IAAI,IAAlB,EAAwB;AACpB;AACH;;AACDC,EAAAA,WAAW,CAAC5Q,IAAD,EAAO2Q,UAAP,CAAX;;AACA,UAAQ3Q,IAAI,CAAC5D,IAAb;AACI,SAAK,oBAAL;AACI,UAAI4D,IAAI,CAAC2D,MAAT,EAAiB;AACb,aAAK,MAAMxH,KAAX,IAAoB6D,IAAI,CAAC2D,MAAzB,EAAiC;AAC7BiN,UAAAA,WAAW,CAACzU,KAAD,EAAQwU,UAAR,EAAoBxU,KAAK,CAACF,IAAN,CAAWE,KAA/B,CAAX;AACH;AACJ;;AACD;;AACJ,SAAK,sBAAL;AACA,SAAK,2BAAL;AACA,SAAK,yBAAL;AACI,UAAI6D,IAAI,CAAC8D,MAAT,EAAiB;AACb,aAAK,MAAMU,KAAX,IAAoBxE,IAAI,CAAC8D,MAAzB,EAAiC;AAC7B8M,UAAAA,WAAW,CAACpM,KAAD,EAAQmM,UAAR,EAAoBnM,KAAK,CAACvI,IAAN,CAAWE,KAA/B,CAAX;;AACA,cAAI0U,qBAAqB,CAACrM,KAAD,CAArB,IAAgCA,KAAK,CAACjE,SAA1C,EAAqD;AACjD,iBAAK,MAAME,GAAX,IAAkB+D,KAAK,CAACjE,SAAxB,EAAmC;AAC/BqQ,cAAAA,WAAW,CAACnQ,GAAD,EAAMkQ,UAAN,EAAkBnM,KAAK,CAACvI,IAAN,CAAWE,KAA7B,EAAoCsE,GAAG,CAACxE,IAAJ,CAASE,KAA7C,CAAX;AACH;AACJ;AACJ;AACJ;;AACD;AArBR;AAuBH;;AACD,SAASyU,WAAT,CAAqB5Q,IAArB,EAA2BwL,MAA3B,EAAmChH,KAAnC,EAA0CsM,QAA1C,EAAoD;AAChD,QAAMC,OAAO,GAAGC,UAAU,CAAChR,IAAD,CAA1B;;AACA,MAAI,OAAO+Q,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACnS,MAAR,KAAmB,CAAtD,EAAyD;AACrD;AACH;;AACD,QAAMqS,IAAI,GAAG,CAACzF,MAAD,CAAb;;AACA,MAAIhH,KAAJ,EAAW;AACPyM,IAAAA,IAAI,CAACxR,IAAL,CAAU+E,KAAV;;AACA,QAAIsM,QAAJ,EAAc;AACVG,MAAAA,IAAI,CAACxR,IAAL,CAAUqR,QAAV;AACH;AACJ;;AACD,QAAMI,IAAI,GAAGD,IAAI,CAAChS,IAAL,CAAU,GAAV,CAAb;;AACA,MAAI,CAACuR,gBAAgB,CAACU,IAAD,CAArB,EAA6B;AACzBV,IAAAA,gBAAgB,CAACU,IAAD,CAAhB,GAAyB,EAAzB;AACH;;AACDV,EAAAA,gBAAgB,CAACU,IAAD,CAAhB,CAAuBzR,IAAvB,CAA4BsR,OAA5B;AACH;;AACD,SAASI,YAAT,CAAsBJ,OAAtB,EAA+B;AAC3B,SAAO,SAASA,OAAO,CAAClR,OAAR,CAAgB,KAAhB,EAAuB,MAAvB,CAAhB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA,SAASZ,IAAT,CAAcmS,UAAd,EAA0BC,SAA1B,EAAqC;AACjC,SAAOD,UAAU,GAAGA,UAAU,CAACrP,MAAX,CAAkBuP,CAAC,IAAIA,CAAvB,EAA0BrS,IAA1B,CAA+BoS,SAAS,IAAI,EAA5C,CAAH,GAAqD,EAAtE;AACH;;AACD,SAASE,iBAAT,CAA2BH,UAA3B,EAAuC;AACnC,MAAIrV,EAAJ;;AACA,SAAO,CAACA,EAAE,GAAGqV,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACpE,IAAX,CAAgB3R,GAAG,IAAIA,GAAG,CAAC+C,QAAJ,CAAa,IAAb,CAAvB,CAA9D,MAA8G,IAA9G,IAAsHrC,EAAE,KAAK,KAAK,CAAlI,GAAsIA,EAAtI,GAA2I,KAAlJ;AACH;;AACD,SAASyV,cAAT,CAAwBC,EAAxB,EAA4B;AACxB,SAAO,CAACzR,IAAD,EAAO0R,IAAP,EAAaC,OAAb,EAAsBT,IAAtB,EAA4BU,SAA5B,KAA0C;AAC7C,QAAI7V,EAAJ;;AACA,UAAMkV,IAAI,GAAG,EAAb;AACA,UAAMY,MAAM,GAAGX,IAAI,CAAC/Q,MAAL,CAAY,CAACC,IAAD,EAAOpB,GAAP,KAAe;AACtC,UAAI,CAAC,QAAD,EAAW,WAAX,EAAwB,QAAxB,EAAkCZ,QAAlC,CAA2CY,GAA3C,KAAmDoB,IAAI,CAACnE,IAA5D,EAAkE;AAC9DgV,QAAAA,IAAI,CAACxR,IAAL,CAAUW,IAAI,CAACnE,IAAL,CAAUE,KAApB;AACH;;AACD,aAAOiE,IAAI,CAACpB,GAAD,CAAX;AACH,KALc,EAKZ4S,SAAS,CAAC,CAAD,CALG,CAAf;AAMA,UAAM5S,GAAG,GAAG,CAAC,GAAGiS,IAAJ,EAAU,CAAClV,EAAE,GAAG8V,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAAC5V,IAA7D,MAAuE,IAAvE,IAA+EF,EAAE,KAAK,KAAK,CAA3F,GAA+F,KAAK,CAApG,GAAwGA,EAAE,CAACI,KAArH,EAA4H4F,MAA5H,CAAmIwB,OAAnI,EAA4ItE,IAA5I,CAAiJ,GAAjJ,CAAZ;AACA,UAAMM,KAAK,GAAG,EAAd;;AACA,QAAIS,IAAI,CAAC5D,IAAL,CAAUgC,QAAV,CAAmB,YAAnB,KAAoCoS,gBAAgB,CAACxR,GAAD,CAAxD,EAA+D;AAC3DO,MAAAA,KAAK,CAACE,IAAN,CAAW,GAAG+Q,gBAAgB,CAACxR,GAAD,CAA9B;AACH;;AACD,WAAOC,IAAI,CAAC,CAAC,GAAGM,KAAK,CAACR,GAAN,CAAUoS,YAAV,CAAJ,EAA6BnR,IAAI,CAAC8K,WAAlC,EAA+C2G,EAAE,CAACzR,IAAD,EAAO0R,IAAP,EAAaC,OAAb,EAAsBT,IAAtB,EAA4BU,SAA5B,CAAjD,CAAD,EAA2F,IAA3F,CAAX;AACH,GAfD;AAgBH;;AACD,SAASE,MAAT,CAAgBC,WAAhB,EAA6B;AACzB,SAAOA,WAAW,IAAK,KAAIA,WAAW,CAAClS,OAAZ,CAAoB,KAApB,EAA2B,MAA3B,CAAmC,EAA9D;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASkL,KAAT,CAAe7L,KAAf,EAAsB;AAClB,SAAOA,KAAK,IAAIA,KAAK,CAACN,MAAN,KAAiB,CAA1B,GAA+B,MAAKkT,MAAM,CAAC7S,IAAI,CAACC,KAAD,EAAQ,IAAR,CAAL,CAAoB,KAA9D,GAAqE,EAA5E;AACH;AACD;AACA;AACA;AACA;;;AACA,SAAS8S,IAAT,CAAcC,KAAd,EAAqBF,WAArB,EAAkCG,GAAlC,EAAuC;AACnC,SAAOH,WAAW,GAAGE,KAAK,GAAGF,WAAR,IAAuBG,GAAG,IAAI,EAA9B,CAAH,GAAuC,EAAzD;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASC,gBAAT,CAA0BhW,KAA1B,EAAwD;AAAA,MAAvBiW,aAAuB,uEAAP,KAAO;AACpD,QAAMC,OAAO,GAAGlW,KAAK,CAAC0D,OAAN,CAAc,MAAd,EAAsB,OAAtB,CAAhB;AACA,SAAO,CAAC1D,KAAK,CAAC,CAAD,CAAL,KAAa,GAAb,IAAoBA,KAAK,CAAC,CAAD,CAAL,KAAa,IAAlC,KAA2CA,KAAK,CAACmW,OAAN,CAAc,IAAd,MAAwB,CAAC,CAApE,GACA,MAAKD,OAAO,CAACxS,OAAR,CAAgB,IAAhB,EAAsB,KAAtB,CAA6B,KADlC,GAEA,QAAOuS,aAAa,GAAGC,OAAH,GAAaP,MAAM,CAACO,OAAD,CAAU,OAFxD;AAGH;;AACD,MAAME,kBAAkB,GAAG;AACvBC,EAAAA,IAAI,EAAE;AAAEC,IAAAA,KAAK,EAAEzS,IAAI,IAAIA,IAAI,CAAC7D;AAAtB,GADiB;AAEvBuW,EAAAA,QAAQ,EAAE;AAAED,IAAAA,KAAK,EAAEzS,IAAI,IAAI,MAAMA,IAAI,CAAC/D;AAA5B,GAFa;AAGvB;AACA0W,EAAAA,QAAQ,EAAE;AACNF,IAAAA,KAAK,EAAEzS,IAAI,IAAIf,IAAI,CAACe,IAAI,CAACqE,WAAN,EAAmB,MAAnB;AADb,GAJa;AAOvBuO,EAAAA,mBAAmB,EAAE;AACjBH,IAAAA,KAAK,EAAEzS,IAAI,IAAI;AACX,YAAM6S,OAAO,GAAGb,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAACe,IAAI,CAAC8S,mBAAN,EAA2B,IAA3B,CAAV,EAA4C,GAA5C,CAApB;AACA,YAAMC,MAAM,GAAG9T,IAAI,CAAC,CAACe,IAAI,CAACqI,SAAN,EAAiBpJ,IAAI,CAAC,CAACe,IAAI,CAAC/D,IAAN,EAAY4W,OAAZ,CAAD,CAArB,EAA6C5T,IAAI,CAACe,IAAI,CAAC8C,UAAN,EAAkB,GAAlB,CAAjD,CAAD,EAA2E,GAA3E,CAAnB,CAFW,CAGX;;AACA,aAAOiQ,MAAM,GAAG,GAAT,GAAe/S,IAAI,CAACgT,YAA3B;AACH;AANgB,GAPE;AAevBC,EAAAA,kBAAkB,EAAE;AAChBR,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAES,QAAAA,QAAF;AAAYxS,QAAAA,IAAZ;AAAkBE,QAAAA,YAAlB;AAAgCkC,QAAAA;AAAhC,OAAD;AAAA,aAAkDoQ,QAAQ,GAAG,IAAX,GAAkBxS,IAAlB,GAAyBsR,IAAI,CAAC,KAAD,EAAQpR,YAAR,CAA7B,GAAqDoR,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAV,CAA3G;AAAA;AADS,GAfG;AAkBvBqQ,EAAAA,YAAY,EAAE;AAAEV,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAEW,QAAAA;AAAF,OAAD;AAAA,aAAoBrI,KAAK,CAACqI,UAAD,CAAzB;AAAA;AAAT,GAlBS;AAmBvBC,EAAAA,KAAK,EAAE;AACHZ,IAAAA,KAAK,QAA6D;AAAA,UAA5D;AAAEvW,QAAAA,KAAF;AAASD,QAAAA,IAAT;AAAesE,QAAAA,SAAS,EAAEM,IAA1B;AAAgCiC,QAAAA,UAAhC;AAA4CkQ,QAAAA;AAA5C,OAA4D;AAC9D,YAAMD,MAAM,GAAGf,IAAI,CAAC,EAAD,EAAK9V,KAAL,EAAY,IAAZ,CAAJ,GAAwBD,IAAvC;AACA,UAAIqX,QAAQ,GAAGP,MAAM,GAAGf,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC4B,IAAD,EAAO,IAAP,CAAV,EAAwB,GAAxB,CAA5B;;AACA,UAAIyS,QAAQ,CAAC1U,MAAT,GAAkB2R,eAAtB,EAAuC;AACnC+C,QAAAA,QAAQ,GAAGP,MAAM,GAAGf,IAAI,CAAC,KAAD,EAAQF,MAAM,CAAC7S,IAAI,CAAC4B,IAAD,EAAO,IAAP,CAAL,CAAd,EAAkC,KAAlC,CAAxB;AACH;;AACD,aAAO5B,IAAI,CAAC,CAACqU,QAAD,EAAWrU,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAf,EAAkCkQ,YAAlC,CAAD,EAAkD,GAAlD,CAAX;AACH;;AARE,GAnBgB;AA6BvBO,EAAAA,QAAQ,EAAE;AAAEd,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQE,QAAAA;AAAR,OAAD;AAAA,aAAqBF,IAAI,GAAG,IAAP,GAAcE,KAAnC;AAAA;AAAT,GA7Ba;AA8BvB;AACAqX,EAAAA,cAAc,EAAE;AACZf,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA;AAAR,OAAD;AAAA,aAA0B,QAAQ7G,IAAR,GAAe+V,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAV,CAA7C;AAAA;AADK,GA/BO;AAkCvB2Q,EAAAA,cAAc,EAAE;AACZhB,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAEiB,QAAAA,aAAF;AAAiB5Q,QAAAA,UAAjB;AAA6BkQ,QAAAA;AAA7B,OAAD;AAAA,aAAiD/T,IAAI,CAAC,CAAC,KAAD,EAAQ+S,IAAI,CAAC,KAAD,EAAQ0B,aAAR,CAAZ,EAAoCzU,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAxC,EAA2DkQ,YAA3D,CAAD,EAA2E,GAA3E,CAArD;AAAA;AADK,GAlCO;AAqCvBW,EAAAA,kBAAkB,EAAE;AAChBlB,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQyX,QAAAA,aAAR;AAAuBZ,QAAAA,mBAAvB;AAA4ChQ,QAAAA,UAA5C;AAAwDkQ,QAAAA;AAAxD,OAAD;AAAA,aACP;AACA;AACC,oBAAW/W,IAAK,GAAE+V,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC6T,mBAAD,EAAsB,IAAtB,CAAV,EAAuC,GAAvC,CAA4C,GAAnE,GACK,MAAKY,aAAc,IAAG1B,IAAI,CAAC,EAAD,EAAK/S,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAT,EAA4B,GAA5B,CAAiC,EADhE,GAEIkQ;AALG;AAAA;AADS,GArCG;AA6CvB;AACAY,EAAAA,QAAQ,EAAE;AAAEnB,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAEtW,QAAAA;AAAF,OAAD;AAAA,aAAeA,KAAf;AAAA;AAAT,GA9Ca;AA+CvB0X,EAAAA,UAAU,EAAE;AAAEpB,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAEtW,QAAAA;AAAF,OAAD;AAAA,aAAeA,KAAf;AAAA;AAAT,GA/CW;AAgDvB2X,EAAAA,WAAW,EAAE;AACTrB,IAAAA,KAAK,EAAE,UAAqC;AAAA,UAApC;AAAEtW,QAAAA,KAAF;AAAS4O,QAAAA,KAAK,EAAEgJ;AAAhB,OAAoC;;AACxC,UAAIA,aAAJ,EAAmB;AACf,eAAO5B,gBAAgB,CAAChW,KAAD,CAAvB;AACH;;AACD,aAAOyB,IAAI,CAACC,SAAL,CAAe1B,KAAf,CAAP;AACH;AANQ,GAhDU;AAwDvB6X,EAAAA,YAAY,EAAE;AAAEvB,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAEtW,QAAAA;AAAF,OAAD;AAAA,aAAgBA,KAAK,GAAG,MAAH,GAAY,OAAjC;AAAA;AAAT,GAxDS;AAyDvB8X,EAAAA,SAAS,EAAE;AAAExB,IAAAA,KAAK,EAAE,MAAM;AAAf,GAzDY;AA0DvByB,EAAAA,SAAS,EAAE;AAAEzB,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAEtW,QAAAA;AAAF,OAAD;AAAA,aAAeA,KAAf;AAAA;AAAT,GA1DY;AA2DvBgY,EAAAA,SAAS,EAAE;AAAE1B,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAE9O,QAAAA;AAAF,OAAD;AAAA,aAAgB,MAAM1E,IAAI,CAAC0E,MAAD,EAAS,IAAT,CAAV,GAA2B,GAA3C;AAAA;AAAT,GA3DY;AA4DvByQ,EAAAA,WAAW,EAAE;AAAE3B,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAE3O,QAAAA;AAAF,OAAD;AAAA,aAAgB,MAAM7E,IAAI,CAAC6E,MAAD,EAAS,IAAT,CAAV,GAA2B,GAA3C;AAAA;AAAT,GA5DU;AA6DvBuQ,EAAAA,WAAW,EAAE;AAAE5B,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQE,QAAAA;AAAR,OAAD;AAAA,aAAqBF,IAAI,GAAG,IAAP,GAAcE,KAAnC;AAAA;AAAT,GA7DU;AA8DvB;AACAmY,EAAAA,SAAS,EAAE;AACP7B,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQsE,QAAAA,SAAS,EAAEM;AAAnB,OAAD;AAAA,aAA+B,MAAM5E,IAAN,GAAa+V,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC4B,IAAD,EAAO,IAAP,CAAV,EAAwB,GAAxB,CAAhD;AAAA;AADA,GA/DY;AAkEvB;AACA0T,EAAAA,SAAS,EAAE;AAAE9B,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA;AAAF,OAAD;AAAA,aAAcA,IAAd;AAAA;AAAT,GAnEY;AAoEvBuY,EAAAA,QAAQ,EAAE;AAAE/B,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAE/R,QAAAA;AAAF,OAAD;AAAA,aAAc,MAAMA,IAAN,GAAa,GAA3B;AAAA;AAAT,GApEa;AAqEvB+T,EAAAA,WAAW,EAAE;AAAEhC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAE/R,QAAAA;AAAF,OAAD;AAAA,aAAcA,IAAI,GAAG,GAArB;AAAA;AAAT,GArEU;AAsEvB;AACAgU,EAAAA,gBAAgB,EAAE;AACdjC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAE3P,QAAAA,UAAF;AAAcwH,QAAAA;AAAd,OAAD;AAAA,aAAoCrL,IAAI,CAAC,CAAC,QAAD,EAAWA,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAf,EAAkCiI,KAAK,CAACT,cAAD,CAAvC,CAAD,EAA2D,GAA3D,CAAxC;AAAA;AADO,GAvEK;AA0EvBqK,EAAAA,uBAAuB,EAAE;AACrBlC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAEpK,QAAAA,SAAF;AAAa3H,QAAAA;AAAb,OAAD;AAAA,aAAyB2H,SAAS,GAAG,IAAZ,GAAmB3H,IAA5C;AAAA;AADc,GA1EF;AA6EvBkU,EAAAA,oBAAoB,EAAE;AAClBnC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA;AAAR,OAAD;AAAA,aAA0B7D,IAAI,CAAC,CAAC,QAAD,EAAWhD,IAAX,EAAiBgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAArB,CAAD,EAA0C,GAA1C,CAA9B;AAAA;AADW,GA7EC;AAgFvB+R,EAAAA,oBAAoB,EAAE;AAClBpC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQmQ,QAAAA,UAAR;AAAoBtJ,QAAAA,UAApB;AAAgCgB,QAAAA;AAAhC,OAAD;AAAA,aAA8C7E,IAAI,CAAC,CAAC,MAAD,EAAShD,IAAT,EAAe+V,IAAI,CAAC,aAAD,EAAgB/S,IAAI,CAACmN,UAAD,EAAa,KAAb,CAApB,CAAnB,EAA6DnN,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAjE,EAAoFiI,KAAK,CAACjH,MAAD,CAAzF,CAAD,EAAqG,GAArG,CAAlD;AAAA;AADW,GAhFC;AAmFvBgR,EAAAA,eAAe,EAAE;AACbrC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQsE,QAAAA,SAAS,EAAEM,IAAnB;AAAyBH,QAAAA,IAAzB;AAA+BoC,QAAAA;AAA/B,OAAD;AAAA,aAAiD7G,IAAI,IACvDsV,iBAAiB,CAAC1Q,IAAD,CAAjB,GACKmR,IAAI,CAAC,KAAD,EAAQF,MAAM,CAAC7S,IAAI,CAAC4B,IAAD,EAAO,IAAP,CAAL,CAAd,EAAkC,KAAlC,CADT,GAEKmR,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC4B,IAAD,EAAO,IAAP,CAAV,EAAwB,GAAxB,CAH8C,CAAJ,GAIpD,IAJoD,GAKpDH,IALoD,GAMpDsR,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAV,CAND;AAAA;AADM,GAnFM;AA4FvBiS,EAAAA,oBAAoB,EAAE;AAClBtC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQyE,QAAAA,IAAR;AAAcE,QAAAA,YAAd;AAA4BkC,QAAAA;AAA5B,OAAD;AAAA,aAA8C7D,IAAI,CAAC,CAAChD,IAAI,GAAG,IAAP,GAAcyE,IAAf,EAAqBsR,IAAI,CAAC,IAAD,EAAOpR,YAAP,CAAzB,EAA+C3B,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAnD,CAAD,EAAwE,GAAxE,CAAlD;AAAA;AADW,GA5FC;AA+FvBkS,EAAAA,uBAAuB,EAAE;AACrBvC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQmQ,QAAAA,UAAR;AAAoBtJ,QAAAA,UAApB;AAAgCgB,QAAAA;AAAhC,OAAD;AAAA,aAA8C7E,IAAI,CAAC,CAAC,WAAD,EAAchD,IAAd,EAAoB+V,IAAI,CAAC,aAAD,EAAgB/S,IAAI,CAACmN,UAAD,EAAa,KAAb,CAApB,CAAxB,EAAkEnN,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAtE,EAAyFiI,KAAK,CAACjH,MAAD,CAA9F,CAAD,EAA0G,GAA1G,CAAlD;AAAA;AADc,GA/FF;AAkGvBmR,EAAAA,mBAAmB,EAAE;AACjBxC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA,UAAR;AAAoB0J,QAAAA;AAApB,OAAD;AAAA,aAAiCvN,IAAI,CAAC,CAAC,OAAD,EAAUhD,IAAV,EAAgBgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAApB,EAAuCkP,IAAI,CAAC,IAAD,EAAO/S,IAAI,CAACuN,KAAD,EAAQ,KAAR,CAAX,CAA3C,CAAD,EAAyE,GAAzE,CAArC;AAAA;AADU,GAlGE;AAqGvB0I,EAAAA,kBAAkB,EAAE;AAChBzC,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA,UAAR;AAAoBa,QAAAA;AAApB,OAAD;AAAA,aAAkC1E,IAAI,CAAC,CAAC,MAAD,EAAShD,IAAT,EAAegD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAnB,EAAsCiI,KAAK,CAACpH,MAAD,CAA3C,CAAD,EAAuD,GAAvD,CAAtC;AAAA;AADS,GArGG;AAwGvBwR,EAAAA,mBAAmB,EAAE;AACjB1C,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA;AAAR,OAAD;AAAA,aAA0B7D,IAAI,CAAC,CAAChD,IAAD,EAAOgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAX,CAAD,EAAgC,GAAhC,CAA9B;AAAA;AADU,GAxGE;AA2GvBsS,EAAAA,yBAAyB,EAAE;AACvB3C,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA,UAAR;AAAoBgB,QAAAA;AAApB,OAAD;AAAA,aAAkC7E,IAAI,CAAC,CAAC,OAAD,EAAUhD,IAAV,EAAgBgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAApB,EAAuCiI,KAAK,CAACjH,MAAD,CAA5C,CAAD,EAAwD,GAAxD,CAAtC;AAAA;AADgB,GA3GJ;AA8GvBuR,EAAAA,mBAAmB,EAAE;AACjB5C,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQsE,QAAAA,SAAS,EAAEM,IAAnB;AAAyBuK,QAAAA,UAAzB;AAAqCE,QAAAA;AAArC,OAAD;AAAA,aAAsD,gBACzDrP,IADyD,IAExDsV,iBAAiB,CAAC1Q,IAAD,CAAjB,GACKmR,IAAI,CAAC,KAAD,EAAQF,MAAM,CAAC7S,IAAI,CAAC4B,IAAD,EAAO,IAAP,CAAL,CAAd,EAAkC,KAAlC,CADT,GAEKmR,IAAI,CAAC,GAAD,EAAM/S,IAAI,CAAC4B,IAAD,EAAO,IAAP,CAAV,EAAwB,GAAxB,CAJ+C,KAKxDuK,UAAU,GAAG,aAAH,GAAmB,EAL2B,IAMzD,MANyD,GAOzDnM,IAAI,CAACqM,SAAD,EAAY,KAAZ,CAPD;AAAA;AADU,GA9GE;AAwHvBgK,EAAAA,eAAe,EAAE;AACb7C,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAE3P,QAAAA,UAAF;AAAcwH,QAAAA;AAAd,OAAD;AAAA,aAAoCrL,IAAI,CAAC,CAAC,eAAD,EAAkBA,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAtB,EAAyCiI,KAAK,CAACT,cAAD,CAA9C,CAAD,EAAkE,GAAlE,CAAxC;AAAA;AADM,GAxHM;AA2HvBiL,EAAAA,mBAAmB,EAAE;AACjB9C,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA;AAAR,OAAD;AAAA,aAA0B7D,IAAI,CAAC,CAAC,eAAD,EAAkBhD,IAAlB,EAAwBgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAA5B,CAAD,EAAiD,GAAjD,CAA9B;AAAA;AADU,GA3HE;AA8HvB0S,EAAAA,mBAAmB,EAAE;AACjB/C,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQmQ,QAAAA,UAAR;AAAoBtJ,QAAAA,UAApB;AAAgCgB,QAAAA;AAAhC,OAAD;AAAA,aAA8C7E,IAAI,CAAC,CAAC,aAAD,EAAgBhD,IAAhB,EAAsB+V,IAAI,CAAC,aAAD,EAAgB/S,IAAI,CAACmN,UAAD,EAAa,KAAb,CAApB,CAA1B,EAAoEnN,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAAxE,EAA2FiI,KAAK,CAACjH,MAAD,CAAhG,CAAD,EAA4G,GAA5G,CAAlD;AAAA;AADU,GA9HE;AAiIvB2R,EAAAA,sBAAsB,EAAE;AACpBhD,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQmQ,QAAAA,UAAR;AAAoBtJ,QAAAA,UAApB;AAAgCgB,QAAAA;AAAhC,OAAD;AAAA,aAA8C7E,IAAI,CAAC,CAAC,kBAAD,EAAqBhD,IAArB,EAA2B+V,IAAI,CAAC,aAAD,EAAgB/S,IAAI,CAACmN,UAAD,EAAa,KAAb,CAApB,CAA/B,EAAyEnN,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAA7E,EAAgGiI,KAAK,CAACjH,MAAD,CAArG,CAAD,EAAiH,GAAjH,CAAlD;AAAA;AADa,GAjID;AAoIvB4R,EAAAA,kBAAkB,EAAE;AAChBjD,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA,UAAR;AAAoB0J,QAAAA;AAApB,OAAD;AAAA,aAAiCvN,IAAI,CAAC,CAAC,cAAD,EAAiBhD,IAAjB,EAAuBgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAA3B,EAA8CkP,IAAI,CAAC,IAAD,EAAO/S,IAAI,CAACuN,KAAD,EAAQ,KAAR,CAAX,CAAlD,CAAD,EAAgF,GAAhF,CAArC;AAAA;AADS,GApIG;AAuIvBmJ,EAAAA,iBAAiB,EAAE;AACflD,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA,UAAR;AAAoBa,QAAAA;AAApB,OAAD;AAAA,aAAkC1E,IAAI,CAAC,CAAC,aAAD,EAAgBhD,IAAhB,EAAsBgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAA1B,EAA6CiI,KAAK,CAACpH,MAAD,CAAlD,CAAD,EAA8D,GAA9D,CAAtC;AAAA;AADQ,GAvII;AA0IvBiS,EAAAA,wBAAwB,EAAE;AACtBnD,IAAAA,KAAK,EAAE;AAAA,UAAC;AAAExW,QAAAA,IAAF;AAAQ6G,QAAAA,UAAR;AAAoBgB,QAAAA;AAApB,OAAD;AAAA,aAAkC7E,IAAI,CAAC,CAAC,cAAD,EAAiBhD,IAAjB,EAAuBgD,IAAI,CAAC6D,UAAD,EAAa,GAAb,CAA3B,EAA8CiI,KAAK,CAACjH,MAAD,CAAnD,CAAD,EAA+D,GAA/D,CAAtC;AAAA;AADe;AA1IH,CAA3B;AA8IA,MAAM+R,8BAA8B,GAAGlX,MAAM,CAACsS,IAAP,CAAYsB,kBAAZ,EAAgCpS,MAAhC,CAAuC,CAACC,IAAD,EAAOpB,GAAP,MAAgB,EAC1F,GAAGoB,IADuF;AAE1F,GAACpB,GAAD,GAAO;AACHyT,IAAAA,KAAK,EAAEjB,cAAc,CAACe,kBAAkB,CAACvT,GAAD,CAAlB,CAAwByT,KAAzB;AADlB;AAFmF,CAAhB,CAAvC,EAKnC,EALmC,CAAvC;AAMA;AACA;AACA;AACA;;AACA,SAASqD,iBAAT,CAA2B5P,GAA3B,EAAgC;AAC5B,SAAOtN,KAAK,CAACsN,GAAD,EAAM2P,8BAAN,CAAZ;AACH;;AACD,SAAShF,qBAAT,CAA+B7Q,IAA/B,EAAqC;AACjC,SAAOA,IAAI,CAAC5D,IAAL,KAAc,iBAArB;AACH,C,CACD;;;AACA,SAAS2Z,cAAT,CAAwB/V,IAAxB,EAA8BiE,OAA9B,EAAuC;AACnC,MAAIjE,IAAI,CAAC8K,WAAL,IAAoB,IAAxB,EAA8B;AAC1B,WAAO9K,IAAI,CAAC8K,WAAL,CAAiB3O,KAAxB;AACH;;AACD,MAAI8H,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC+R,mBAA9D,EAAmF;AAC/E,WAAOhF,UAAU,CAAChR,IAAD,CAAjB;AACH;AACJ;;AACD,SAASgR,UAAT,CAAoBhR,IAApB,EAA0B;AACtB,QAAMiW,QAAQ,GAAGC,sBAAsB,CAAClW,IAAD,CAAvC;;AACA,MAAIiW,QAAQ,KAAKlV,SAAjB,EAA4B;AACxB,WAAOoV,sBAAsB,CAAE,KAAIF,QAAS,EAAf,CAA7B;AACH;AACJ;;AACD,SAASC,sBAAT,CAAgClW,IAAhC,EAAsC;AAClC,QAAMoW,GAAG,GAAGpW,IAAI,CAACoW,GAAjB;;AACA,MAAI,CAACA,GAAL,EAAU;AACN;AACH;;AACD,QAAMC,QAAQ,GAAG,EAAjB;AACA,MAAIC,KAAK,GAAGF,GAAG,CAACG,UAAJ,CAAenW,IAA3B;;AACA,SAAOkW,KAAK,IAAI,IAAT,IACHA,KAAK,CAACla,IAAN,KAAevD,SAAS,CAAC2d,OADtB,IAEHF,KAAK,CAACG,IAAN,IAAc,IAFX,IAGHH,KAAK,CAAClW,IAAN,IAAc,IAHX,IAIHkW,KAAK,CAACjH,IAAN,GAAa,CAAb,KAAmBiH,KAAK,CAACG,IAAN,CAAWpH,IAJ3B,IAKHiH,KAAK,CAACjH,IAAN,KAAeiH,KAAK,CAAClW,IAAN,CAAWiP,IAL9B,EAKoC;AAChC,UAAMlT,KAAK,GAAGN,MAAM,CAACya,KAAK,CAACna,KAAP,CAApB;AACAka,IAAAA,QAAQ,CAAC5W,IAAT,CAActD,KAAd;AACAma,IAAAA,KAAK,GAAGA,KAAK,CAAClW,IAAd;AACH;;AACD,SAAOiW,QAAQ,CAACzX,MAAT,GAAkB,CAAlB,GAAsByX,QAAQ,CAACK,OAAT,GAAmBzX,IAAnB,CAAwB,IAAxB,CAAtB,GAAsD8B,SAA7D;AACH;;AACD,SAASoV,sBAAT,CAAgCQ,SAAhC,EAA2C;AACvC;AACA,QAAMC,KAAK,GAAGD,SAAS,CAACE,KAAV,CAAgB,cAAhB,CAAd,CAFuC,CAGvC;;AACA,QAAMC,YAAY,GAAGC,yBAAyB,CAACH,KAAD,CAA9C;;AACA,MAAIE,YAAY,KAAK,CAArB,EAAwB;AACpB,SAAK,IAAItX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoX,KAAK,CAAChY,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AACnCoX,MAAAA,KAAK,CAACpX,CAAD,CAAL,GAAWoX,KAAK,CAACpX,CAAD,CAAL,CAASuQ,KAAT,CAAe+G,YAAf,CAAX;AACH;AACJ,GATsC,CAUvC;;;AACA,SAAOF,KAAK,CAAChY,MAAN,GAAe,CAAf,IAAoBoY,OAAO,CAACJ,KAAK,CAAC,CAAD,CAAN,CAAlC,EAA8C;AAC1CA,IAAAA,KAAK,CAACK,KAAN;AACH;;AACD,SAAOL,KAAK,CAAChY,MAAN,GAAe,CAAf,IAAoBoY,OAAO,CAACJ,KAAK,CAACA,KAAK,CAAChY,MAAN,GAAe,CAAhB,CAAN,CAAlC,EAA6D;AACzDgY,IAAAA,KAAK,CAACM,GAAN;AACH,GAhBsC,CAiBvC;;;AACA,SAAON,KAAK,CAAC3X,IAAN,CAAW,IAAX,CAAP;AACH;AACD;AACA;AACA;;;AACA,SAAS8X,yBAAT,CAAmCH,KAAnC,EAA0C;AACtC,MAAIE,YAAY,GAAG,IAAnB;;AACA,OAAK,IAAItX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoX,KAAK,CAAChY,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AACnC,UAAM6P,IAAI,GAAGuH,KAAK,CAACpX,CAAD,CAAlB;AACA,UAAMsS,MAAM,GAAGqF,iBAAiB,CAAC9H,IAAD,CAAhC;;AACA,QAAIyC,MAAM,KAAKzC,IAAI,CAACzQ,MAApB,EAA4B;AACxB,eADwB,CACd;AACb;;AACD,QAAIkY,YAAY,KAAK,IAAjB,IAAyBhF,MAAM,GAAGgF,YAAtC,EAAoD;AAChDA,MAAAA,YAAY,GAAGhF,MAAf;;AACA,UAAIgF,YAAY,KAAK,CAArB,EAAwB;AACpB;AACH;AACJ;AACJ;;AACD,SAAOA,YAAY,KAAK,IAAjB,GAAwB,CAAxB,GAA4BA,YAAnC;AACH;;AACD,SAASK,iBAAT,CAA2B9b,GAA3B,EAAgC;AAC5B,MAAImE,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGnE,GAAG,CAACuD,MAAR,KAAmBvD,GAAG,CAACmE,CAAD,CAAH,KAAW,GAAX,IAAkBnE,GAAG,CAACmE,CAAD,CAAH,KAAW,IAAhD,CAAP,EAA8D;AAC1DA,IAAAA,CAAC;AACJ;;AACD,SAAOA,CAAP;AACH;;AACD,SAASwX,OAAT,CAAiB3b,GAAjB,EAAsB;AAClB,SAAO8b,iBAAiB,CAAC9b,GAAD,CAAjB,KAA2BA,GAAG,CAACuD,MAAtC;AACH;;AAED,SAASwY,eAAT,CAAyB7L,QAAzB,EAAmC+E,MAAnC,EAAyD;AAAA,MAAdrM,OAAc,uEAAJ,EAAI;AACrD,MAAIsK,QAAJ;;AACA,MAAI;AACA,QAAItK,OAAO,CAAC+R,mBAAR,IAA+B1F,MAAM,CAAClS,QAAP,CAAgB,GAAhB,CAAnC,EAAyD;AACrDmQ,MAAAA,QAAQ,GAAG8I,+BAA+B,CAAC/G,MAAD,EAASrM,OAAT,CAA1C,CADqD,CAErD;AACA;AACA;;AACA,UAAIA,OAAO,CAACqT,UAAZ,EAAwB;AACpB/I,QAAAA,QAAQ,GAAGlX,KAAK,CAACK,KAAK,CAAC6W,QAAD,CAAN,EAAkBtK,OAAlB,CAAhB;AACH;AACJ,KARD,MASK;AACDsK,MAAAA,QAAQ,GAAGlX,KAAK,CAAC,IAAIyB,MAAJ,CAAWwX,MAAX,EAAmB/E,QAAnB,CAAD,EAA+BtH,OAA/B,CAAhB;AACH;AACJ,GAbD,CAcA,OAAO1I,CAAP,EAAU;AACN,QAAIA,CAAC,CAACqB,OAAF,CAAUwB,QAAV,CAAmB,KAAnB,KAA6BkS,MAAM,CAACzQ,OAAP,CAAe,YAAf,EAA6B,EAA7B,EAAiC0X,IAAjC,OAA4C,EAA7E,EAAiF;AAC7EhJ,MAAAA,QAAQ,GAAG;AACPnS,QAAAA,IAAI,EAAE5E,IAAI,CAACyS,QADJ;AAEP5F,QAAAA,WAAW,EAAE;AAFN,OAAX;AAIH,KALD,MAMK;AACD,YAAM9I,CAAN;AACH;AACJ;;AACD,SAAO;AACHgQ,IAAAA,QADG;AAEHgD,IAAAA;AAFG,GAAP;AAIH;;AACD,SAAS8I,+BAAT,CAAyCG,SAAzC,EAAkE;AAAA,MAAdvT,OAAc,uEAAJ,EAAI;AAC9D,QAAMwT,SAAS,GAAGpgB,KAAK,CAACmgB,SAAD,EAAY,EAC/B,GAAGvT,OAD4B;AAE/BqT,IAAAA,UAAU,EAAE;AAFmB,GAAZ,CAAvB;AAIA,QAAMI,WAAW,GAAG9e,KAAK,CAAC6e,SAAD,EAAY;AACjChF,IAAAA,KAAK,EAAGzS,IAAD,IAAU;AACb,UAAI2X,aAAa,CAAC3X,IAAD,CAAjB,EAAyB;AACrB,cAAMiW,QAAQ,GAAGC,sBAAsB,CAAClW,IAAD,CAAvC;;AACA,YAAIiW,QAAQ,KAAKlV,SAAjB,EAA4B;AACxB,gBAAM6W,aAAa,GAAGzB,sBAAsB,CAAC,OAAOF,QAAR,CAA5C;AACA,gBAAM4B,OAAO,GAAGD,aAAa,CAACxZ,QAAd,CAAuB,IAAvB,CAAhB;;AACA,cAAI,CAAC4B,IAAI,CAAC8K,WAAV,EAAuB;AACnB,mBAAO,EACH,GAAG9K,IADA;AAEH8K,cAAAA,WAAW,EAAE;AACT1O,gBAAAA,IAAI,EAAE5E,IAAI,CAACgM,MADF;AAETrH,gBAAAA,KAAK,EAAEyb,aAFE;AAGT7M,gBAAAA,KAAK,EAAE8M;AAHE;AAFV,aAAP;AAQH,WATD,MAUK;AACD,mBAAO,EACH,GAAG7X,IADA;AAEH8K,cAAAA,WAAW,EAAE,EACT,GAAG9K,IAAI,CAAC8K,WADC;AAET3O,gBAAAA,KAAK,EAAE6D,IAAI,CAAC8K,WAAL,CAAiB3O,KAAjB,GAAyB,IAAzB,GAAgCyb,aAF9B;AAGT7M,gBAAAA,KAAK,EAAE;AAHE;AAFV,aAAP;AAQH;AACJ;AACJ;AACJ;AA7BgC,GAAZ,CAAzB;AA+BA,SAAO2M,WAAP;AACH;;AACD,SAASC,aAAT,CAAuB3X,IAAvB,EAA6B;AACzB,SAAQjH,0BAA0B,CAACiH,IAAD,CAA1B,IACJA,IAAI,CAAC5D,IAAL,KAAc5E,IAAI,CAAC6V,gBADf,IAEJrN,IAAI,CAAC5D,IAAL,KAAc5E,IAAI,CAACwU,sBAFf,IAGJhM,IAAI,CAAC5D,IAAL,KAAc5E,IAAI,CAAC8V,qBAHvB;AAIH;;AAED,IAAIwK,kBAAkB,GAAG,EAAzB;AACA,IAAIC,YAAY,GAAG,IAAIlP,GAAJ,EAAnB;;AACA,SAASmP,oBAAT,CAA8B9E,QAA9B,EAAwC;AACpC4E,EAAAA,kBAAkB,CAACrY,IAAnB,CAAwByT,QAAxB;AACH;;AACD,SAAS+E,uBAAT,GAAmC;AAC/BH,EAAAA,kBAAkB,GAAG,EAArB;AACH;;AACD,SAASI,aAAT,GAAyB;AACrBH,EAAAA,YAAY,GAAG,IAAIlP,GAAJ,EAAf;AACH;;AACD,SAASsP,0BAAT,SAAwJ;AAAA,MAApH;AAAE7V,IAAAA,MAAF;AAAUlG,IAAAA,IAAV;AAAgBoI,IAAAA,KAAhB;AAAuB4T,IAAAA,MAAvB;AAA+BC,IAAAA,MAAM,GAAG,EAAxC;AAA4CC,IAAAA,UAA5C;AAAwDC,IAAAA,sBAAxD;AAAgFC,IAAAA,QAAhF;AAA0FC,IAAAA,cAAc,GAAG;AAA3G,GAAoH;AACpJR,EAAAA,uBAAuB;AACvBC,EAAAA,aAAa;AACb,QAAMQ,aAAa,GAAGjQ,gBAAgB,CAACnG,MAAD,CAAtC;AACA,QAAMqW,aAAa,GAAGC,iCAAiC,CAAC;AACpDtW,IAAAA,MADoD;AAEpDmC,IAAAA,SAAS,EAAED,KAFyC;AAGpDpI,IAAAA,IAHoD;AAIpDgc,IAAAA,MAAM,EAAEA,MAAM,IAAI,EAJkC;AAKpDC,IAAAA,MALoD;AAMpDC,IAAAA,UAAU,EAAEA,UAAU,IAAIO,QAN0B;AAOpDN,IAAAA,sBAAsB,EAAEA,sBAAsB,IAAI,CAPE;AAQpDC,IAAAA,QARoD;AASpDC,IAAAA,cAToD;AAUpDC,IAAAA;AAVoD,GAAD,CAAvD,CAJoJ,CAgBpJ;;AACAC,EAAAA,aAAa,CAAC7F,mBAAd,GAAoC,CAAC,GAAGgF,kBAAJ,CAApC;AACAG,EAAAA,uBAAuB;AACvBC,EAAAA,aAAa;AACb,SAAOS,aAAP;AACH;;AACD,SAASC,iCAAT,SAAsK;AAAA,MAA3H;AAAEtW,IAAAA,MAAF;AAAUmC,IAAAA,SAAV;AAAqBrI,IAAAA,IAArB;AAA2Bgc,IAAAA,MAA3B;AAAmCC,IAAAA,MAAnC;AAA2CC,IAAAA,UAA3C;AAAuDC,IAAAA,sBAAvD;AAA+EC,IAAAA,QAA/E;AAAyFC,IAAAA,cAAzF;AAAyGC,IAAAA;AAAzG,GAA2H;AAClK,QAAMhY,IAAI,GAAG0H,kBAAkB,CAAC9F,MAAD,EAASlG,IAAT,CAA/B;AACA,QAAMoI,KAAK,GAAG9D,IAAI,CAACwL,SAAL,GAAiBzH,SAAjB,CAAd;AACA,QAAMqU,aAAa,GAAI,GAAErU,SAAU,IAAGrI,IAAK,EAA3C;;AACA,MAAIoI,KAAK,CAAC3D,IAAV,EAAgB;AACZ,SAAK,MAAMJ,GAAX,IAAkB+D,KAAK,CAAC3D,IAAxB,EAA8B;AAC1B,YAAM4M,OAAO,GAAGhN,GAAG,CAACxE,IAApB;;AACA,UAAI,CAACuc,QAAD,IAAaA,QAAQ,CAACpa,QAAT,CAAkBqP,OAAlB,CAAjB,EAA6C;AACzCuK,QAAAA,oBAAoB,CAACe,eAAe,CAACtY,GAAD,EAAMgN,OAAN,CAAhB,CAApB;AACH;AACJ;AACJ;;AACD,SAAO;AACHrR,IAAAA,IAAI,EAAE5E,IAAI,CAACwhB,oBADR;AAEH3Q,IAAAA,SAAS,EAAEjM,IAFR;AAGHH,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAE2c;AAFL,KAHH;AAOHhG,IAAAA,mBAAmB,EAAE,EAPlB;AAQHE,IAAAA,YAAY,EAAE;AACV5W,MAAAA,IAAI,EAAE5E,IAAI,CAACyhB,aADD;AAEV7F,MAAAA,UAAU,EAAE,CACR8F,YAAY,CAAC;AACTxY,QAAAA,IADS;AAET8D,QAAAA,KAFS;AAGT4T,QAAAA,MAHS;AAITe,QAAAA,SAAS,EAAE,IAJF;AAKTjI,QAAAA,IAAI,EAAE,EALG;AAMTU,QAAAA,SAAS,EAAE,EANF;AAOTyG,QAAAA,MAPS;AAQTC,QAAAA,UARS;AASTC,QAAAA,sBATS;AAUTjW,QAAAA,MAVS;AAWT8W,QAAAA,KAAK,EAAE,CAXE;AAYTZ,QAAAA,QAZS;AAaTC,QAAAA,cAbS;AAcTC,QAAAA;AAdS,OAAD,CADJ;AAFF;AARX,GAAP;AA8BH;;AACD,SAASW,mBAAT,SAAwL;AAAA,MAA3J;AAAExH,IAAAA,MAAF;AAAUnR,IAAAA,IAAV;AAAgB0X,IAAAA,MAAhB;AAAwBe,IAAAA,SAAxB;AAAmCjI,IAAAA,IAAnC;AAAyCU,IAAAA,SAAzC;AAAoDyG,IAAAA,MAApD;AAA4DC,IAAAA,UAA5D;AAAwEC,IAAAA,sBAAxE;AAAgGjW,IAAAA,MAAhG;AAAwG8W,IAAAA,KAAxG;AAA+GZ,IAAAA,QAA/G;AAAyHC,IAAAA,cAAzH;AAAyIC,IAAAA;AAAzI,GAA2J;;AACpL,MAAI,OAAOD,cAAP,KAA0B,SAA1B,IAAuCW,KAAK,GAAGd,UAAnD,EAA+D;AAC3D;AACH;;AACD,MAAIpgB,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACnB,UAAM8L,KAAK,GAAG9L,IAAI,CAAC+L,QAAL,EAAd;AACA,WAAO;AACHrQ,MAAAA,IAAI,EAAE5E,IAAI,CAACyhB,aADR;AAEH7F,MAAAA,UAAU,EAAE5G,KAAK,CACZzK,MADO,CACAuX,CAAC,IAAI,CAACC,cAAc,CAAC,CAAC,GAAG3H,SAAJ,EAAe0H,CAAf,CAAD,EAAoB;AAChDF,QAAAA,KAAK,EAAEb;AADyC,OAApB,CADpB,EAIPxZ,GAJO,CAIHua,CAAC,IAAI;AACV,eAAO;AACHld,UAAAA,IAAI,EAAE5E,IAAI,CAACgiB,eADR;AAEH9F,UAAAA,aAAa,EAAE;AACXtX,YAAAA,IAAI,EAAE5E,IAAI,CAACkO,UADA;AAEXzJ,YAAAA,IAAI,EAAE;AACFG,cAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,cAAAA,KAAK,EAAEmd,CAAC,CAACrd;AAFP;AAFK,WAFZ;AASH+W,UAAAA,YAAY,EAAEqG,mBAAmB,CAAC;AAC9BxH,YAAAA,MAAM,EAAEnR,IADsB;AAE9BA,YAAAA,IAAI,EAAE4Y,CAFwB;AAG9BlB,YAAAA,MAH8B;AAI9BlH,YAAAA,IAJ8B;AAK9BU,YAAAA,SAL8B;AAM9ByG,YAAAA,MAN8B;AAO9BC,YAAAA,UAP8B;AAQ9BC,YAAAA,sBAR8B;AAS9BjW,YAAAA,MAT8B;AAU9B8W,YAAAA,KAV8B;AAW9BZ,YAAAA,QAX8B;AAY9BC,YAAAA,cAZ8B;AAa9BC,YAAAA;AAb8B,WAAD;AAT9B,SAAP;AAyBH,OA9BW,EA+BP3W,MA/BO,CA+BA0X,YAAY,IAAI;AAAE,YAAI1d,EAAJ,EAAQC,EAAR;;AAAY,eAAO,CAAC,CAACA,EAAE,GAAG,CAACD,EAAE,GAAG0d,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACzG,YAA/E,MAAiG,IAAjG,IAAyGjX,EAAE,KAAK,KAAK,CAArH,GAAyH,KAAK,CAA9H,GAAkIA,EAAE,CAACqX,UAA3I,MAA2J,IAA3J,IAAmKpX,EAAE,KAAK,KAAK,CAA/K,GAAmL,KAAK,CAAxL,GAA4LA,EAAE,CAAC4C,MAAhM,IAA0M,CAAjN;AAAqN,OA/BnP;AAFT,KAAP;AAmCH;;AACD,MAAI3G,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AACvB,UAAM8L,KAAK,GAAG7N,MAAM,CAACgF,MAAP,CAAcrB,MAAM,CAACwC,UAAP,EAAd,EAAmC/C,MAAnC,CAA2CuX,CAAD,IAAO3hB,YAAY,CAAC2hB,CAAD,CAAZ,IAAmBA,CAAC,CAACpU,aAAF,GAAkB9G,QAAlB,CAA2BsC,IAA3B,CAApE,CAAd;AACA,WAAO;AACHtE,MAAAA,IAAI,EAAE5E,IAAI,CAACyhB,aADR;AAEH7F,MAAAA,UAAU,EAAE5G,KAAK,CACZzK,MADO,CACAuX,CAAC,IAAI,CAACC,cAAc,CAAC,CAAC,GAAG3H,SAAJ,EAAe0H,CAAf,CAAD,EAAoB;AAChDF,QAAAA,KAAK,EAAEb;AADyC,OAApB,CADpB,EAIPxZ,GAJO,CAIHua,CAAC,IAAI;AACV,eAAO;AACHld,UAAAA,IAAI,EAAE5E,IAAI,CAACgiB,eADR;AAEH9F,UAAAA,aAAa,EAAE;AACXtX,YAAAA,IAAI,EAAE5E,IAAI,CAACkO,UADA;AAEXzJ,YAAAA,IAAI,EAAE;AACFG,cAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,cAAAA,KAAK,EAAEmd,CAAC,CAACrd;AAFP;AAFK,WAFZ;AASH+W,UAAAA,YAAY,EAAEqG,mBAAmB,CAAC;AAC9BxH,YAAAA,MAAM,EAAEnR,IADsB;AAE9BA,YAAAA,IAAI,EAAE4Y,CAFwB;AAG9BlB,YAAAA,MAH8B;AAI9BlH,YAAAA,IAJ8B;AAK9BU,YAAAA,SAL8B;AAM9ByG,YAAAA,MAN8B;AAO9BC,YAAAA,UAP8B;AAQ9BC,YAAAA,sBAR8B;AAS9BjW,YAAAA,MAT8B;AAU9B8W,YAAAA,KAV8B;AAW9BZ,YAAAA,QAX8B;AAY9BC,YAAAA,cAZ8B;AAa9BC,YAAAA;AAb8B,WAAD;AAT9B,SAAP;AAyBH,OA9BW,EA+BP3W,MA/BO,CA+BA0X,YAAY,IAAI;AAAE,YAAI1d,EAAJ,EAAQC,EAAR;;AAAY,eAAO,CAAC,CAACA,EAAE,GAAG,CAACD,EAAE,GAAG0d,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACzG,YAA/E,MAAiG,IAAjG,IAAyGjX,EAAE,KAAK,KAAK,CAArH,GAAyH,KAAK,CAA9H,GAAkIA,EAAE,CAACqX,UAA3I,MAA2J,IAA3J,IAAmKpX,EAAE,KAAK,KAAK,CAA/K,GAAmL,KAAK,CAAxL,GAA4LA,EAAE,CAAC4C,MAAhM,IAA0M,CAAjN;AAAqN,OA/BnP;AAFT,KAAP;AAmCH;;AACD,MAAIjH,YAAY,CAAC+I,IAAD,CAAZ,IAAsB,CAACgY,aAAa,CAACgB,GAAd,CAAkBhZ,IAAI,CAACzE,IAAvB,CAA3B,EAAyD;AACrD,UAAM0d,SAAS,GAAGtB,MAAM,CAACja,QAAP,CAAgBsC,IAAI,CAACzE,IAArB,KAA8Boc,MAAM,CAACja,QAAP,CAAiB,GAAEyT,MAAM,CAAC5V,IAAK,IAAGiV,IAAI,CAACA,IAAI,CAACtS,MAAL,GAAc,CAAf,CAAkB,EAAxD,CAAhD;AACA,UAAMgb,OAAO,GAAGxB,MAAM,CAACha,QAAP,CAAgBsC,IAAI,CAACzE,IAArB,CAAhB;;AACA,QAAI,CAACkd,SAAD,IAAcS,OAAd,IAAyB,CAACD,SAA9B,EAAyC;AACrC,aAAO;AACHvd,QAAAA,IAAI,EAAE5E,IAAI,CAACyhB,aADR;AAEH7F,QAAAA,UAAU,EAAE,CACR;AACIhX,UAAAA,IAAI,EAAE5E,IAAI,CAACqiB,KADf;AAEI5d,UAAAA,IAAI,EAAE;AACFG,YAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,YAAAA,KAAK,EAAE;AAFL;AAFV,SADQ;AAFT,OAAP;AAYH;;AACD,UAAM2H,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf;AACA,WAAO;AACH9P,MAAAA,IAAI,EAAE5E,IAAI,CAACyhB,aADR;AAEH7F,MAAAA,UAAU,EAAEzU,MAAM,CAACsS,IAAP,CAAYnN,MAAZ,EACP/B,MADO,CACA0C,SAAS,IAAI;AACrB,eAAO,CAAC8U,cAAc,CAAC,CAAC,GAAG3H,SAAJ,EAAe5Y,YAAY,CAAC8K,MAAM,CAACW,SAAD,CAAN,CAAkB/D,IAAnB,CAA3B,CAAD,EAAuD;AACzE0Y,UAAAA,KAAK,EAAEb;AADkE,SAAvD,CAAtB;AAGH,OALW,EAMPxZ,GANO,CAMH0F,SAAS,IAAI;AAClB,cAAMqV,iBAAiB,GAAG,OAAOrB,cAAP,KAA0B,QAA1B,GAAqCA,cAAc,CAAChU,SAAD,CAAnD,GAAiE,IAA3F;;AACA,YAAIqV,iBAAJ,EAAuB;AACnB,iBAAOZ,YAAY,CAAC;AAChBxY,YAAAA,IAAI,EAAEA,IADU;AAEhB8D,YAAAA,KAAK,EAAEV,MAAM,CAACW,SAAD,CAFG;AAGhB2T,YAAAA,MAHgB;AAIhBlH,YAAAA,IAAI,EAAE,CAAC,GAAGA,IAAJ,EAAUzM,SAAV,CAJU;AAKhBmN,YAAAA,SALgB;AAMhByG,YAAAA,MANgB;AAOhBC,YAAAA,UAPgB;AAQhBC,YAAAA,sBARgB;AAShBjW,YAAAA,MATgB;AAUhB8W,YAAAA,KAVgB;AAWhBZ,YAAAA,QAXgB;AAYhBC,YAAAA,cAAc,EAAEqB,iBAZA;AAahBpB,YAAAA;AAbgB,WAAD,CAAnB;AAeH;;AACD,eAAO,IAAP;AACH,OA1BW,EA2BP3W,MA3BO,CA2BC4N,CAAD,IAAO;AACf,YAAI5T,EAAJ,EAAQC,EAAR;;AACA,YAAI2T,CAAC,IAAI,IAAT,EAAe;AACX,iBAAO,KAAP;AACH,SAFD,MAGK,IAAI,kBAAkBA,CAAtB,EAAyB;AAC1B,iBAAO,CAAC,EAAE,CAAC3T,EAAE,GAAG,CAACD,EAAE,GAAG4T,CAAC,CAACqD,YAAR,MAA0B,IAA1B,IAAkCjX,EAAE,KAAK,KAAK,CAA9C,GAAkD,KAAK,CAAvD,GAA2DA,EAAE,CAACqX,UAApE,MAAoF,IAApF,IAA4FpX,EAAE,KAAK,KAAK,CAAxG,GAA4G,KAAK,CAAjH,GAAqHA,EAAE,CAAC4C,MAA1H,CAAR;AACH;;AACD,eAAO,IAAP;AACH,OApCW;AAFT,KAAP;AAwCH;AACJ;;AACD,SAASma,eAAT,CAAyBtY,GAAzB,EAA8BxE,IAA9B,EAAoC;AAChC,WAAS8d,mBAAT,CAA6BrZ,IAA7B,EAAmC;AAC/B,QAAI9I,UAAU,CAAC8I,IAAD,CAAd,EAAsB;AAClB,aAAO;AACHtE,QAAAA,IAAI,EAAE5E,IAAI,CAACiO,SADR;AAEH/E,QAAAA,IAAI,EAAEqZ,mBAAmB,CAACrZ,IAAI,CAAC6E,MAAN;AAFtB,OAAP;AAIH;;AACD,QAAIhO,aAAa,CAACmJ,IAAD,CAAjB,EAAyB;AACrB,aAAO;AACHtE,QAAAA,IAAI,EAAE5E,IAAI,CAACgO,aADR;AAEH;AACA9E,QAAAA,IAAI,EAAEqZ,mBAAmB,CAACrZ,IAAI,CAAC6E,MAAN;AAHtB,OAAP;AAKH;;AACD,WAAO;AACHnJ,MAAAA,IAAI,EAAE5E,IAAI,CAACkO,UADR;AAEHzJ,MAAAA,IAAI,EAAE;AACFG,QAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,QAAAA,KAAK,EAAEuE,IAAI,CAACzE;AAFV;AAFH,KAAP;AAOH;;AACD,SAAO;AACHG,IAAAA,IAAI,EAAE5E,IAAI,CAACwiB,mBADR;AAEH9G,IAAAA,QAAQ,EAAE;AACN9W,MAAAA,IAAI,EAAE5E,IAAI,CAAC2J,QADL;AAENlF,MAAAA,IAAI,EAAE;AACFG,QAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,QAAAA,KAAK,EAAEF,IAAI,IAAIwE,GAAG,CAACxE;AAFjB;AAFA,KAFP;AASHyE,IAAAA,IAAI,EAAEqZ,mBAAmB,CAACtZ,GAAG,CAACC,IAAL;AATtB,GAAP;AAWH;;AACD,SAASuZ,eAAT,CAAyBhe,IAAzB,EAA+BiV,IAA/B,EAAqC;AACjC,SAAO,CAAC,GAAGA,IAAJ,EAAUjV,IAAV,EAAgBgD,IAAhB,CAAqB,GAArB,CAAP;AACH;;AACD,SAASia,YAAT,SAAgL;AAAA,MAA1J;AAAExY,IAAAA,IAAF;AAAQ8D,IAAAA,KAAR;AAAe4T,IAAAA,MAAf;AAAuBe,IAAAA,SAAvB;AAAkCjI,IAAAA,IAAlC;AAAwCU,IAAAA,SAAxC;AAAmDyG,IAAAA,MAAnD;AAA2DC,IAAAA,UAA3D;AAAuEC,IAAAA,sBAAvE;AAA+FjW,IAAAA,MAA/F;AAAuG8W,IAAAA,KAAvG;AAA8GZ,IAAAA,QAA9G;AAAwHC,IAAAA,cAAxH;AAAwIC,IAAAA;AAAxI,GAA0J;AAC5K,QAAMwB,SAAS,GAAGlhB,YAAY,CAACwL,KAAK,CAAC9D,IAAP,CAA9B;AACA,MAAIG,IAAI,GAAG,EAAX;AACA,MAAIsZ,WAAW,GAAG,KAAlB;;AACA,MAAI3V,KAAK,CAAC3D,IAAN,IAAc2D,KAAK,CAAC3D,IAAN,CAAWjC,MAA7B,EAAqC;AACjCiC,IAAAA,IAAI,GAAG2D,KAAK,CAAC3D,IAAN,CACF9B,GADE,CACE0B,GAAG,IAAI;AACZ,YAAM2Z,YAAY,GAAGH,eAAe,CAACxZ,GAAG,CAACxE,IAAL,EAAWiV,IAAX,CAApC;;AACA,UAAIsH,QAAQ,IAAI,CAACA,QAAQ,CAACpa,QAAT,CAAkBgc,YAAlB,CAAjB,EAAkD;AAC9C,YAAI7iB,aAAa,CAACkJ,GAAG,CAACC,IAAL,CAAjB,EAA6B;AACzByZ,UAAAA,WAAW,GAAG,IAAd;AACH;;AACD,eAAO,IAAP;AACH;;AACD,UAAI,CAAChB,SAAL,EAAgB;AACZnB,QAAAA,oBAAoB,CAACe,eAAe,CAACtY,GAAD,EAAM2Z,YAAN,CAAhB,CAApB;AACH;;AACD,aAAO;AACHhe,QAAAA,IAAI,EAAE5E,IAAI,CAACmW,QADR;AAEH1R,QAAAA,IAAI,EAAE;AACFG,UAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,UAAAA,KAAK,EAAEsE,GAAG,CAACxE;AAFT,SAFH;AAMHE,QAAAA,KAAK,EAAE;AACHC,UAAAA,IAAI,EAAE5E,IAAI,CAAC2J,QADR;AAEHlF,UAAAA,IAAI,EAAE;AACFG,YAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,YAAAA,KAAK,EAAE8d,eAAe,CAACxZ,GAAG,CAACxE,IAAL,EAAWiV,IAAX;AAFpB;AAFH;AANJ,OAAP;AAcH,KA1BM,EA2BFnP,MA3BE,CA2BKwB,OA3BL,CAAP;AA4BH;;AACD,MAAI4W,WAAJ,EAAiB;AACb,WAAO,IAAP;AACH;;AACD,QAAME,SAAS,GAAG,CAAC,GAAGnJ,IAAJ,EAAU1M,KAAK,CAACvI,IAAhB,CAAlB;AACA,QAAMqe,YAAY,GAAGD,SAAS,CAACpb,IAAV,CAAe,GAAf,CAArB;AACA,MAAIwF,SAAS,GAAGD,KAAK,CAACvI,IAAtB;;AACA,MAAI8b,YAAY,CAAC2B,GAAb,CAAiBY,YAAjB,KAAkCvC,YAAY,CAAChR,GAAb,CAAiBuT,YAAjB,MAAmC9V,KAAK,CAAC9D,IAAN,CAAW1C,QAAX,EAAzE,EAAgG;AAC5FyG,IAAAA,SAAS,IAAID,KAAK,CAAC9D,IAAN,CAAW1C,QAAX,GAAsB6B,OAAtB,CAA8B,GAA9B,EAAmC,SAAnC,CAAb;AACH;;AACDkY,EAAAA,YAAY,CAAC9Q,GAAb,CAAiBqT,YAAjB,EAA+B9V,KAAK,CAAC9D,IAAN,CAAW1C,QAAX,EAA/B;;AACA,MAAI,CAAC3F,YAAY,CAAC6hB,SAAD,CAAb,IAA4B,CAAC9hB,UAAU,CAAC8hB,SAAD,CAA3C,EAAwD;AACpD,WAAO;AACH9d,MAAAA,IAAI,EAAE5E,IAAI,CAACqiB,KADR;AAEH5d,MAAAA,IAAI,EAAE;AACFG,QAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,QAAAA,KAAK,EAAEqI,KAAK,CAACvI;AAFX,OAFH;AAMH,UAAIwI,SAAS,KAAKD,KAAK,CAACvI,IAApB,IAA4B;AAAEC,QAAAA,KAAK,EAAE;AAAEE,UAAAA,IAAI,EAAE5E,IAAI,CAACmO,IAAb;AAAmBxJ,UAAAA,KAAK,EAAEsI;AAA1B;AAAT,OAAhC,CANG;AAOHuO,MAAAA,YAAY,EAAEqG,mBAAmB,CAAC;AAC9BxH,QAAAA,MAAM,EAAEnR,IADsB;AAE9BA,QAAAA,IAAI,EAAEwZ,SAFwB;AAG9B9B,QAAAA,MAH8B;AAI9Be,QAAAA,SAJ8B;AAK9BjI,QAAAA,IAAI,EAAEmJ,SALwB;AAM9BzI,QAAAA,SAAS,EAAE,CAAC,GAAGA,SAAJ,EAAelR,IAAf,CANmB;AAO9B2X,QAAAA,MAP8B;AAQ9BC,QAAAA,UAR8B;AAS9BC,QAAAA,sBAT8B;AAU9BjW,QAAAA,MAV8B;AAW9B8W,QAAAA,KAAK,EAAEA,KAAK,GAAG,CAXe;AAY9BZ,QAAAA,QAZ8B;AAa9BC,QAAAA,cAb8B;AAc9BC,QAAAA;AAd8B,OAAD,CAAnB,IAeR3X,SAtBH;AAuBHR,MAAAA,SAAS,EAAEM;AAvBR,KAAP;AAyBH;;AACD,SAAO;AACHzE,IAAAA,IAAI,EAAE5E,IAAI,CAACqiB,KADR;AAEH5d,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEqI,KAAK,CAACvI;AAFX,KAFH;AAMH,QAAIwI,SAAS,KAAKD,KAAK,CAACvI,IAApB,IAA4B;AAAEC,MAAAA,KAAK,EAAE;AAAEE,QAAAA,IAAI,EAAE5E,IAAI,CAACmO,IAAb;AAAmBxJ,QAAAA,KAAK,EAAEsI;AAA1B;AAAT,KAAhC,CANG;AAOHlE,IAAAA,SAAS,EAAEM;AAPR,GAAP;AASH;;AACD,SAAS0Y,cAAT,CAAwB/M,KAAxB,EAEG;AAAA,MAF4B+N,MAE5B,uEAFqC;AACpCnB,IAAAA,KAAK,EAAE;AAD6B,GAErC;AACC,QAAM1Y,IAAI,GAAG8L,KAAK,CAACA,KAAK,CAAC5N,MAAN,GAAe,CAAhB,CAAlB;;AACA,MAAIvG,YAAY,CAACqI,IAAD,CAAhB,EAAwB;AACpB,WAAO,KAAP;AACH;;AACD,QAAM8Z,IAAI,GAAGhO,KAAK,CAACzK,MAAN,CAAauX,CAAC,IAAIA,CAAC,CAACrd,IAAF,KAAWyE,IAAI,CAACzE,IAAlC,EAAwC2C,MAArD;AACA,SAAO4b,IAAI,GAAGD,MAAM,CAACnB,KAArB;AACH;;AAED,IAAIqB,UAAJ;;AACA,CAAC,UAAUA,UAAV,EAAsB;AACnBA,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAqB,iBAArB;AACAA,EAAAA,UAAU,CAAC,aAAD,CAAV,GAA4B,wBAA5B;AACAA,EAAAA,UAAU,CAAC,WAAD,CAAV,GAA0B,sBAA1B;AACAA,EAAAA,UAAU,CAAC,gBAAD,CAAV,GAA+B,2BAA/B;AACAA,EAAAA,UAAU,CAAC,aAAD,CAAV,GAA4B,wBAA5B;AACAA,EAAAA,UAAU,CAAC,mBAAD,CAAV,GAAkC,8BAAlC;AACAA,EAAAA,UAAU,CAAC,eAAD,CAAV,GAA8B,0BAA9B;AACAA,EAAAA,UAAU,CAAC,YAAD,CAAV,GAA2B,uBAA3B;AACAA,EAAAA,UAAU,CAAC,gBAAD,CAAV,GAA+B,2BAA/B;AACAA,EAAAA,UAAU,CAAC,aAAD,CAAV,GAA4B,wBAA5B;AACAA,EAAAA,UAAU,CAAC,OAAD,CAAV,GAAsB,kBAAtB;AACAA,EAAAA,UAAU,CAAC,UAAD,CAAV,GAAyB,qBAAzB;AACAA,EAAAA,UAAU,CAAC,cAAD,CAAV,GAA6B,yBAA7B;AACAA,EAAAA,UAAU,CAAC,WAAD,CAAV,GAA0B,sBAA1B;AACAA,EAAAA,UAAU,CAAC,OAAD,CAAV,GAAsB,kBAAtB;AACAA,EAAAA,UAAU,CAAC,iBAAD,CAAV,GAAgC,4BAAhC;AACAA,EAAAA,UAAU,CAAC,cAAD,CAAV,GAA6B,yBAA7B;AACAA,EAAAA,UAAU,CAAC,YAAD,CAAV,GAA2B,uBAA3B;AACAA,EAAAA,UAAU,CAAC,kBAAD,CAAV,GAAiC,6BAAjC;AACAA,EAAAA,UAAU,CAAC,qBAAD,CAAV,GAAoC,gCAApC;AACAA,EAAAA,UAAU,CAAC,yBAAD,CAAV,GAAwC,oCAAxC;AACAA,EAAAA,UAAU,CAAC,iBAAD,CAAV,GAAgC,4BAAhC;AACAA,EAAAA,UAAU,CAAC,oBAAD,CAAV,GAAmC,+BAAnC;AACAA,EAAAA,UAAU,CAAC,UAAD,CAAV,GAAyB,qBAAzB;AACAA,EAAAA,UAAU,CAAC,YAAD,CAAV,GAA2B,uBAA3B;AACH,CA1BD,EA0BGA,UAAU,KAAKA,UAAU,GAAG,EAAlB,CA1Bb;;AA4BA,SAASC,wBAAT,CAAkCC,OAAlC,EAA2Cja,IAA3C,EAAiD;AAC7C,MAAIA,IAAJ,EAAU;AACN,UAAMka,eAAe,GAAGD,OAAO,CAACja,IAAI,CAACzE,IAAN,CAA/B;;AACA,QAAItE,YAAY,CAACijB,eAAD,CAAhB,EAAmC;AAC/B,aAAOA,eAAP;AACH;AACJ;AACJ;;AAED,SAASC,eAAT,CAAyB5e,IAAzB,EAA+ByE,IAA/B,EAAqC;AACjC,MAAIxD,WAAJ;;AACA,MAAIwD,IAAI,KAAK,QAAb,EAAuB;AACnBxD,IAAAA,WAAW,GAAG1D,iBAAd;AACH,GAFD,MAGK,IAAIkH,IAAI,KAAK,WAAb,EAA0B;AAC3BxD,IAAAA,WAAW,GAAGzD,oBAAd;AACH,GAFI,MAGA;AACDyD,IAAAA,WAAW,GAAGxD,sBAAd;AACH;;AACD,SAAO,IAAIwD,WAAJ,CAAgB;AACnBjB,IAAAA,IADmB;AAEnB6H,IAAAA,MAAM,EAAE;AACJgX,MAAAA,KAAK,EAAE;AACHpa,QAAAA,IAAI,EAAEzH;AADH;AADH;AAFW,GAAhB,CAAP;AAQH;;AACD,SAAS8hB,UAAT,CAAoB/a,IAApB,EAA0BU,IAA1B,EAAgC;AAC5B,UAAQV,IAAI,CAAC5D,IAAb;AACI,SAAK5E,IAAI,CAACiO,SAAV;AACI,aAAO,IAAItM,WAAJ,CAAgB4hB,UAAU,CAAC/a,IAAI,CAACU,IAAN,EAAYA,IAAZ,CAA1B,CAAP;;AACJ,SAAKlJ,IAAI,CAACgO,aAAV;AACI,aAAO,IAAItM,cAAJ,CAAmB6hB,UAAU,CAAC/a,IAAI,CAACU,IAAN,EAAYA,IAAZ,CAA7B,CAAP;;AACJ;AACI,UAAIA,IAAI,KAAK,QAAb,EAAuB;AACnB,eAAOma,eAAe,CAAC7a,IAAI,CAAC/D,IAAL,CAAUE,KAAX,EAAkB,QAAlB,CAAtB;AACH;;AACD,aAAO0e,eAAe,CAAC7a,IAAI,CAAC/D,IAAL,CAAUE,KAAX,EAAkB,OAAlB,CAAtB;AATR;AAWH;;AACD,SAAS6e,WAAT,CAAqBta,IAArB,EAA2B;AACvB,MAAI,eAAeA,IAAnB,EAAyB;AACrB,UAAMoD,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf,CADqB,CAErB;;AACA,SAAK,MAAMzH,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,YAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;AACA,aAAOD,KAAK,CAACvI,IAAN,KAAe,OAAtB;AACH;AACJ;;AACD,SAAO,KAAP;AACH;;AACD,SAASgf,iBAAT,CAA2Bva,IAA3B,EAAiC;AAC7B,UAAQA,IAAI,CAACzE,IAAb;AACI,SAAK1C,UAAU,CAAC0C,IAAhB;AACI,aAAO1C,UAAP;;AACJ,SAAKD,YAAY,CAAC2C,IAAlB;AACI,aAAO3C,YAAP;;AACJ,SAAKL,aAAa,CAACgD,IAAnB;AACI,aAAOhD,aAAP;;AACJ,SAAKI,cAAc,CAAC4C,IAApB;AACI,aAAO5C,cAAP;;AACJ,SAAKD,SAAS,CAAC6C,IAAf;AACI,aAAO7C,SAAP;;AACJ;AACI,aAAOsH,IAAP;AAZR;AAcH;;AAED,SAASwa,WAAT,CAAqBC,eAArB,EAAsCrY,UAAtC,EAAkD;AAC9C,QAAMsY,gBAAgB,GAAGzc,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAAzB;;AACA,OAAK,MAAM9W,QAAX,IAAuB4W,eAAvB,EAAwC;AACpCC,IAAAA,gBAAgB,CAAC7W,QAAD,CAAhB,GAA6B4W,eAAe,CAAC5W,QAAD,CAA5C;AACH;;AACD,QAAM+W,UAAU,GAAG3c,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAAnB;;AACA,OAAK,MAAM9W,QAAX,IAAuB6W,gBAAvB,EAAyC;AACrC,UAAMlB,SAAS,GAAGkB,gBAAgB,CAAC7W,QAAD,CAAlC;;AACA,QAAI2V,SAAS,IAAI,IAAb,IAAqB3V,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAzB,EAAoD;AAChD;AACH;;AACD,UAAMC,OAAO,GAAGtB,SAAS,CAACje,IAA1B;;AACA,QAAIuf,OAAO,CAACD,UAAR,CAAmB,IAAnB,CAAJ,EAA8B;AAC1B;AACH;;AACD,QAAID,UAAU,CAACE,OAAD,CAAV,IAAuB,IAA3B,EAAiC;AAC7B,YAAM,IAAI3e,KAAJ,CAAW,8BAA6B2e,OAAQ,EAAhD,CAAN;AACH;;AACDF,IAAAA,UAAU,CAACE,OAAD,CAAV,GAAsBtB,SAAtB;AACH;;AACD,OAAK,MAAM3V,QAAX,IAAuB+W,UAAvB,EAAmC;AAC/BA,IAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuBkX,eAAe,CAACH,UAAU,CAAC/W,QAAD,CAAX,CAAtC;AACH;;AACD,QAAMmX,aAAa,GAAG5Y,UAAU,CAAC/D,GAAX,CAAekD,SAAS,IAAI0Z,eAAe,CAAC1Z,SAAD,CAA3C,CAAtB;AACA,SAAO;AACH0Y,IAAAA,OAAO,EAAEW,UADN;AAEHxY,IAAAA,UAAU,EAAE4Y;AAFT,GAAP;;AAIA,WAASC,eAAT,CAAyB1Z,SAAzB,EAAoC;AAChC,QAAIpK,oBAAoB,CAACoK,SAAD,CAAxB,EAAqC;AACjC,aAAOA,SAAP;AACH;;AACD,UAAM2Z,eAAe,GAAG3Z,SAAS,CAAC4Z,QAAV,EAAxB;AACAD,IAAAA,eAAe,CAAC/a,IAAhB,GAAuBib,UAAU,CAACF,eAAe,CAAC/a,IAAjB,CAAjC;AACA,WAAO,IAAIlH,gBAAJ,CAAqBiiB,eAArB,CAAP;AACH;;AACD,WAASE,UAAT,CAAoBjb,IAApB,EAA0B;AACtB,UAAMkb,WAAW,GAAG,EAApB;;AACA,SAAK,MAAMtO,OAAX,IAAsB5M,IAAtB,EAA4B;AACxB,YAAMJ,GAAG,GAAGI,IAAI,CAAC4M,OAAD,CAAhB;AACA,YAAMuO,cAAc,GAAGC,UAAU,CAACxb,GAAG,CAACC,IAAL,CAAjC;;AACA,UAAIsb,cAAc,IAAI,IAAtB,EAA4B;AACxBvb,QAAAA,GAAG,CAACC,IAAJ,GAAWsb,cAAX;AACAD,QAAAA,WAAW,CAACtO,OAAD,CAAX,GAAuBhN,GAAvB;AACH;AACJ;;AACD,WAAOsb,WAAP;AACH;;AACD,WAASN,eAAT,CAAyB/a,IAAzB,EAA+B;AAC3B,QAAI/I,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpB,YAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,YAAMK,SAAS,GAAG,EACd,GAAG3B,MADW;AAEdzW,QAAAA,MAAM,EAAE,MAAMqY,YAAY,CAAC5B,MAAM,CAACzW,MAAR,CAFZ;AAGdsI,QAAAA,UAAU,EAAE,MAAMgQ,gBAAgB,CAAC7B,MAAM,CAACnO,UAAR;AAHpB,OAAlB;AAKA,aAAO,IAAI5S,iBAAJ,CAAsB0iB,SAAtB,CAAP;AACH,KARD,MASK,IAAIjkB,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5B,YAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,YAAMK,SAAS,GAAG,EACd,GAAG3B,MADW;AAEdzW,QAAAA,MAAM,EAAE,MAAMqY,YAAY,CAAC5B,MAAM,CAACzW,MAAR;AAFZ,OAAlB;;AAIA,UAAI,gBAAgBoY,SAApB,EAA+B;AAC3BA,QAAAA,SAAS,CAAC9P,UAAV,GAAuB,MAAMgQ,gBAAgB,CAAC7B,MAAM,CAACnO,UAAR,CAA7C;AACH;;AACD,aAAO,IAAI3S,oBAAJ,CAAyByiB,SAAzB,CAAP;AACH,KAVI,MAWA,IAAIhkB,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxB,YAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,YAAMK,SAAS,GAAG,EACd,GAAG3B,MADW;AAEd/N,QAAAA,KAAK,EAAE,MAAM4P,gBAAgB,CAAC7B,MAAM,CAAC/N,KAAR;AAFf,OAAlB;AAIA,aAAO,IAAI5S,gBAAJ,CAAqBsiB,SAArB,CAAP;AACH,KAPI,MAQA,IAAI/jB,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9B,YAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,YAAMK,SAAS,GAAG,EACd,GAAG3B,MADW;AAEdzW,QAAAA,MAAM,EAAE,MAAMuY,iBAAiB,CAAC9B,MAAM,CAACzW,MAAR;AAFjB,OAAlB;AAIA,aAAO,IAAIpK,sBAAJ,CAA2BwiB,SAA3B,CAAP;AACH,KAPI,MAQA,IAAI9jB,UAAU,CAACsI,IAAD,CAAd,EAAsB;AACvB,YAAM4b,UAAU,GAAG5b,IAAI,CAACmb,QAAL,EAAnB;AACA,aAAO,IAAIhiB,eAAJ,CAAoByiB,UAApB,CAAP;AACH,KAHI,MAIA,IAAIjkB,YAAY,CAACqI,IAAD,CAAhB,EAAwB;AACzB,UAAI3I,qBAAqB,CAAC2I,IAAD,CAAzB,EAAiC;AAC7B,eAAOA,IAAP;AACH;;AACD,YAAM6b,YAAY,GAAG7b,IAAI,CAACmb,QAAL,EAArB;AACA,aAAO,IAAI/hB,iBAAJ,CAAsByiB,YAAtB,CAAP;AACH;;AACD,UAAM,IAAI1f,KAAJ,CAAW,2BAA0B6D,IAAK,EAA1C,CAAN;AACH;;AACD,WAASyb,YAAT,CAAsBrY,MAAtB,EAA8B;AAC1B,UAAM0Y,aAAa,GAAG,EAAtB;;AACA,SAAK,MAAM/X,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,YAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;AACA,YAAMgY,gBAAgB,GAAGR,UAAU,CAACzX,KAAK,CAAC9D,IAAP,CAAnC;;AACA,UAAI+b,gBAAgB,IAAI,IAApB,IAA4BjY,KAAK,CAAC3D,IAAtC,EAA4C;AACxC2D,QAAAA,KAAK,CAAC9D,IAAN,GAAa+b,gBAAb;AACAjY,QAAAA,KAAK,CAAC3D,IAAN,GAAaib,UAAU,CAACtX,KAAK,CAAC3D,IAAP,CAAvB;AACA2b,QAAAA,aAAa,CAAC/X,SAAD,CAAb,GAA2BD,KAA3B;AACH;AACJ;;AACD,WAAOgY,aAAP;AACH;;AACD,WAASH,iBAAT,CAA2BvY,MAA3B,EAAmC;AAC/B,UAAM0Y,aAAa,GAAG,EAAtB;;AACA,SAAK,MAAM/X,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,YAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;AACA,YAAMgY,gBAAgB,GAAGR,UAAU,CAACzX,KAAK,CAAC9D,IAAP,CAAnC;;AACA,UAAI+b,gBAAgB,IAAI,IAAxB,EAA8B;AAC1BjY,QAAAA,KAAK,CAAC9D,IAAN,GAAa+b,gBAAb;AACAD,QAAAA,aAAa,CAAC/X,SAAD,CAAb,GAA2BD,KAA3B;AACH;AACJ;;AACD,WAAOgY,aAAP;AACH;;AACD,WAASJ,gBAAT,CAA0BM,UAA1B,EAAsC;AAClC,UAAMC,YAAY,GAAG,EAArB;;AACA,SAAK,MAAMzC,SAAX,IAAwBwC,UAAxB,EAAoC;AAChC,YAAME,WAAW,GAAGX,UAAU,CAAC/B,SAAD,CAA9B;;AACA,UAAI0C,WAAW,IAAI,IAAnB,EAAyB;AACrBD,QAAAA,YAAY,CAACld,IAAb,CAAkBmd,WAAlB;AACH;AACJ;;AACD,WAAOD,YAAP;AACH;;AACD,WAASV,UAAT,CAAoBvb,IAApB,EAA0B;AACtB,QAAI9I,UAAU,CAAC8I,IAAD,CAAd,EAAsB;AAClB,YAAMkc,WAAW,GAAGX,UAAU,CAACvb,IAAI,CAAC6E,MAAN,CAA9B;AACA,aAAOqX,WAAW,IAAI,IAAf,GAAsB,IAAIzjB,WAAJ,CAAgByjB,WAAhB,CAAtB,GAAqD,IAA5D;AACH,KAHD,MAIK,IAAIrlB,aAAa,CAACmJ,IAAD,CAAjB,EAAyB;AAC1B,YAAMkc,WAAW,GAAGX,UAAU,CAACvb,IAAI,CAAC6E,MAAN,CAA9B;AACA,aAAOqX,WAAW,IAAI,IAAf,GAAsB,IAAI1jB,cAAJ,CAAmB0jB,WAAnB,CAAtB,GAAwD,IAA/D;AACH,KAHI,MAIA,IAAI7iB,WAAW,CAAC2G,IAAD,CAAf,EAAuB;AACxB,UAAIkc,WAAW,GAAGxB,gBAAgB,CAAC1a,IAAI,CAACzE,IAAN,CAAlC;;AACA,UAAI2gB,WAAW,KAAK7b,SAApB,EAA+B;AAC3B6b,QAAAA,WAAW,GAAG5B,WAAW,CAACta,IAAD,CAAX,GAAoBua,iBAAiB,CAACva,IAAD,CAArC,GAA8C+a,eAAe,CAAC/a,IAAD,CAA3E;AACA4a,QAAAA,UAAU,CAACsB,WAAW,CAAC3gB,IAAb,CAAV,GAA+Bmf,gBAAgB,CAAC1a,IAAI,CAACzE,IAAN,CAAhB,GAA8B2gB,WAA7D;AACH;;AACD,aAAOA,WAAW,IAAI,IAAf,GAAsBtB,UAAU,CAACsB,WAAW,CAAC3gB,IAAb,CAAhC,GAAqD,IAA5D;AACH;;AACD,WAAO,IAAP;AACH;AACJ;;AAED,SAAS4gB,mBAAT,CAA6Bnc,IAA7B,EAAmCvE,KAAnC,EAAgH;AAAA,MAAtE2gB,yBAAsE,uEAA1C,IAA0C;AAAA,MAApCC,2BAAoC,uEAAN,IAAM;;AAC5G,MAAI5gB,KAAK,IAAI,IAAb,EAAmB;AACf,WAAOA,KAAP;AACH;;AACD,QAAM6gB,YAAY,GAAGhjB,eAAe,CAAC0G,IAAD,CAApC;;AACA,MAAIzG,UAAU,CAAC+iB,YAAD,CAAd,EAA8B;AAC1B,WAAOF,yBAAyB,IAAI,IAA7B,GAAoCA,yBAAyB,CAACE,YAAD,EAAe7gB,KAAf,CAA7D,GAAqFA,KAA5F;AACH,GAFD,MAGK,IAAIvE,UAAU,CAAColB,YAAD,CAAd,EAA8B;AAC/B,WAAO7gB,KAAK,CAAC4C,GAAN,CAAWke,UAAD,IAAgBJ,mBAAmB,CAACG,YAAY,CAACzX,MAAd,EAAsB0X,UAAtB,EAAkCH,yBAAlC,EAA6DC,2BAA7D,CAA7C,CAAP;AACH,GAFI,MAGA,IAAI5kB,iBAAiB,CAAC6kB,YAAD,CAArB,EAAqC;AACtC,UAAMlZ,MAAM,GAAGkZ,YAAY,CAAC9Q,SAAb,EAAf;AACA,UAAMlF,QAAQ,GAAG,EAAjB;;AACA,SAAK,MAAMhI,GAAX,IAAkB7C,KAAlB,EAAyB;AACrB,YAAMqI,KAAK,GAAGV,MAAM,CAAC9E,GAAD,CAApB;;AACA,UAAIwF,KAAK,IAAI,IAAb,EAAmB;AACfwC,QAAAA,QAAQ,CAAChI,GAAD,CAAR,GAAgB6d,mBAAmB,CAACrY,KAAK,CAAC9D,IAAP,EAAavE,KAAK,CAAC6C,GAAD,CAAlB,EAAyB8d,yBAAzB,EAAoDC,2BAApD,CAAnC;AACH;AACJ;;AACD,WAAOA,2BAA2B,IAAI,IAA/B,GAAsCA,2BAA2B,CAACC,YAAD,EAAehW,QAAf,CAAjE,GAA4FA,QAAnG;AACH,GArB2G,CAsB5G;;AACH;;AACD,SAASkW,mBAAT,CAA6Bxc,IAA7B,EAAmCvE,KAAnC,EAA0C;AACtC,SAAO0gB,mBAAmB,CAACnc,IAAD,EAAOvE,KAAP,EAAc,CAACmd,CAAD,EAAI1V,CAAJ,KAAU0V,CAAC,CAAC6D,SAAF,CAAYvZ,CAAZ,CAAxB,CAA1B;AACH;;AACD,SAASwZ,eAAT,CAAyB1c,IAAzB,EAA+BvE,KAA/B,EAAsC;AAClC,SAAO0gB,mBAAmB,CAACnc,IAAD,EAAOvE,KAAP,EAAc,CAACmd,CAAD,EAAI1V,CAAJ,KAAU0V,CAAC,CAAC+D,UAAF,CAAazZ,CAAb,CAAxB,CAA1B;AACH;;AACD,SAAS0Z,sBAAT,CAAgC5c,IAAhC,EAAsCvE,KAAtC,EAA6C;AACzC,SAAO0gB,mBAAmB,CAACnc,IAAD,EAAOvE,KAAP,EAAc,CAACmd,CAAD,EAAI1V,CAAJ,KAAU0V,CAAC,CAACiE,YAAF,CAAe3Z,CAAf,EAAkB,EAAlB,CAAxB,CAA1B;AACH;;AAED,SAAS4Z,SAAT,CAAmBlb,MAAnB,EAA8C;AAAA,MAAnBmb,YAAmB,uEAAJ,EAAI;AAC1C,QAAMnC,UAAU,GAAGoC,YAAY,CAACC,SAAS,CAACC,QAAQ,CAACC,gBAAgB,CAACC,aAAa,CAACF,QAAQ,CAACC,gBAAgB,CAACvb,MAAM,CAACwC,UAAP,EAAD,EAAsBxC,MAAtB,EAA8B4a,mBAA9B,CAAjB,EAAqE5a,MAArE,EAA6Emb,YAA7E,EAA2F/c,IAAI,IAAIzG,UAAU,CAACyG,IAAD,CAA7G,CAAT,EAA+H4B,MAA/H,EAAuImb,YAAvI,CAAd,EAAoKnb,MAApK,EAA4K8a,eAA5K,CAAjB,EAA+M9a,MAA/M,EAAuNmb,YAAvN,EAAqO/c,IAAI,IAAI,CAACzG,UAAU,CAACyG,IAAD,CAAxP,CAAT,EAA0Q4B,MAA1Q,EAAkRmb,YAAlR,CAAV,EAA2Snb,MAA3S,EAAmTmb,YAAnT,CAA/B;AACA,QAAMM,kBAAkB,GAAGzb,MAAM,CAACD,aAAP,EAA3B;AACA,QAAMqZ,aAAa,GAAGsC,aAAa,CAACD,kBAAD,EAAqBzb,MAArB,EAA6Bmb,YAA7B,CAAnC;AACA,QAAM;AAAE9C,IAAAA,OAAF;AAAW7X,IAAAA;AAAX,MAA0BoY,WAAW,CAACI,UAAD,EAAaI,aAAb,CAA3C;AACA,SAAO,IAAIxhB,aAAJ,CAAkB,EACrB,GAAGoI,MAAM,CAACuZ,QAAP,EADkB;AAErBoC,IAAAA,KAAK,EAAEvD,wBAAwB,CAACC,OAAD,EAAUD,wBAAwB,CAACY,UAAD,EAAahZ,MAAM,CAACyG,YAAP,EAAb,CAAlC,CAFV;AAGrBmV,IAAAA,QAAQ,EAAExD,wBAAwB,CAACC,OAAD,EAAUD,wBAAwB,CAACY,UAAD,EAAahZ,MAAM,CAAC2G,eAAP,EAAb,CAAlC,CAHb;AAIrBkV,IAAAA,YAAY,EAAEzD,wBAAwB,CAACC,OAAD,EAAUD,wBAAwB,CAACY,UAAD,EAAahZ,MAAM,CAAC6G,mBAAP,EAAb,CAAlC,CAJjB;AAKrBqD,IAAAA,KAAK,EAAE7N,MAAM,CAACgF,MAAP,CAAcgX,OAAd,CALc;AAMrB7X,IAAAA;AANqB,GAAlB,CAAP;AAQH;;AACD,SAAS8a,QAAT,CAAkBzC,eAAlB,EAAmC7Y,MAAnC,EAA2Cmb,YAA3C,EAA8E;AAAA,MAArBW,MAAqB,uEAAZ,MAAM,IAAM;AAC1E,QAAM9C,UAAU,GAAG,EAAnB;;AACA,OAAK,MAAM/W,QAAX,IAAuB4W,eAAvB,EAAwC;AACpC,QAAI,CAAC5W,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAL,EAAgC;AAC5B,YAAM8C,YAAY,GAAGlD,eAAe,CAAC5W,QAAD,CAApC;;AACA,UAAI8Z,YAAY,IAAI,IAAhB,IAAwB,CAACD,MAAM,CAACC,YAAD,CAAnC,EAAmD;AAC/C/C,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB8Z,YAAvB;AACA;AACH;;AACD,YAAMC,UAAU,GAAGC,aAAa,CAACjc,MAAD,EAASmb,YAAT,EAAuBlZ,QAAvB,CAAhC;;AACA,UAAI+Z,UAAU,IAAI,IAAlB,EAAwB;AACpBhD,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB8Z,YAAvB;AACA;AACH;;AACD,YAAMG,YAAY,GAAGF,UAAU,CAACD,YAAD,EAAe/b,MAAf,CAA/B;;AACA,UAAIkc,YAAY,KAAKzd,SAArB,EAAgC;AAC5Bua,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB8Z,YAAvB;AACA;AACH;;AACD/C,MAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuBia,YAAvB;AACH;AACJ;;AACD,SAAOlD,UAAP;AACH;;AACD,SAASwC,aAAT,CAAuB3C,eAAvB,EAAwC7Y,MAAxC,EAAgDmb,YAAhD,EAA8D;AAC1D,QAAMgB,eAAe,GAAGC,kBAAkB,CAACjB,YAAD,CAA1C;;AACA,MAAI,CAACgB,eAAL,EAAsB;AAClB,WAAOtD,eAAP;AACH;;AACD,SAAOyC,QAAQ,CAACzC,eAAD,EAAkB7Y,MAAlB,EAA0B;AACrC,KAACmY,UAAU,CAACkE,SAAZ,GAAwBje,IAAI,IAAI;AAC5B,YAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,YAAM+C,0BAA0B,GAAGrE,MAAM,CAAC5W,MAA1C;AACA,YAAMkb,qBAAqB,GAAG,EAA9B;;AACA,WAAK,MAAMC,aAAX,IAA4BF,0BAA5B,EAAwD;AACpD,cAAMG,uBAAuB,GAAGH,0BAA0B,CAACE,aAAD,CAA1D;AACA,cAAME,eAAe,GAAGP,eAAe,CAACM,uBAAD,EAA0Bre,IAAI,CAACzE,IAA/B,EAAqCqG,MAArC,EAA6Cwc,aAA7C,CAAvC;;AACA,YAAIE,eAAe,KAAKje,SAAxB,EAAmC;AAC/B8d,UAAAA,qBAAqB,CAACC,aAAD,CAArB,GAAuCC,uBAAvC;AACH,SAFD,MAGK,IAAI9jB,KAAK,CAACC,OAAN,CAAc8jB,eAAd,CAAJ,EAAoC;AACrC,gBAAM,CAACC,gBAAD,EAAmBC,kBAAnB,IAAyCF,eAA/C;AACAH,UAAAA,qBAAqB,CAACI,gBAAD,CAArB,GACIC,kBAAkB,KAAKne,SAAvB,GAAmCge,uBAAnC,GAA6DG,kBADjE;AAEH,SAJI,MAKA,IAAIF,eAAe,KAAK,IAAxB,EAA8B;AAC/BH,UAAAA,qBAAqB,CAACC,aAAD,CAArB,GAAuCE,eAAvC;AACH;AACJ;;AACD,aAAOG,eAAe,CAAC,IAAItlB,eAAJ,CAAoB,EACvC,GAAG0gB,MADoC;AAEvC5W,QAAAA,MAAM,EAAEkb;AAF+B,OAApB,CAAD,CAAtB;AAIH;AAxBoC,GAA1B,EAyBZne,IAAI,IAAItI,UAAU,CAACsI,IAAD,CAzBN,CAAf;AA0BH;;AACD,SAASmd,gBAAT,CAA0B1C,eAA1B,EAA2C7Y,MAA3C,EAAmDmE,EAAnD,EAAuD;AACnD,QAAM6U,UAAU,GAAGoC,YAAY,CAACvC,eAAD,EAAkB7Y,MAAlB,EAA0B;AACrD,KAACmY,UAAU,CAAC9M,QAAZ,GAAuByR,cAAc,IAAI;AACrC,UAAIA,cAAc,CAACxe,YAAf,KAAgCG,SAApC,EAA+C;AAC3C,eAAOqe,cAAP;AACH;;AACD,YAAMZ,YAAY,GAAGa,UAAU,CAAClE,eAAD,EAAkBiE,cAAc,CAAC1e,IAAjC,CAA/B;;AACA,UAAI8d,YAAY,IAAI,IAApB,EAA0B;AACtB,eAAO,EACH,GAAGY,cADA;AAEHxe,UAAAA,YAAY,EAAE6F,EAAE,CAAC+X,YAAD,EAAeY,cAAc,CAACxe,YAA9B;AAFb,SAAP;AAIH;AACJ;AAZoD,GAA1B,CAA/B;AAcA,SAAO+c,SAAS,CAACrC,UAAD,EAAahZ,MAAb,EAAqB;AACjC,KAACmY,UAAU,CAAC6E,kBAAZ,GAAiCC,gBAAgB,IAAI;AACjD,UAAIA,gBAAgB,CAAC3e,YAAjB,KAAkCG,SAAtC,EAAiD;AAC7C,eAAOwe,gBAAP;AACH;;AACD,YAAMf,YAAY,GAAGa,UAAU,CAAC/D,UAAD,EAAaiE,gBAAgB,CAAC7e,IAA9B,CAA/B;;AACA,UAAI8d,YAAY,IAAI,IAApB,EAA0B;AACtB,eAAO,EACH,GAAGe,gBADA;AAEH3e,UAAAA,YAAY,EAAE6F,EAAE,CAAC+X,YAAD,EAAee,gBAAgB,CAAC3e,YAAhC;AAFb,SAAP;AAIH;AACJ;AAZgC,GAArB,CAAhB;AAcH;;AACD,SAASye,UAAT,CAAoB/D,UAApB,EAAgC5a,IAAhC,EAAsC;AAClC,MAAI9I,UAAU,CAAC8I,IAAD,CAAd,EAAsB;AAClB,UAAM8e,OAAO,GAAGH,UAAU,CAAC/D,UAAD,EAAa5a,IAAI,CAAC6E,MAAlB,CAA1B;AACA,WAAOia,OAAO,IAAI,IAAX,GAAkB,IAAIrmB,WAAJ,CAAgBqmB,OAAhB,CAAlB,GAA6C,IAApD;AACH,GAHD,MAIK,IAAIjoB,aAAa,CAACmJ,IAAD,CAAjB,EAAyB;AAC1B,UAAM8e,OAAO,GAAGH,UAAU,CAAC/D,UAAD,EAAa5a,IAAI,CAAC6E,MAAlB,CAA1B;AACA,WAAOia,OAAO,IAAI,IAAX,GAAkB,IAAItmB,cAAJ,CAAmBsmB,OAAnB,CAAlB,GAAgD,IAAvD;AACH,GAHI,MAIA,IAAIzlB,WAAW,CAAC2G,IAAD,CAAf,EAAuB;AACxB,UAAM8e,OAAO,GAAGlE,UAAU,CAAC5a,IAAI,CAACzE,IAAN,CAA1B;AACA,WAAOujB,OAAO,IAAI,IAAX,GAAkBA,OAAlB,GAA4B,IAAnC;AACH;;AACD,SAAO,IAAP;AACH;;AACD,SAAS7B,SAAT,CAAmBxC,eAAnB,EAAoC7Y,MAApC,EAA4Cmb,YAA5C,EAA0D;AACtD,QAAMnC,UAAU,GAAG,EAAnB;;AACA,OAAK,MAAM/W,QAAX,IAAuB4W,eAAvB,EAAwC;AACpC,QAAI,CAAC5W,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAL,EAAgC;AAC5B,YAAM8C,YAAY,GAAGlD,eAAe,CAAC5W,QAAD,CAApC;;AACA,UAAI,CAAC5M,YAAY,CAAC0mB,YAAD,CAAb,IAA+B,CAACpmB,eAAe,CAAComB,YAAD,CAA/C,IAAiE,CAAClmB,iBAAiB,CAACkmB,YAAD,CAAvF,EAAuG;AACnG/C,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB8Z,YAAvB;AACA;AACH;;AACD,YAAMoB,WAAW,GAAGC,cAAc,CAACpd,MAAD,EAASmb,YAAT,EAAuBlZ,QAAvB,CAAlC;;AACA,UAAIkb,WAAW,IAAI,IAAnB,EAAyB;AACrBnE,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB8Z,YAAvB;AACA;AACH;;AACD,YAAM9D,MAAM,GAAG8D,YAAY,CAACxC,QAAb,EAAf;AACA,YAAM8D,sBAAsB,GAAGpF,MAAM,CAACzW,MAAtC;AACA,YAAM8b,iBAAiB,GAAG,EAA1B;;AACA,WAAK,MAAMnb,SAAX,IAAwBkb,sBAAxB,EAAgD;AAC5C,cAAME,mBAAmB,GAAGF,sBAAsB,CAAClb,SAAD,CAAlD;AACA,cAAMqb,WAAW,GAAGL,WAAW,CAACI,mBAAD,EAAsBpb,SAAtB,EAAiCF,QAAjC,EAA2CjC,MAA3C,CAA/B;;AACA,YAAIwd,WAAW,KAAK/e,SAApB,EAA+B;AAC3B6e,UAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+Bob,mBAA/B;AACH,SAFD,MAGK,IAAI5kB,KAAK,CAACC,OAAN,CAAc4kB,WAAd,CAAJ,EAAgC;AACjC,gBAAM,CAACC,YAAD,EAAeC,cAAf,IAAiCF,WAAvC;;AACA,cAAIE,cAAc,CAACrd,OAAf,IAA0B,IAA9B,EAAoC;AAChCqd,YAAAA,cAAc,CAACrd,OAAf,GAAyB,EACrB,GAAGqd,cAAc,CAACrd,OADG;AAErB1G,cAAAA,IAAI,EAAE,EACF,GAAG+jB,cAAc,CAACrd,OAAf,CAAuB1G,IADxB;AAEFE,gBAAAA,KAAK,EAAE4jB;AAFL;AAFe,aAAzB;AAOH;;AACDH,UAAAA,iBAAiB,CAACG,YAAD,CAAjB,GAAkCC,cAAc,KAAKjf,SAAnB,GAA+B8e,mBAA/B,GAAqDG,cAAvF;AACH,SAZI,MAaA,IAAIF,WAAW,KAAK,IAApB,EAA0B;AAC3BF,UAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+Bqb,WAA/B;AACH;AACJ;;AACD,UAAInoB,YAAY,CAAC0mB,YAAD,CAAhB,EAAgC;AAC5B/C,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB4a,eAAe,CAAC,IAAI3lB,iBAAJ,CAAsB,EACzD,GAAG+gB,MADsD;AAEzDzW,UAAAA,MAAM,EAAE8b;AAFiD,SAAtB,CAAD,CAAtC;AAIH,OALD,MAMK,IAAI3nB,eAAe,CAAComB,YAAD,CAAnB,EAAmC;AACpC/C,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB4a,eAAe,CAAC,IAAI1lB,oBAAJ,CAAyB,EAC5D,GAAG8gB,MADyD;AAE5DzW,UAAAA,MAAM,EAAE8b;AAFoD,SAAzB,CAAD,CAAtC;AAIH,OALI,MAMA;AACDtE,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB4a,eAAe,CAAC,IAAIzlB,sBAAJ,CAA2B,EAC9D,GAAG6gB,MAD2D;AAE9DzW,UAAAA,MAAM,EAAE8b;AAFsD,SAA3B,CAAD,CAAtC;AAIH;AACJ;AACJ;;AACD,SAAOtE,UAAP;AACH;;AACD,SAASoC,YAAT,CAAsBvC,eAAtB,EAAuC7Y,MAAvC,EAA+Cmb,YAA/C,EAA6D;AACzD,QAAMnC,UAAU,GAAG,EAAnB;;AACA,OAAK,MAAM/W,QAAX,IAAuB4W,eAAvB,EAAwC;AACpC,QAAI,CAAC5W,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAL,EAAgC;AAC5B,YAAM8C,YAAY,GAAGlD,eAAe,CAAC5W,QAAD,CAApC;;AACA,UAAI,CAAC5M,YAAY,CAAC0mB,YAAD,CAAb,IAA+B,CAACpmB,eAAe,CAAComB,YAAD,CAAnD,EAAmE;AAC/D/C,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB8Z,YAAvB;AACA;AACH;;AACD,YAAM4B,cAAc,GAAGC,iBAAiB,CAACzC,YAAD,CAAxC;;AACA,UAAIwC,cAAc,IAAI,IAAtB,EAA4B;AACxB3E,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB8Z,YAAvB;AACA;AACH;;AACD,YAAM9D,MAAM,GAAG8D,YAAY,CAACxC,QAAb,EAAf;AACA,YAAM8D,sBAAsB,GAAGpF,MAAM,CAACzW,MAAtC;AACA,YAAM8b,iBAAiB,GAAG,EAA1B;;AACA,WAAK,MAAMnb,SAAX,IAAwBkb,sBAAxB,EAAgD;AAC5C,cAAME,mBAAmB,GAAGF,sBAAsB,CAAClb,SAAD,CAAlD;AACA,cAAM0b,yBAAyB,GAAGN,mBAAmB,CAAChf,IAAtD;;AACA,YAAIsf,yBAAyB,IAAI,IAAjC,EAAuC;AACnCP,UAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+Bob,mBAA/B;AACA;AACH;;AACD,cAAMO,aAAa,GAAGzhB,MAAM,CAACsS,IAAP,CAAYkP,yBAAZ,CAAtB;;AACA,YAAI,CAACC,aAAa,CAACxhB,MAAnB,EAA2B;AACvBghB,UAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+Bob,mBAA/B;AACA;AACH;;AACD,cAAMQ,oBAAoB,GAAG,EAA7B;;AACA,aAAK,MAAMjG,YAAX,IAA2BgG,aAA3B,EAA0C;AACtC,gBAAME,sBAAsB,GAAGH,yBAAyB,CAAC/F,YAAD,CAAxD;AACA,gBAAMmG,cAAc,GAAGN,cAAc,CAACK,sBAAD,EAAyB7b,SAAzB,EAAoCF,QAApC,EAA8CjC,MAA9C,CAArC;;AACA,cAAIie,cAAc,KAAKxf,SAAvB,EAAkC;AAC9Bsf,YAAAA,oBAAoB,CAACjG,YAAD,CAApB,GAAqCkG,sBAArC;AACH,WAFD,MAGK,IAAIrlB,KAAK,CAACC,OAAN,CAAcqlB,cAAd,CAAJ,EAAmC;AACpC,kBAAM,CAACC,eAAD,EAAkBC,iBAAlB,IAAuCF,cAA7C;AACAF,YAAAA,oBAAoB,CAACG,eAAD,CAApB,GAAwCC,iBAAxC;AACH,WAHI,MAIA,IAAIF,cAAc,KAAK,IAAvB,EAA6B;AAC9BF,YAAAA,oBAAoB,CAACjG,YAAD,CAApB,GAAqCmG,cAArC;AACH;AACJ;;AACDX,QAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+B,EAC3B,GAAGob,mBADwB;AAE3Bhf,UAAAA,IAAI,EAAEwf;AAFqB,SAA/B;AAIH;;AACD,UAAI1oB,YAAY,CAAC0mB,YAAD,CAAhB,EAAgC;AAC5B/C,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB,IAAI/K,iBAAJ,CAAsB,EACzC,GAAG+gB,MADsC;AAEzCzW,UAAAA,MAAM,EAAE8b;AAFiC,SAAtB,CAAvB;AAIH,OALD,MAMK,IAAI3nB,eAAe,CAAComB,YAAD,CAAnB,EAAmC;AACpC/C,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB,IAAI9K,oBAAJ,CAAyB,EAC5C,GAAG8gB,MADyC;AAE5CzW,UAAAA,MAAM,EAAE8b;AAFoC,SAAzB,CAAvB;AAIH,OALI,MAMA;AACDtE,QAAAA,UAAU,CAAC/W,QAAD,CAAV,GAAuB,IAAI7K,sBAAJ,CAA2B,EAC9C,GAAG6gB,MAD2C;AAE9CzW,UAAAA,MAAM,EAAE8b;AAFsC,SAA3B,CAAvB;AAIH;AACJ;AACJ;;AACD,SAAOtE,UAAP;AACH;;AACD,SAAS0C,aAAT,CAAuBD,kBAAvB,EAA2Czb,MAA3C,EAAmDmb,YAAnD,EAAiE;AAC7D,QAAMiD,eAAe,GAAGC,kBAAkB,CAAClD,YAAD,CAA1C;;AACA,MAAIiD,eAAe,IAAI,IAAvB,EAA6B;AACzB,WAAO3C,kBAAkB,CAAChO,KAAnB,EAAP;AACH;;AACD,QAAM2L,aAAa,GAAG,EAAtB;;AACA,OAAK,MAAMzZ,SAAX,IAAwB8b,kBAAxB,EAA4C;AACxC,UAAM6C,eAAe,GAAGF,eAAe,CAACze,SAAD,EAAYK,MAAZ,CAAvC;;AACA,QAAIse,eAAe,KAAK7f,SAAxB,EAAmC;AAC/B2a,MAAAA,aAAa,CAACjc,IAAd,CAAmBwC,SAAnB;AACH,KAFD,MAGK,IAAI2e,eAAe,KAAK,IAAxB,EAA8B;AAC/BlF,MAAAA,aAAa,CAACjc,IAAd,CAAmBmhB,eAAnB;AACH;AACJ;;AACD,SAAOlF,aAAP;AACH;;AACD,SAASmF,iBAAT,CAA2Bve,MAA3B,EAAmCiC,QAAnC,EAA6C;AACzC,MAAIxI,EAAJ,EAAQC,EAAR,EAAYgP,EAAZ;;AACA,QAAMtK,IAAI,GAAG4B,MAAM,CAACwe,OAAP,CAAevc,QAAf,CAAb;AACA,QAAMwc,UAAU,GAAG,CAACtG,UAAU,CAACuG,IAAZ,CAAnB;;AACA,MAAIrpB,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpBqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACwG,cAA3B,EAA2CxG,UAAU,CAACyG,WAAtD;;AACA,QAAI3c,QAAQ,MAAM,CAACxI,EAAE,GAAGuG,MAAM,CAACyG,YAAP,EAAN,MAAiC,IAAjC,IAAyChN,EAAE,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,EAAE,CAACE,IAA3E,CAAZ,EAA8F;AAC1F8kB,MAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAAC0G,WAA3B,EAAwC1G,UAAU,CAAC2G,KAAnD;AACH,KAFD,MAGK,IAAI7c,QAAQ,MAAM,CAACvI,EAAE,GAAGsG,MAAM,CAAC2G,eAAP,EAAN,MAAoC,IAApC,IAA4CjN,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAACC,IAA9E,CAAZ,EAAiG;AAClG8kB,MAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAAC0G,WAA3B,EAAwC1G,UAAU,CAAC4G,QAAnD;AACH,KAFI,MAGA,IAAI9c,QAAQ,MAAM,CAACyG,EAAE,GAAG1I,MAAM,CAAC6G,mBAAP,EAAN,MAAwC,IAAxC,IAAgD6B,EAAE,KAAK,KAAK,CAA5D,GAAgE,KAAK,CAArE,GAAyEA,EAAE,CAAC/O,IAAlF,CAAZ,EAAqG;AACtG8kB,MAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAAC0G,WAA3B,EAAwC1G,UAAU,CAAC6G,YAAnD;AACH;AACJ,GAXD,MAYK,IAAInpB,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9BqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAAC8G,iBAA3B;AACH,GAFI,MAGA,IAAItpB,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5BqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACwG,cAA3B,EAA2CxG,UAAU,CAAC+G,aAAtD,EAAqE/G,UAAU,CAACgH,cAAhF;AACH,GAFI,MAGA,IAAIvpB,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxBqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACwG,cAA3B,EAA2CxG,UAAU,CAAC+G,aAAtD,EAAqE/G,UAAU,CAACiH,UAAhF;AACH,GAFI,MAGA,IAAItpB,UAAU,CAACsI,IAAD,CAAd,EAAsB;AACvBqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACkE,SAA3B;AACH,GAFI,MAGA,IAAItmB,YAAY,CAACqI,IAAD,CAAhB,EAAwB;AACzBqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACkH,WAA3B;AACH;;AACD,SAAOZ,UAAP;AACH;;AACD,SAASxC,aAAT,CAAuBjc,MAAvB,EAA+Bmb,YAA/B,EAA6ClZ,QAA7C,EAAuD;AACnD,QAAMwc,UAAU,GAAGF,iBAAiB,CAACve,MAAD,EAASiC,QAAT,CAApC;AACA,MAAI+Z,UAAJ;AACA,QAAMrgB,KAAK,GAAG,CAAC,GAAG8iB,UAAJ,CAAd;;AACA,SAAO,CAACzC,UAAD,IAAergB,KAAK,CAACW,MAAN,GAAe,CAArC,EAAwC;AACpC;AACA,UAAM6X,IAAI,GAAGxY,KAAK,CAACiZ,GAAN,EAAb;AACAoH,IAAAA,UAAU,GAAGb,YAAY,CAAChH,IAAD,CAAzB;AACH;;AACD,SAAO6H,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkC,IAAzC;AACH;;AACD,SAASsD,kBAAT,CAA4Btf,MAA5B,EAAoCiC,QAApC,EAA8C;AAC1C,MAAIxI,EAAJ,EAAQC,EAAR,EAAYgP,EAAZ;;AACA,QAAMtK,IAAI,GAAG4B,MAAM,CAACwe,OAAP,CAAevc,QAAf,CAAb;AACA,QAAMwc,UAAU,GAAG,CAACtG,UAAU,CAACZ,KAAZ,CAAnB;;AACA,MAAIliB,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpBqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACoH,eAA3B,EAA4CpH,UAAU,CAACtU,YAAvD;;AACA,QAAI5B,QAAQ,MAAM,CAACxI,EAAE,GAAGuG,MAAM,CAACyG,YAAP,EAAN,MAAiC,IAAjC,IAAyChN,EAAE,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,EAAE,CAACE,IAA3E,CAAZ,EAA8F;AAC1F8kB,MAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACqH,UAA3B,EAAuCrH,UAAU,CAACsH,gBAAlD;AACH,KAFD,MAGK,IAAIxd,QAAQ,MAAM,CAACvI,EAAE,GAAGsG,MAAM,CAAC2G,eAAP,EAAN,MAAoC,IAApC,IAA4CjN,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAACC,IAA9E,CAAZ,EAAiG;AAClG8kB,MAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACqH,UAA3B,EAAuCrH,UAAU,CAACuH,mBAAlD;AACH,KAFI,MAGA,IAAIzd,QAAQ,MAAM,CAACyG,EAAE,GAAG1I,MAAM,CAAC6G,mBAAP,EAAN,MAAwC,IAAxC,IAAgD6B,EAAE,KAAK,KAAK,CAA5D,GAAgE,KAAK,CAArE,GAAyEA,EAAE,CAAC/O,IAAlF,CAAZ,EAAqG;AACtG8kB,MAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACqH,UAA3B,EAAuCrH,UAAU,CAACwH,uBAAlD;AACH;AACJ,GAXD,MAYK,IAAIhqB,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5BqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAACoH,eAA3B,EAA4CpH,UAAU,CAACyH,eAAvD;AACH,GAFI,MAGA,IAAI/pB,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9BqgB,IAAAA,UAAU,CAACthB,IAAX,CAAgBgb,UAAU,CAAC6E,kBAA3B;AACH;;AACD,SAAOyB,UAAP;AACH;;AACD,SAASrB,cAAT,CAAwBpd,MAAxB,EAAgCmb,YAAhC,EAA8ClZ,QAA9C,EAAwD;AACpD,QAAMwc,UAAU,GAAGa,kBAAkB,CAACtf,MAAD,EAASiC,QAAT,CAArC;AACA,MAAIkb,WAAJ;AACA,QAAMxhB,KAAK,GAAG,CAAC,GAAG8iB,UAAJ,CAAd;;AACA,SAAO,CAACtB,WAAD,IAAgBxhB,KAAK,CAACW,MAAN,GAAe,CAAtC,EAAyC;AACrC;AACA,UAAM6X,IAAI,GAAGxY,KAAK,CAACiZ,GAAN,EAAb,CAFqC,CAGrC;;AACAuI,IAAAA,WAAW,GAAGhC,YAAY,CAAChH,IAAD,CAA1B;AACH;;AACD,SAAOgJ,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAK,KAAK,CAA7C,GAAiDA,WAAjD,GAA+D,IAAtE;AACH;;AACD,SAASS,iBAAT,CAA2BzC,YAA3B,EAAyC;AACrC,QAAMwC,cAAc,GAAGxC,YAAY,CAAChD,UAAU,CAAC9M,QAAZ,CAAnC;AACA,SAAOsS,cAAc,IAAI,IAAlB,GAAyBA,cAAzB,GAA0C,IAAjD;AACH;;AACD,SAASU,kBAAT,CAA4BlD,YAA5B,EAA0C;AACtC,QAAMiD,eAAe,GAAGjD,YAAY,CAAChD,UAAU,CAAC7M,SAAZ,CAApC;AACA,SAAO8S,eAAe,IAAI,IAAnB,GAA0BA,eAA1B,GAA4C,IAAnD;AACH;;AACD,SAAShC,kBAAT,CAA4BjB,YAA5B,EAA0C;AACtC,QAAMgB,eAAe,GAAGhB,YAAY,CAAChD,UAAU,CAAC0H,UAAZ,CAApC;AACA,SAAO1D,eAAe,IAAI,IAAnB,GAA0BA,eAA1B,GAA4C,IAAnD;AACH;;AACD,SAASU,eAAT,CAAyBze,IAAzB,EAA+B;AAC3B,MAAI/I,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpB,UAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;;AACA,QAAItB,MAAM,CAAC5X,OAAP,IAAkB,IAAtB,EAA4B;AACxB,YAAMmB,MAAM,GAAG,EAAf;;AACA,WAAK,MAAMW,SAAX,IAAwB8V,MAAM,CAACzW,MAA/B,EAAuC;AACnC,cAAMse,WAAW,GAAG7H,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAApB;;AACA,YAAI2d,WAAW,CAACzf,OAAZ,IAAuB,IAA3B,EAAiC;AAC7BmB,UAAAA,MAAM,CAACrE,IAAP,CAAY2iB,WAAW,CAACzf,OAAxB;AACH;AACJ;;AACD4X,MAAAA,MAAM,CAAC5X,OAAP,GAAiB,EACb,GAAG4X,MAAM,CAAC5X,OADG;AAEbvG,QAAAA,IAAI,EAAE5E,IAAI,CAACyU,sBAFE;AAGbnI,QAAAA;AAHa,OAAjB;AAKH;;AACD,QAAIyW,MAAM,CAAC3X,iBAAP,IAA4B,IAAhC,EAAsC;AAClC2X,MAAAA,MAAM,CAAC3X,iBAAP,GAA2B2X,MAAM,CAAC3X,iBAAP,CAAyB7D,GAAzB,CAA6BiB,IAAI,KAAK,EAC7D,GAAGA,IAD0D;AAE7D5D,QAAAA,IAAI,EAAE5E,IAAI,CAAC6qB,qBAFkD;AAG7Dve,QAAAA,MAAM,EAAE/C;AAHqD,OAAL,CAAjC,CAA3B;AAKH;;AACD,WAAO,IAAIvH,iBAAJ,CAAsB+gB,MAAtB,CAAP;AACH,GAxBD,MAyBK,IAAItiB,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5B,UAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;;AACA,QAAItB,MAAM,CAAC5X,OAAP,IAAkB,IAAtB,EAA4B;AACxB,YAAMmB,MAAM,GAAG,EAAf;;AACA,WAAK,MAAMW,SAAX,IAAwB8V,MAAM,CAACzW,MAA/B,EAAuC;AACnC,cAAMse,WAAW,GAAG7H,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAApB;;AACA,YAAI2d,WAAW,CAACzf,OAAZ,IAAuB,IAA3B,EAAiC;AAC7BmB,UAAAA,MAAM,CAACrE,IAAP,CAAY2iB,WAAW,CAACzf,OAAxB;AACH;AACJ;;AACD4X,MAAAA,MAAM,CAAC5X,OAAP,GAAiB,EACb,GAAG4X,MAAM,CAAC5X,OADG;AAEbvG,QAAAA,IAAI,EAAE5E,IAAI,CAAC8U,yBAFE;AAGbxI,QAAAA;AAHa,OAAjB;AAKH;;AACD,QAAIyW,MAAM,CAAC3X,iBAAP,IAA4B,IAAhC,EAAsC;AAClC2X,MAAAA,MAAM,CAAC3X,iBAAP,GAA2B2X,MAAM,CAAC3X,iBAAP,CAAyB7D,GAAzB,CAA6BiB,IAAI,KAAK,EAC7D,GAAGA,IAD0D;AAE7D5D,QAAAA,IAAI,EAAE5E,IAAI,CAAC8qB,wBAFkD;AAG7Dxe,QAAAA,MAAM,EAAE/C;AAHqD,OAAL,CAAjC,CAA3B;AAKH;;AACD,WAAO,IAAItH,oBAAJ,CAAyB8gB,MAAzB,CAAP;AACH,GAxBI,MAyBA,IAAIpiB,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9B,UAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;;AACA,QAAItB,MAAM,CAAC5X,OAAP,IAAkB,IAAtB,EAA4B;AACxB,YAAMmB,MAAM,GAAG,EAAf;;AACA,WAAK,MAAMW,SAAX,IAAwB8V,MAAM,CAACzW,MAA/B,EAAuC;AACnC,cAAMse,WAAW,GAAG7H,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAApB;;AACA,YAAI2d,WAAW,CAACzf,OAAZ,IAAuB,IAA3B,EAAiC;AAC7BmB,UAAAA,MAAM,CAACrE,IAAP,CAAY2iB,WAAW,CAACzf,OAAxB;AACH;AACJ;;AACD4X,MAAAA,MAAM,CAAC5X,OAAP,GAAiB,EACb,GAAG4X,MAAM,CAAC5X,OADG;AAEbvG,QAAAA,IAAI,EAAE5E,IAAI,CAACkV,4BAFE;AAGb5I,QAAAA;AAHa,OAAjB;AAKH;;AACD,QAAIyW,MAAM,CAAC3X,iBAAP,IAA4B,IAAhC,EAAsC;AAClC2X,MAAAA,MAAM,CAAC3X,iBAAP,GAA2B2X,MAAM,CAAC3X,iBAAP,CAAyB7D,GAAzB,CAA6BiB,IAAI,KAAK,EAC7D,GAAGA,IAD0D;AAE7D5D,QAAAA,IAAI,EAAE5E,IAAI,CAAC+qB,2BAFkD;AAG7Dze,QAAAA,MAAM,EAAE/C;AAHqD,OAAL,CAAjC,CAA3B;AAKH;;AACD,WAAO,IAAIrH,sBAAJ,CAA2B6gB,MAA3B,CAAP;AACH,GAxBI,MAyBA,IAAIniB,UAAU,CAACsI,IAAD,CAAd,EAAsB;AACvB,UAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;;AACA,QAAItB,MAAM,CAAC5X,OAAP,IAAkB,IAAtB,EAA4B;AACxB,YAAMgB,MAAM,GAAG,EAAf;;AACA,WAAK,MAAM6e,OAAX,IAAsBjI,MAAM,CAAC5W,MAA7B,EAAqC;AACjC,cAAM8e,eAAe,GAAGlI,MAAM,CAAC5W,MAAP,CAAc6e,OAAd,CAAxB;;AACA,YAAIC,eAAe,CAAC9f,OAAhB,IAA2B,IAA/B,EAAqC;AACjCgB,UAAAA,MAAM,CAAClE,IAAP,CAAYgjB,eAAe,CAAC9f,OAA5B;AACH;AACJ;;AACD4X,MAAAA,MAAM,CAAC5X,OAAP,GAAiB,EACb,GAAG4X,MAAM,CAAC5X,OADG;AAEbgB,QAAAA;AAFa,OAAjB;AAIH;;AACD,QAAI4W,MAAM,CAAC3X,iBAAP,IAA4B,IAAhC,EAAsC;AAClC2X,MAAAA,MAAM,CAAC3X,iBAAP,GAA2B2X,MAAM,CAAC3X,iBAAP,CAAyB7D,GAAzB,CAA6BiB,IAAI,KAAK,EAC7D,GAAGA,IAD0D;AAE7D2D,QAAAA,MAAM,EAAE5C;AAFqD,OAAL,CAAjC,CAA3B;AAIH;;AACD,WAAO,IAAIlH,eAAJ,CAAoB0gB,MAApB,CAAP;AACH,GAtBI,MAuBA;AACD,WAAO7Z,IAAP;AACH;AACJ;;AAED,SAASgiB,YAAT,SAAmP;AAAA,MAA7N;AAAEpgB,IAAAA,MAAF;AAAUqgB,IAAAA,UAAU,GAAG,MAAM,IAA7B;AAAmCC,IAAAA,WAAW,GAAG7hB,SAAjD;AAA4D8hB,IAAAA,eAAe,GAAG9hB,SAA9E;AAAyF+hB,IAAAA,iBAAiB,GAAG/hB,SAA7G;AAAwHgiB,IAAAA,oBAAoB,GAAGhiB,SAA/I;AAA0JiiB,IAAAA,sBAAsB,GAAGjiB,SAAnL;AAA8LkiB,IAAAA,cAAc,GAAGliB;AAA/M,GAA6N;AAC/O,QAAMmiB,cAAc,GAAG1F,SAAS,CAAClb,MAAD,EAAS;AACrC,KAACmY,UAAU,CAAC2G,KAAZ,GAAqB1gB,IAAD,IAAUyiB,gBAAgB,CAACziB,IAAD,EAAO,OAAP,EAAgBmiB,eAAhB,EAAiCI,cAAjC,CADT;AAErC,KAACxI,UAAU,CAAC4G,QAAZ,GAAwB3gB,IAAD,IAAUyiB,gBAAgB,CAACziB,IAAD,EAAO,UAAP,EAAmBmiB,eAAnB,EAAoCI,cAApC,CAFZ;AAGrC,KAACxI,UAAU,CAAC6G,YAAZ,GAA4B5gB,IAAD,IAAUyiB,gBAAgB,CAACziB,IAAD,EAAO,cAAP,EAAuBmiB,eAAvB,EAAwCI,cAAxC,CAHhB;AAIrC,KAACxI,UAAU,CAACyG,WAAZ,GAA2BxgB,IAAD,IAAUiiB,UAAU,CAACjiB,IAAI,CAACzE,IAAN,EAAYyE,IAAZ,CAAV,GAC9B0iB,mBAAmB,CAAC5pB,iBAAD,EAAoBkH,IAApB,EAA0BoiB,iBAAiB,IAAIF,WAA/C,EAA4DK,cAA5D,CADW,GAE9B,IAN+B;AAOrC,KAACxI,UAAU,CAACgH,cAAZ,GAA8B/gB,IAAD,IAAUiiB,UAAU,CAACjiB,IAAI,CAACzE,IAAN,EAAYyE,IAAZ,CAAV,GACjC0iB,mBAAmB,CAAC3pB,oBAAD,EAAuBiH,IAAvB,EAA6BqiB,oBAAoB,IAAIH,WAArD,EAAkEK,cAAlE,CADc,GAEjC,IAT+B;AAUrC,KAACxI,UAAU,CAAC8G,iBAAZ,GAAiC7gB,IAAD,IAAUiiB,UAAU,CAACjiB,IAAI,CAACzE,IAAN,EAAYyE,IAAZ,CAAV,GACpC0iB,mBAAmB,CAAC1pB,sBAAD,EAAyBgH,IAAzB,EAA+BsiB,sBAAsB,IAAIJ,WAAzD,CADiB,GAEpC,IAZ+B;AAarC,KAACnI,UAAU,CAACiH,UAAZ,GAA0BhhB,IAAD,IAAWiiB,UAAU,CAACjiB,IAAI,CAACzE,IAAN,EAAYyE,IAAZ,CAAV,GAA8BK,SAA9B,GAA0C,IAbzC;AAcrC,KAAC0Z,UAAU,CAACkE,SAAZ,GAAyBje,IAAD,IAAWiiB,UAAU,CAACjiB,IAAI,CAACzE,IAAN,EAAYyE,IAAZ,CAAV,GAA8BK,SAA9B,GAA0C,IAdxC;AAerC,KAAC0Z,UAAU,CAACkH,WAAZ,GAA2BjhB,IAAD,IAAWiiB,UAAU,CAACjiB,IAAI,CAACzE,IAAN,EAAYyE,IAAZ,CAAV,GAA8BK,SAA9B,GAA0C;AAf1C,GAAT,CAAhC;AAiBA,SAAOmiB,cAAP;AACH;;AACD,SAASC,gBAAT,CAA0BziB,IAA1B,EAAgC2H,SAAhC,EAA2Cwa,eAA3C,EAA4DI,cAA5D,EAA4E;AACxE,MAAIJ,eAAe,IAAII,cAAvB,EAAuC;AACnC,UAAM1I,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;;AACA,SAAK,MAAMpX,SAAX,IAAwB8V,MAAM,CAACzW,MAA/B,EAAuC;AACnC,YAAMU,KAAK,GAAG+V,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAAd;;AACA,UAAIoe,eAAe,IAAI,CAACA,eAAe,CAACxa,SAAD,EAAY5D,SAAZ,EAAuB8V,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAAvB,CAAvC,EAAyF;AACrF,eAAO8V,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAAP;AACH,OAFD,MAGK,IAAIwe,cAAc,IAAIze,KAAK,CAAC3D,IAA5B,EAAkC;AACnC,aAAK,MAAM4M,OAAX,IAAsBjJ,KAAK,CAAC3D,IAA5B,EAAkC;AAC9B,cAAI,CAACoiB,cAAc,CAAC5a,SAAD,EAAY5D,SAAZ,EAAuBgJ,OAAvB,EAAgCjJ,KAAK,CAAC3D,IAAN,CAAW4M,OAAX,CAAhC,CAAnB,EAAyE;AACrE,mBAAOjJ,KAAK,CAAC3D,IAAN,CAAW4M,OAAX,CAAP;AACH;AACJ;AACJ;AACJ;;AACD,WAAO,IAAIjU,iBAAJ,CAAsB+gB,MAAtB,CAAP;AACH;;AACD,SAAO7Z,IAAP;AACH;;AACD,SAAS0iB,mBAAT,CAA6BC,kBAA7B,EAAiD3iB,IAAjD,EAAuDkiB,WAAvD,EAAoEK,cAApE,EAAoF;AAChF,MAAIL,WAAW,IAAIK,cAAnB,EAAmC;AAC/B,UAAM1I,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;;AACA,SAAK,MAAMpX,SAAX,IAAwB8V,MAAM,CAACzW,MAA/B,EAAuC;AACnC,YAAMU,KAAK,GAAG+V,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAAd;;AACA,UAAIme,WAAW,IAAI,CAACA,WAAW,CAACliB,IAAI,CAACzE,IAAN,EAAYwI,SAAZ,EAAuB8V,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAAvB,CAA/B,EAAiF;AAC7E,eAAO8V,MAAM,CAACzW,MAAP,CAAcW,SAAd,CAAP;AACH,OAFD,MAGK,IAAIwe,cAAc,IAAI,UAAUze,KAAhC,EAAuC;AACxC,aAAK,MAAMiJ,OAAX,IAAsBjJ,KAAK,CAAC3D,IAA5B,EAAkC;AAC9B,cAAI,CAACoiB,cAAc,CAACviB,IAAI,CAACzE,IAAN,EAAYwI,SAAZ,EAAuBgJ,OAAvB,EAAgCjJ,KAAK,CAAC3D,IAAN,CAAW4M,OAAX,CAAhC,CAAnB,EAAyE;AACrE,mBAAOjJ,KAAK,CAAC3D,IAAN,CAAW4M,OAAX,CAAP;AACH;AACJ;AACJ;AACJ;;AACD,WAAO,IAAI4V,kBAAJ,CAAuB9I,MAAvB,CAAP;AACH;AACJ,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS+I,UAAT,CAAoBhhB,MAApB,EAA4B;AACxBihB,EAAAA,SAAS,CAACjhB,MAAM,CAACwC,UAAP,EAAD,EAAsBxC,MAAM,CAACD,aAAP,EAAtB,CAAT;AACA,SAAOC,MAAP;AACH;;AACD,SAASihB,SAAT,CAAmBpI,eAAnB,EAAoCrY,UAApC,EAAgD;AAC5C,QAAM0gB,kBAAkB,GAAG7kB,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAA3B,CAD4C,CAE5C;AACA;AACA;;AACA,OAAK,MAAM9W,QAAX,IAAuB4W,eAAvB,EAAwC;AACpC,UAAMjB,SAAS,GAAGiB,eAAe,CAAC5W,QAAD,CAAjC;;AACA,QAAI2V,SAAS,IAAI,IAAb,IAAqB3V,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAzB,EAAoD;AAChD;AACH;;AACD,UAAMkI,UAAU,GAAGvJ,SAAS,CAACje,IAA7B;;AACA,QAAIwnB,UAAU,CAAClI,UAAX,CAAsB,IAAtB,CAAJ,EAAiC;AAC7B;AACH;;AACD,QAAIkI,UAAU,IAAID,kBAAlB,EAAsC;AAClC,YAAM,IAAI3mB,KAAJ,CAAW,8BAA6B4mB,UAAW,EAAnD,CAAN;AACH;;AACDD,IAAAA,kBAAkB,CAACC,UAAD,CAAlB,GAAiCvJ,SAAjC,CAZoC,CAapC;AACA;AACA;AACH,GArB2C,CAsB5C;;;AACA,OAAK,MAAM3V,QAAX,IAAuBif,kBAAvB,EAA2C;AACvC,UAAMtJ,SAAS,GAAGsJ,kBAAkB,CAACjf,QAAD,CAApC;AACA4W,IAAAA,eAAe,CAAC5W,QAAD,CAAf,GAA4B2V,SAA5B;AACH,GA1B2C,CA2B5C;;;AACA,OAAK,MAAMwJ,IAAX,IAAmB5gB,UAAnB,EAA+B;AAC3B4gB,IAAAA,IAAI,CAAC7iB,IAAL,GAAY6iB,IAAI,CAAC7iB,IAAL,CAAUkB,MAAV,CAAiBtB,GAAG,IAAI;AAChCA,MAAAA,GAAG,CAACC,IAAJ,GAAWijB,QAAQ,CAACljB,GAAG,CAACC,IAAL,CAAnB;AACA,aAAOD,GAAG,CAACC,IAAJ,KAAa,IAApB;AACH,KAHW,CAAZ;AAIH;;AACD,OAAK,MAAM6D,QAAX,IAAuB4W,eAAvB,EAAwC;AACpC,UAAMjB,SAAS,GAAGiB,eAAe,CAAC5W,QAAD,CAAjC,CADoC,CAEpC;;AACA,QAAI,CAACA,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAD,IAA8BhX,QAAQ,IAAIif,kBAA9C,EAAkE;AAC9D,UAAItJ,SAAS,IAAI,IAAjB,EAAuB;AACnB0J,QAAAA,aAAa,CAAC1J,SAAD,CAAb;AACH;AACJ;AACJ;;AACD,OAAK,MAAM3V,QAAX,IAAuB4W,eAAvB,EAAwC;AACpC,QAAI,CAAC5W,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAD,IAA8B,EAAEhX,QAAQ,IAAIif,kBAAd,CAAlC,EAAqE;AACjE,aAAOrI,eAAe,CAAC5W,QAAD,CAAtB;AACH;AACJ;;AACD,WAASqf,aAAT,CAAuBljB,IAAvB,EAA6B;AACzB,QAAI/I,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpBmjB,MAAAA,UAAU,CAACnjB,IAAD,CAAV;AACAojB,MAAAA,cAAc,CAACpjB,IAAD,CAAd;AACA;AACH,KAJD,MAKK,IAAIzI,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5BmjB,MAAAA,UAAU,CAACnjB,IAAD,CAAV;;AACA,UAAI,mBAAmBA,IAAvB,EAA6B;AACzBojB,QAAAA,cAAc,CAACpjB,IAAD,CAAd;AACH;;AACD;AACH,KANI,MAOA,IAAIxI,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxBqjB,MAAAA,mBAAmB,CAACrjB,IAAD,CAAnB;AACA;AACH,KAHI,MAIA,IAAIvI,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9BsjB,MAAAA,eAAe,CAACtjB,IAAD,CAAf;AACA;AACH,KAHI,MAIA,IAAIzG,UAAU,CAACyG,IAAD,CAAd,EAAsB;AACvB;AACH;;AACD,UAAM,IAAI7D,KAAJ,CAAW,2BAA0B6D,IAAK,EAA1C,CAAN;AACH;;AACD,WAASmjB,UAAT,CAAoBnjB,IAApB,EAA0B;AACtB,UAAMujB,QAAQ,GAAGvjB,IAAI,CAACwL,SAAL,EAAjB;;AACA,SAAK,MAAM,CAAClN,GAAD,EAAMwF,KAAN,CAAX,IAA2B7F,MAAM,CAACD,OAAP,CAAeulB,QAAf,CAA3B,EAAqD;AACjDzf,MAAAA,KAAK,CAAC3D,IAAN,CACK9B,GADL,CACS0B,GAAG,IAAI;AACZA,QAAAA,GAAG,CAACC,IAAJ,GAAWijB,QAAQ,CAACljB,GAAG,CAACC,IAAL,CAAnB;AACA,eAAOD,GAAG,CAACC,IAAJ,KAAa,IAAb,GAAoB,IAApB,GAA2BD,GAAlC;AACH,OAJD,EAKKsB,MALL,CAKYwB,OALZ;AAMAiB,MAAAA,KAAK,CAAC9D,IAAN,GAAaijB,QAAQ,CAACnf,KAAK,CAAC9D,IAAP,CAArB;;AACA,UAAI8D,KAAK,CAAC9D,IAAN,KAAe,IAAnB,EAAyB;AACrB,eAAOujB,QAAQ,CAACjlB,GAAD,CAAf;AACH;AACJ;AACJ;;AACD,WAAS8kB,cAAT,CAAwBpjB,IAAxB,EAA8B;AAC1B,QAAI,mBAAmBA,IAAvB,EAA6B;AACzB,YAAM0L,UAAU,GAAG1L,IAAI,CAACwE,aAAL,EAAnB;AACAkH,MAAAA,UAAU,CAAC3M,IAAX,CAAgB,GAAG2M,UAAU,CACxB8X,MADc,CACP,CADO,EAEdnlB,GAFc,CAEVolB,KAAK,IAAIR,QAAQ,CAACQ,KAAD,CAFP,EAGdpiB,MAHc,CAGPwB,OAHO,CAAnB;AAIH;AACJ;;AACD,WAASygB,eAAT,CAAyBtjB,IAAzB,EAA+B;AAC3B,UAAMujB,QAAQ,GAAGvjB,IAAI,CAACwL,SAAL,EAAjB;;AACA,SAAK,MAAM,CAAClN,GAAD,EAAMwF,KAAN,CAAX,IAA2B7F,MAAM,CAACD,OAAP,CAAeulB,QAAf,CAA3B,EAAqD;AACjDzf,MAAAA,KAAK,CAAC9D,IAAN,GAAaijB,QAAQ,CAACnf,KAAK,CAAC9D,IAAP,CAArB;;AACA,UAAI8D,KAAK,CAAC9D,IAAN,KAAe,IAAnB,EAAyB;AACrB,eAAOujB,QAAQ,CAACjlB,GAAD,CAAf;AACH;AACJ;AACJ;;AACD,WAAS+kB,mBAAT,CAA6BrjB,IAA7B,EAAmC;AAC/B,UAAM8L,KAAK,GAAG9L,IAAI,CAAC+L,QAAL,EAAd;AACAD,IAAAA,KAAK,CAAC/M,IAAN,CAAW,GAAG+M,KAAK,CACd0X,MADS,CACF,CADE,EAETnlB,GAFS,CAELua,CAAC,IAAIqK,QAAQ,CAACrK,CAAD,CAFR,EAGTvX,MAHS,CAGFwB,OAHE,CAAd;AAIH;;AACD,WAASogB,QAAT,CAAkBjjB,IAAlB,EAAwB;AACpB;AACA,QAAI9I,UAAU,CAAC8I,IAAD,CAAd,EAAsB;AAClB,YAAM0jB,UAAU,GAAGT,QAAQ,CAACjjB,IAAI,CAAC6E,MAAN,CAA3B;AACA,aAAO6e,UAAU,IAAI,IAAd,GAAqB,IAAIjrB,WAAJ,CAAgBirB,UAAhB,CAArB,GAAmD,IAA1D;AACH,KAHD,MAIK,IAAI7sB,aAAa,CAACmJ,IAAD,CAAjB,EAAyB;AAC1B,YAAM0jB,UAAU,GAAGT,QAAQ,CAACjjB,IAAI,CAAC6E,MAAN,CAA3B;AACA,aAAO6e,UAAU,IAAI,IAAd,GAAqB,IAAIlrB,cAAJ,CAAmBkrB,UAAnB,CAArB,GAAsD,IAA7D;AACH,KAHI,MAIA,IAAIrqB,WAAW,CAAC2G,IAAD,CAAf,EAAuB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,YAAM2jB,YAAY,GAAGlJ,eAAe,CAACza,IAAI,CAACzE,IAAN,CAApC;;AACA,UAAIooB,YAAY,IAAI3jB,IAAI,KAAK2jB,YAA7B,EAA2C;AACvC,eAAOA,YAAP;AACH;AACJ;;AACD,WAAO3jB,IAAP;AACH;AACJ;;AAED,SAAS4jB,sBAAT,CAAgChiB,MAAhC,EAAwC;AACpC,MAAIvG,EAAJ,EAAQC,EAAR;;AACA,QAAMuoB,SAAS,GAAG5lB,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAAlB;AACA,QAAMV,OAAO,GAAGrY,MAAM,CAACwC,UAAP,EAAhB;;AACA,OAAK,MAAMP,QAAX,IAAuBoW,OAAvB,EAAgC;AAC5B,QAAI,CAACpW,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAL,EAAgC;AAC5B,YAAM7a,IAAI,GAAGia,OAAO,CAACpW,QAAD,CAApB;;AACA,UAAIlM,YAAY,CAACqI,IAAD,CAAhB,EAAwB;AACpB,YAAI,CAAC3I,qBAAqB,CAAC2I,IAAD,CAA1B,EAAkC;AAC9B,gBAAM6Z,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,iBAAOtB,MAAM,CAAC5X,OAAd,CAF8B,CAEP;;AACvB4hB,UAAAA,SAAS,CAAChgB,QAAD,CAAT,GAAsB,IAAIzK,iBAAJ,CAAsBygB,MAAtB,CAAtB;AACH;AACJ,OAND,MAOK,IAAIniB,UAAU,CAACsI,IAAD,CAAd,EAAsB;AACvB6jB,QAAAA,SAAS,CAAChgB,QAAD,CAAT,GAAsB,EAAtB;AACA,cAAMZ,MAAM,GAAGjD,IAAI,CAACmM,SAAL,EAAf;;AACA,aAAK,MAAM1Q,KAAX,IAAoBwH,MAApB,EAA4B;AACxB4gB,UAAAA,SAAS,CAAChgB,QAAD,CAAT,CAAoBpI,KAAK,CAACF,IAA1B,IAAkCE,KAAK,CAACA,KAAxC;AACH;AACJ,OANI,MAOA,IAAIlE,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5B,YAAIA,IAAI,CAAC8jB,WAAL,IAAoB,IAAxB,EAA8B;AAC1BD,UAAAA,SAAS,CAAChgB,QAAD,CAAT,GAAsB;AAClBkgB,YAAAA,aAAa,EAAE/jB,IAAI,CAAC8jB;AADF,WAAtB;AAGH;AACJ,OANI,MAOA,IAAItsB,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxB,YAAIA,IAAI,CAAC8jB,WAAL,IAAoB,IAAxB,EAA8B;AAC1BD,UAAAA,SAAS,CAAChgB,QAAD,CAAT,GAAsB;AAClBkgB,YAAAA,aAAa,EAAE/jB,IAAI,CAAC8jB;AADF,WAAtB;AAGH;AACJ,OANI,MAOA,IAAI7sB,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACzB6jB,QAAAA,SAAS,CAAChgB,QAAD,CAAT,GAAsB,EAAtB;;AACA,YAAI7D,IAAI,CAACgkB,QAAL,IAAiB,IAArB,EAA2B;AACvBH,UAAAA,SAAS,CAAChgB,QAAD,CAAT,CAAoBogB,UAApB,GAAiCjkB,IAAI,CAACgkB,QAAtC;AACH;;AACD,cAAM5gB,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf;;AACA,aAAK,MAAMzH,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,gBAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;;AACA,cAAID,KAAK,CAACogB,SAAN,IAAmB,IAAvB,EAA6B;AACzBL,YAAAA,SAAS,CAAChgB,QAAD,CAAT,CAAoBE,SAApB,IAAiC8f,SAAS,CAAChgB,QAAD,CAAT,CAAoBE,SAApB,KAAkC,EAAnE;AACA8f,YAAAA,SAAS,CAAChgB,QAAD,CAAT,CAAoBE,SAApB,EAA+BmgB,SAA/B,GAA2CpgB,KAAK,CAACogB,SAAjD;AACH;;AACD,cAAIpgB,KAAK,CAACqgB,OAAN,IAAiB,IAAjB,IACA,CAAC,CAAC9oB,EAAE,GAAGyI,KAAK,CAACqgB,OAAZ,MAAyB,IAAzB,IAAiC9oB,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACE,IAA9D,MAAwE,sBADxE,IAEA,CAAC,CAACD,EAAE,GAAGwI,KAAK,CAACqgB,OAAZ,MAAyB,IAAzB,IAAiC7oB,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACC,IAA9D,MAAwE,uBAF5E,EAEqG;AACjGsoB,YAAAA,SAAS,CAAChgB,QAAD,CAAT,CAAoBE,SAApB,IAAiC8f,SAAS,CAAChgB,QAAD,CAAT,CAAoBE,SAApB,KAAkC,EAAnE;AACA8f,YAAAA,SAAS,CAAChgB,QAAD,CAAT,CAAoBE,SAApB,EAA+BogB,OAA/B,GAAyCrgB,KAAK,CAACqgB,OAA/C;AACH;AACJ;AACJ;AACJ;AACJ;;AACD,SAAON,SAAP;AACH;;AAED,SAASO,YAAT,CAAsBxiB,MAAtB,EAA8BmE,EAA9B,EAAkC;AAC9B,QAAMkU,OAAO,GAAGrY,MAAM,CAACwC,UAAP,EAAhB;;AACA,OAAK,MAAMP,QAAX,IAAuBoW,OAAvB,EAAgC;AAC5B,UAAMja,IAAI,GAAGia,OAAO,CAACpW,QAAD,CAApB,CAD4B,CAE5B;;AACA,QAAI,CAACvL,YAAY,CAAC0H,IAAD,CAAZ,CAAmBzE,IAAnB,CAAwBsf,UAAxB,CAAmC,IAAnC,CAAD,IAA6C5jB,YAAY,CAAC+I,IAAD,CAA7D,EAAqE;AACjE,YAAMoD,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf;;AACA,WAAK,MAAMzH,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,cAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;AACAgC,QAAAA,EAAE,CAACjC,KAAD,EAAQD,QAAR,EAAkBE,SAAlB,CAAF;AACH;AACJ;AACJ;AACJ;;AAED,SAASsgB,mBAAT,CAA6BziB,MAA7B,EAAqCmE,EAArC,EAAyC;AACrC,QAAMkU,OAAO,GAAGrY,MAAM,CAACwC,UAAP,EAAhB;;AACA,OAAK,MAAMP,QAAX,IAAuBoW,OAAvB,EAAgC;AAC5B,UAAMja,IAAI,GAAGia,OAAO,CAACpW,QAAD,CAApB;;AACA,QAAI,CAACvL,YAAY,CAAC0H,IAAD,CAAZ,CAAmBzE,IAAnB,CAAwBsf,UAAxB,CAAmC,IAAnC,CAAL,EAA+C;AAC3C,UAAI5jB,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpB,cAAMoD,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf;;AACA,aAAK,MAAMzH,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,gBAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;;AACA,eAAK,MAAMhE,GAAX,IAAkB+D,KAAK,CAAC3D,IAAxB,EAA8B;AAC1BJ,YAAAA,GAAG,CAACG,YAAJ,GAAmB6F,EAAE,CAAChG,GAAG,CAACC,IAAL,EAAWD,GAAG,CAACG,YAAf,CAArB;AACH;AACJ;AACJ,OARD,MASK,IAAIzI,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9B,cAAMoD,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf;;AACA,aAAK,MAAMzH,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,gBAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;AACAD,UAAAA,KAAK,CAAC5D,YAAN,GAAqB6F,EAAE,CAACjC,KAAK,CAAC9D,IAAP,EAAa8D,KAAK,CAAC5D,YAAnB,CAAvB;AACH;AACJ;AACJ;AACJ;AACJ,C,CAED;;;AACA,SAASokB,QAAT,CAAkB1iB,MAAlB,EAA0B2iB,oBAA1B,EAAgD;AAC5C,QAAM1K,MAAM,GAAGjY,MAAM,CAACuZ,QAAP,EAAf;AACA,QAAMV,eAAe,GAAG,EAAxB;;AACA,OAAK,MAAMza,IAAX,IAAmB6Z,MAAM,CAAC/N,KAA1B,EAAiC;AAC7B2O,IAAAA,eAAe,CAACza,IAAI,CAACzE,IAAN,CAAf,GAA6ByE,IAA7B;AACH;;AACD,QAAMwkB,oBAAoB,GAAG,EAA7B;;AACA,OAAK,MAAMjjB,SAAX,IAAwBsY,MAAM,CAACzX,UAA/B,EAA2C;AACvCoiB,IAAAA,oBAAoB,CAACjjB,SAAS,CAAChG,IAAX,CAApB,GAAuCgG,SAAvC;AACH;;AACD,OAAK,MAAMkjB,kBAAX,IAAiCF,oBAAjC,EAAuD;AACnD,QAAIlrB,WAAW,CAACorB,kBAAD,CAAf,EAAqC;AACjChK,MAAAA,eAAe,CAACgK,kBAAkB,CAAClpB,IAApB,CAAf,GAA2CkpB,kBAA3C;AACH,KAFD,MAGK,IAAIhrB,WAAW,CAACgrB,kBAAD,CAAf,EAAqC;AACtCD,MAAAA,oBAAoB,CAACC,kBAAkB,CAAClpB,IAApB,CAApB,GAAgDkpB,kBAAhD;AACH;AACJ;;AACD,QAAM;AAAExK,IAAAA,OAAF;AAAW7X,IAAAA;AAAX,MAA0BoY,WAAW,CAACC,eAAD,EAAkBxc,MAAM,CAACgF,MAAP,CAAcuhB,oBAAd,CAAlB,CAA3C;AACA,SAAO,IAAIhrB,aAAJ,CAAkB,EACrB,GAAGqgB,MADkB;AAErB0D,IAAAA,KAAK,EAAEvD,wBAAwB,CAACC,OAAD,EAAUrY,MAAM,CAACyG,YAAP,EAAV,CAFV;AAGrBmV,IAAAA,QAAQ,EAAExD,wBAAwB,CAACC,OAAD,EAAUrY,MAAM,CAAC2G,eAAP,EAAV,CAHb;AAIrBkV,IAAAA,YAAY,EAAEzD,wBAAwB,CAACC,OAAD,EAAUrY,MAAM,CAAC6G,mBAAP,EAAV,CAJjB;AAKrBqD,IAAAA,KAAK,EAAE7N,MAAM,CAACgF,MAAP,CAAcgX,OAAd,CALc;AAMrB7X,IAAAA;AANqB,GAAlB,CAAP;AAQH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASsiB,WAAT,CAAqB9iB,MAArB,EAA2C;AAAA,MAAd2B,OAAc,uEAAJ,EAAI;AACvC,QAAMohB,cAAc,GAAG;AACnB/iB,IAAAA,MADmB;AAEnBgjB,IAAAA,WAAW,EAAE3mB,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAFM;AAGnBkK,IAAAA,eAAe,EAAE5mB,MAAM,CAAC0c,MAAP,CAAc,IAAd;AAHE,GAAvB;;AAKA,OAAK,MAAM9W,QAAX,IAAuBjC,MAAM,CAACwC,UAAP,EAAvB,EAA4C;AACxC,UAAMpE,IAAI,GAAG4B,MAAM,CAACwe,OAAP,CAAevc,QAAf,CAAb;;AACA,QAAI7D,IAAI,IAAI,mBAAmBA,IAA/B,EAAqC;AACjC,WAAK,MAAMyjB,KAAX,IAAoBzjB,IAAI,CAACwE,aAAL,EAApB,EAA0C;AACtC,cAAMqgB,eAAe,GAAGC,kBAAkB,CAACH,cAAD,EAAiBlB,KAAjB,CAA1C;;AACA,YAAIoB,eAAe,IAAI,IAAvB,EAA6B;AACzBF,UAAAA,cAAc,CAACE,eAAf,CAA+BpB,KAAK,CAACloB,IAArC,IAA6C0C,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAA7C;AACH;;AACDgK,QAAAA,cAAc,CAACE,eAAf,CAA+BpB,KAAK,CAACloB,IAArC,EAA2CyE,IAAI,CAACzE,IAAhD,IAAwD,IAAxD;AACH;AACJ;AACJ;;AACDwpB,EAAAA,UAAU,CAACJ,cAAD,EAAiB/iB,MAAjB,CAAV;AACA,SAAOkb,SAAS,CAAClb,MAAD,EAAS;AACrB,KAACmY,UAAU,CAACuG,IAAZ,GAAoBtgB,IAAD,IAAU;AACzB;AACA,UAAIuD,OAAO,CAACyhB,WAAR,IAAuBzhB,OAAO,CAACyhB,WAAR,CAAoBhlB,IAApB,CAA3B,EAAsD;AAClD,eAAOA,IAAP;AACH;;AACD,UAAI/I,YAAY,CAAC+I,IAAD,CAAZ,IAAsBvI,iBAAiB,CAACuI,IAAD,CAA3C,EAAmD;AAC/C,YAAK,CAAC/B,MAAM,CAACsS,IAAP,CAAYvQ,IAAI,CAACwL,SAAL,EAAZ,EAA8BtN,MAA/B,IAAyC,CAACqF,OAAO,CAAC0hB,6BAAnD,IACCN,cAAc,CAACC,WAAf,CAA2B5kB,IAAI,CAACzE,IAAhC,KAAyC,CAACgI,OAAO,CAAC2hB,sBADvD,EACgF;AAC5E,iBAAO,IAAP;AACH;AACJ,OALD,MAMK,IAAI1tB,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxB,YAAK,CAACA,IAAI,CAAC+L,QAAL,GAAgB7N,MAAjB,IAA2B,CAACqF,OAAO,CAAC4hB,qBAArC,IACCR,cAAc,CAACC,WAAf,CAA2B5kB,IAAI,CAACzE,IAAhC,KAAyC,CAACgI,OAAO,CAAC2hB,sBADvD,EACgF;AAC5E,iBAAO,IAAP;AACH;AACJ,OALI,MAMA,IAAI3tB,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5B,cAAM6kB,eAAe,GAAGC,kBAAkB,CAACH,cAAD,EAAiB3kB,IAAjB,CAA1C;;AACA,YAAK,CAAC/B,MAAM,CAACsS,IAAP,CAAYvQ,IAAI,CAACwL,SAAL,EAAZ,EAA8BtN,MAA/B,IAAyC,CAACqF,OAAO,CAAC0hB,6BAAnD,IACCJ,eAAe,IAAI,CAAC5mB,MAAM,CAACsS,IAAP,CAAYsU,eAAZ,EAA6B3mB,MAAjD,IAA2D,CAACqF,OAAO,CAAC6hB,kCADrE,IAECT,cAAc,CAACC,WAAf,CAA2B5kB,IAAI,CAACzE,IAAhC,KAAyC,CAACgI,OAAO,CAAC2hB,sBAFvD,EAEgF;AAC5E,iBAAO,IAAP;AACH;AACJ,OAPI,MAQA;AACD,YAAIP,cAAc,CAACC,WAAf,CAA2B5kB,IAAI,CAACzE,IAAhC,KAAyC,CAACgI,OAAO,CAAC2hB,sBAAtD,EAA8E;AAC1E,iBAAO,IAAP;AACH;AACJ;AACJ;AA/BoB,GAAT,CAAhB;AAiCH;;AACD,SAASG,eAAT,CAAyBC,YAAzB,EAAuCX,cAAvC,EAAuD3kB,IAAvD,EAA6D;AACzD,MAAIslB,YAAY,CAACtlB,IAAI,CAACzE,IAAN,CAAhB,EAA6B;AACzB;AACH;;AACD+pB,EAAAA,YAAY,CAACtlB,IAAI,CAACzE,IAAN,CAAZ,GAA0B,IAA1B;AACAopB,EAAAA,cAAc,CAACC,WAAf,CAA2B5kB,IAAI,CAACzE,IAAhC,IAAwC,KAAxC;;AACA,MAAItE,YAAY,CAAC+I,IAAD,CAAZ,IAAsBzI,eAAe,CAACyI,IAAD,CAAzC,EAAiD;AAC7C,UAAMoD,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf;;AACA,SAAK,MAAMzH,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,YAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;AACA,YAAMyV,SAAS,GAAGlhB,YAAY,CAACwL,KAAK,CAAC9D,IAAP,CAA9B;AACAqlB,MAAAA,eAAe,CAACC,YAAD,EAAeX,cAAf,EAA+BnL,SAA/B,CAAf;;AACA,WAAK,MAAMzZ,GAAX,IAAkB+D,KAAK,CAAC3D,IAAxB,EAA8B;AAC1B,cAAMH,IAAI,GAAG1H,YAAY,CAACyH,GAAG,CAACC,IAAL,CAAzB;AACAulB,QAAAA,cAAc,CAACD,YAAD,EAAeX,cAAf,EAA+B3kB,IAA/B,CAAd;AACH;AACJ;;AACD,QAAIzI,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AACvB,YAAM6kB,eAAe,GAAGC,kBAAkB,CAACH,cAAD,EAAiB3kB,IAAjB,CAA1C;;AACA,UAAI6kB,eAAJ,EAAqB;AACjB,aAAK,MAAMhhB,QAAX,IAAuBghB,eAAvB,EAAwC;AACpCQ,UAAAA,eAAe,CAACC,YAAD,EAAeX,cAAf,EAA+BA,cAAc,CAAC/iB,MAAf,CAAsBwe,OAAtB,CAA8Bvc,QAA9B,CAA/B,CAAf;AACH;AACJ;AACJ;;AACD,QAAI,mBAAmB7D,IAAvB,EAA6B;AACzB,WAAK,MAAM2L,KAAX,IAAoB3L,IAAI,CAACwE,aAAL,EAApB,EAA0C;AACtC6gB,QAAAA,eAAe,CAACC,YAAD,EAAeX,cAAf,EAA+BhZ,KAA/B,CAAf;AACH;AACJ;AACJ,GAxBD,MAyBK,IAAInU,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxB,UAAM8L,KAAK,GAAG9L,IAAI,CAAC+L,QAAL,EAAd;;AACA,SAAK,MAAM/L,IAAX,IAAmB8L,KAAnB,EAA0B;AACtBuZ,MAAAA,eAAe,CAACC,YAAD,EAAeX,cAAf,EAA+B3kB,IAA/B,CAAf;AACH;AACJ;AACJ;AACD;AACA;AACA;;;AACA,SAAS8kB,kBAAT,CAA4BH,cAA5B,EAA4C3kB,IAA5C,EAAkD;AAC9C,SAAO2kB,cAAc,CAACE,eAAf,CAA+B7kB,IAAI,CAACzE,IAApC,CAAP;AACH;;AACD,SAASgqB,cAAT,CAAwBD,YAAxB,EAAsCX,cAAtC,EAAsD3kB,IAAtD,EAA4D;AACxD,MAAIslB,YAAY,CAACtlB,IAAI,CAACzE,IAAN,CAAhB,EAA6B;AACzB;AACH;;AACDopB,EAAAA,cAAc,CAACC,WAAf,CAA2B5kB,IAAI,CAACzE,IAAhC,IAAwC,KAAxC;AACA+pB,EAAAA,YAAY,CAACtlB,IAAI,CAACzE,IAAN,CAAZ,GAA0B,IAA1B;;AACA,MAAI9D,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AACzB,UAAMoD,MAAM,GAAGpD,IAAI,CAACwL,SAAL,EAAf;;AACA,SAAK,MAAMzH,SAAX,IAAwBX,MAAxB,EAAgC;AAC5B,YAAMU,KAAK,GAAGV,MAAM,CAACW,SAAD,CAApB;AACA,YAAMyV,SAAS,GAAGlhB,YAAY,CAACwL,KAAK,CAAC9D,IAAP,CAA9B;AACAulB,MAAAA,cAAc,CAACD,YAAD,EAAeX,cAAf,EAA+BnL,SAA/B,CAAd;AACH;AACJ;AACJ;;AACD,SAASuL,UAAT,CAAoBJ,cAApB,EAAoC/iB,MAApC,EAA4C;AACxC,OAAK,MAAMiC,QAAX,IAAuBjC,MAAM,CAACwC,UAAP,EAAvB,EAA4C;AACxC,QAAI,CAACP,QAAQ,CAACgX,UAAT,CAAoB,IAApB,CAAL,EAAgC;AAC5B8J,MAAAA,cAAc,CAACC,WAAf,CAA2B/gB,QAA3B,IAAuC,IAAvC;AACH;AACJ;;AACD,QAAMyhB,YAAY,GAAGrnB,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAArB;AACA,QAAM3S,SAAS,GAAGC,YAAY,CAACrG,MAAD,CAA9B;;AACA,OAAK,MAAMkG,QAAX,IAAuBE,SAAvB,EAAkC;AAC9Bqd,IAAAA,eAAe,CAACC,YAAD,EAAeX,cAAf,EAA+B7c,QAA/B,CAAf;AACH;;AACD,OAAK,MAAMvG,SAAX,IAAwBK,MAAM,CAACD,aAAP,EAAxB,EAAgD;AAC5C,SAAK,MAAM5B,GAAX,IAAkBwB,SAAS,CAACpB,IAA5B,EAAkC;AAC9B,YAAMH,IAAI,GAAG1H,YAAY,CAACyH,GAAG,CAACC,IAAL,CAAzB;AACAulB,MAAAA,cAAc,CAACD,YAAD,EAAeX,cAAf,EAA+B3kB,IAA/B,CAAd;AACH;AACJ;AACJ,C,CAED;;;AACA,SAASwlB,SAAT,CAAmBC,OAAnB,EAAsD;AAAA,MAA1BC,gBAA0B,uEAAP,KAAO;AAClD,QAAMC,MAAM,GAAGF,OAAO,CAAC,CAAD,CAAP,IAAc,EAA7B;AACA,QAAMG,MAAM,GAAG,EAAf;;AACA,MAAIF,gBAAJ,EAAsB;AAClBznB,IAAAA,MAAM,CAAC4nB,cAAP,CAAsBD,MAAtB,EAA8B3nB,MAAM,CAAC0c,MAAP,CAAc1c,MAAM,CAAC6nB,cAAP,CAAsBH,MAAtB,CAAd,CAA9B;AACH;;AACD,OAAK,MAAMI,MAAX,IAAqBN,OAArB,EAA8B;AAC1B,QAAIO,QAAQ,CAACL,MAAD,CAAR,IAAoBK,QAAQ,CAACD,MAAD,CAAhC,EAA0C;AACtC,UAAIL,gBAAJ,EAAsB;AAClB,cAAMO,eAAe,GAAGhoB,MAAM,CAAC6nB,cAAP,CAAsBF,MAAtB,CAAxB;AACA,cAAMM,eAAe,GAAGjoB,MAAM,CAAC6nB,cAAP,CAAsBC,MAAtB,CAAxB;;AACA,YAAIG,eAAJ,EAAqB;AACjB,eAAK,MAAM5nB,GAAX,IAAkBL,MAAM,CAACkoB,mBAAP,CAA2BD,eAA3B,CAAlB,EAA+D;AAC3D,kBAAME,UAAU,GAAGnoB,MAAM,CAACooB,wBAAP,CAAgCH,eAAhC,EAAiD5nB,GAAjD,CAAnB;;AACA,gBAAIvC,MAAM,CAACqqB,UAAD,CAAV,EAAwB;AACpBnoB,cAAAA,MAAM,CAACqoB,cAAP,CAAsBL,eAAtB,EAAuC3nB,GAAvC,EAA4C8nB,UAA5C;AACH;AACJ;AACJ;AACJ;;AACD,WAAK,MAAM9nB,GAAX,IAAkBynB,MAAlB,EAA0B;AACtB,YAAIC,QAAQ,CAACD,MAAM,CAACznB,GAAD,CAAP,CAAZ,EAA2B;AACvB,cAAI,EAAEA,GAAG,IAAIsnB,MAAT,CAAJ,EAAsB;AAClB3nB,YAAAA,MAAM,CAACsoB,MAAP,CAAcX,MAAd,EAAsB;AAAE,eAACtnB,GAAD,GAAOynB,MAAM,CAACznB,GAAD;AAAf,aAAtB;AACH,WAFD,MAGK;AACDsnB,YAAAA,MAAM,CAACtnB,GAAD,CAAN,GAAcknB,SAAS,CAAC,CAACI,MAAM,CAACtnB,GAAD,CAAP,EAAcynB,MAAM,CAACznB,GAAD,CAApB,CAAD,EAA6BonB,gBAA7B,CAAvB;AACH;AACJ,SAPD,MAQK;AACDznB,UAAAA,MAAM,CAACsoB,MAAP,CAAcX,MAAd,EAAsB;AAAE,aAACtnB,GAAD,GAAOynB,MAAM,CAACznB,GAAD;AAAf,WAAtB;AACH;AACJ;AACJ;AACJ;;AACD,SAAOsnB,MAAP;AACH;;AACD,SAASI,QAAT,CAAkB5gB,IAAlB,EAAwB;AACpB,SAAOA,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAAxB,IAAoC,CAAC7K,KAAK,CAACC,OAAN,CAAc4K,IAAd,CAA5C;AACH;;AAED,SAASohB,iBAAT,CAA2BlU,YAA3B,EAAyC/O,OAAzC,EAAkD;AAC9C,QAAMga,KAAK,GAAG5mB,KAAK,CAAC2b,YAAD,EAAe/O,OAAf,CAAL,CAA6BI,WAA7B,CAAyC,CAAzC,CAAd;AACA,SAAO4Z,KAAK,CAACjL,YAAb;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASmU,sBAAT,CAAgCC,IAAhC,EAAsC;AAClC,SAAOA,IAAI,CAACphB,UAAL,CAAgB,CAAhB,EAAmB9J,KAAnB,IAA4B,IAA5B,GAAmCkrB,IAAI,CAACphB,UAAL,CAAgB,CAAhB,EAAmB9J,KAAnB,CAAyBC,KAA5D,GAAoEirB,IAAI,CAAC3iB,SAAhF;AACH;;AAED,SAAS4iB,kBAAT,CAA4B/kB,MAA5B,EAAoCiC,QAApC,EAA8C+iB,gBAA9C,EAAgE;AAC5D,MAAIhlB,MAAM,CAACwe,OAAP,CAAevc,QAAf,KAA4B,IAAhC,EAAsC;AAClC,WAAOygB,QAAQ,CAAC1iB,MAAD,EAAS,CACpB,IAAI9I,iBAAJ,CAAsB;AAClByC,MAAAA,IAAI,EAAEsI,QADY;AAElBT,MAAAA,MAAM,EAAEwjB;AAFU,KAAtB,CADoB,CAAT,CAAf;AAMH;;AACD,SAAO9J,SAAS,CAAClb,MAAD,EAAS;AACrB,KAACmY,UAAU,CAACyG,WAAZ,GAA0BxgB,IAAI,IAAI;AAC9B,UAAIA,IAAI,CAACzE,IAAL,KAAcsI,QAAlB,EAA4B;AACxB,cAAMgW,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,cAAM8D,sBAAsB,GAAGpF,MAAM,CAACzW,MAAtC;AACA,cAAM8b,iBAAiB,GAAG,EAA1B;;AACA,aAAK,MAAMnb,SAAX,IAAwBkb,sBAAxB,EAAgD;AAC5CC,UAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+Bkb,sBAAsB,CAAClb,SAAD,CAArD;AACH;;AACD,aAAK,MAAMA,SAAX,IAAwB6iB,gBAAxB,EAA0C;AACtC1H,UAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+B6iB,gBAAgB,CAAC7iB,SAAD,CAA/C;AACH;;AACD,eAAO0a,eAAe,CAAC,IAAI3lB,iBAAJ,CAAsB,EACzC,GAAG+gB,MADsC;AAEzCzW,UAAAA,MAAM,EAAE8b;AAFiC,SAAtB,CAAD,CAAtB;AAIH;AACJ;AAjBoB,GAAT,CAAhB;AAmBH;;AACD,SAAS2H,kBAAT,CAA4BjlB,MAA5B,EAAoCiC,QAApC,EAA8C6Z,MAA9C,EAAsD;AAClD,QAAMoJ,aAAa,GAAG,EAAtB;AACA,QAAMC,SAAS,GAAGjK,SAAS,CAAClb,MAAD,EAAS;AAChC,KAACmY,UAAU,CAACyG,WAAZ,GAA0BxgB,IAAI,IAAI;AAC9B,UAAIA,IAAI,CAACzE,IAAL,KAAcsI,QAAlB,EAA4B;AACxB,cAAMgW,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,cAAM8D,sBAAsB,GAAGpF,MAAM,CAACzW,MAAtC;AACA,cAAM8b,iBAAiB,GAAG,EAA1B;;AACA,aAAK,MAAMnb,SAAX,IAAwBkb,sBAAxB,EAAgD;AAC5C,gBAAME,mBAAmB,GAAGF,sBAAsB,CAAClb,SAAD,CAAlD;;AACA,cAAI2Z,MAAM,CAAC3Z,SAAD,EAAYob,mBAAZ,CAAV,EAA4C;AACxC2H,YAAAA,aAAa,CAAC/iB,SAAD,CAAb,GAA2Bob,mBAA3B;AACH,WAFD,MAGK;AACDD,YAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+Bob,mBAA/B;AACH;AACJ;;AACD,eAAOV,eAAe,CAAC,IAAI3lB,iBAAJ,CAAsB,EACzC,GAAG+gB,MADsC;AAEzCzW,UAAAA,MAAM,EAAE8b;AAFiC,SAAtB,CAAD,CAAtB;AAIH;AACJ;AApB+B,GAAT,CAA3B;AAsBA,SAAO,CAAC6H,SAAD,EAAYD,aAAZ,CAAP;AACH;;AACD,SAASE,kBAAT,CAA4BplB,MAA5B,EAAoCiC,QAApC,EAA8C6Z,MAA9C,EAAsD;AAClD,QAAM3F,cAAc,GAAG,EAAvB;AACA+E,EAAAA,SAAS,CAAClb,MAAD,EAAS;AACd,KAACmY,UAAU,CAACyG,WAAZ,GAA0BxgB,IAAI,IAAI;AAC9B,UAAIA,IAAI,CAACzE,IAAL,KAAcsI,QAAlB,EAA4B;AACxB,cAAMgW,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,cAAM8D,sBAAsB,GAAGpF,MAAM,CAACzW,MAAtC;;AACA,aAAK,MAAMW,SAAX,IAAwBkb,sBAAxB,EAAgD;AAC5C,gBAAME,mBAAmB,GAAGF,sBAAsB,CAAClb,SAAD,CAAlD;;AACA,cAAI2Z,MAAM,CAAC3Z,SAAD,EAAYob,mBAAZ,CAAV,EAA4C;AACxCpH,YAAAA,cAAc,CAAChU,SAAD,CAAd,GAA4Bob,mBAA5B;AACH;AACJ;AACJ;;AACD,aAAO9e,SAAP;AACH;AAba,GAAT,CAAT;AAeA,SAAO0X,cAAP;AACH;;AACD,SAASkP,kBAAT,CAA4BrlB,MAA5B,EAAoCiC,QAApC,EAA8C6Z,MAA9C,EAAsDwJ,SAAtD,EAAiE;AAC7D,QAAMJ,aAAa,GAAG,EAAtB;AACA,QAAMC,SAAS,GAAGjK,SAAS,CAAClb,MAAD,EAAS;AAChC,KAACmY,UAAU,CAACyG,WAAZ,GAA0BxgB,IAAI,IAAI;AAC9B,UAAIA,IAAI,CAACzE,IAAL,KAAcsI,QAAlB,EAA4B;AACxB,cAAMgW,MAAM,GAAG7Z,IAAI,CAACmb,QAAL,EAAf;AACA,cAAM8D,sBAAsB,GAAGpF,MAAM,CAACzW,MAAtC;AACA,cAAM8b,iBAAiB,GAAG,EAA1B;;AACA,aAAK,MAAMnb,SAAX,IAAwBkb,sBAAxB,EAAgD;AAC5C,gBAAME,mBAAmB,GAAGF,sBAAsB,CAAClb,SAAD,CAAlD;;AACA,cAAI2Z,MAAM,CAAC3Z,SAAD,EAAYob,mBAAZ,CAAV,EAA4C;AACxC2H,YAAAA,aAAa,CAAC/iB,SAAD,CAAb,GAA2Bob,mBAA3B;AACH,WAFD,MAGK;AACDD,YAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+Bob,mBAA/B;AACH;AACJ;;AACD,aAAK,MAAMpb,SAAX,IAAwBmjB,SAAxB,EAAmC;AAC/B,gBAAMxF,WAAW,GAAGwF,SAAS,CAACnjB,SAAD,CAA7B;AACAmb,UAAAA,iBAAiB,CAACnb,SAAD,CAAjB,GAA+B2d,WAA/B;AACH;;AACD,eAAOjD,eAAe,CAAC,IAAI3lB,iBAAJ,CAAsB,EACzC,GAAG+gB,MADsC;AAEzCzW,UAAAA,MAAM,EAAE8b;AAFiC,SAAtB,CAAD,CAAtB;AAIH;AACJ;AAxB+B,GAAT,CAA3B;AA0BA,SAAO,CAAC6H,SAAD,EAAYD,aAAZ,CAAP;AACH;;AAED,SAASK,UAAT,CAAoBnnB,IAApB,EAA0BonB,WAA1B,EAAuC;AACnC,MAAInwB,YAAY,CAAC+I,IAAD,CAAhB,EAAwB;AACpB,WAAO,IAAIlH,iBAAJ,CAAsB,EACzB,GAAGkH,IAAI,CAACmb,QAAL,EADsB;AAEzB5f,MAAAA,IAAI,EAAE6rB,WAFmB;AAGzBnlB,MAAAA,OAAO,EAAEjC,IAAI,CAACiC,OAAL,IAAgB,IAAhB,GACHjC,IAAI,CAACiC,OADF,GAEH,EACE,GAAGjC,IAAI,CAACiC,OADV;AAEE1G,QAAAA,IAAI,EAAE,EACF,GAAGyE,IAAI,CAACiC,OAAL,CAAa1G,IADd;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAFR,OALmB;AAYzBllB,MAAAA,iBAAiB,EAAElC,IAAI,CAACkC,iBAAL,IAA0B,IAA1B,GACblC,IAAI,CAACkC,iBADQ,GAEblC,IAAI,CAACkC,iBAAL,CAAuB7D,GAAvB,CAA2BiB,IAAI,KAAK,EAClC,GAAGA,IAD+B;AAElC/D,QAAAA,IAAI,EAAE,EACF,GAAG+D,IAAI,CAAC/D,IADN;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAF4B,OAAL,CAA/B;AAdmB,KAAtB,CAAP;AAsBH,GAvBD,MAwBK,IAAI7vB,eAAe,CAACyI,IAAD,CAAnB,EAA2B;AAC5B,WAAO,IAAIjH,oBAAJ,CAAyB,EAC5B,GAAGiH,IAAI,CAACmb,QAAL,EADyB;AAE5B5f,MAAAA,IAAI,EAAE6rB,WAFsB;AAG5BnlB,MAAAA,OAAO,EAAEjC,IAAI,CAACiC,OAAL,IAAgB,IAAhB,GACHjC,IAAI,CAACiC,OADF,GAEH,EACE,GAAGjC,IAAI,CAACiC,OADV;AAEE1G,QAAAA,IAAI,EAAE,EACF,GAAGyE,IAAI,CAACiC,OAAL,CAAa1G,IADd;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAFR,OALsB;AAY5BllB,MAAAA,iBAAiB,EAAElC,IAAI,CAACkC,iBAAL,IAA0B,IAA1B,GACblC,IAAI,CAACkC,iBADQ,GAEblC,IAAI,CAACkC,iBAAL,CAAuB7D,GAAvB,CAA2BiB,IAAI,KAAK,EAClC,GAAGA,IAD+B;AAElC/D,QAAAA,IAAI,EAAE,EACF,GAAG+D,IAAI,CAAC/D,IADN;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAF4B,OAAL,CAA/B;AAdsB,KAAzB,CAAP;AAsBH,GAvBI,MAwBA,IAAI5vB,WAAW,CAACwI,IAAD,CAAf,EAAuB;AACxB,WAAO,IAAI9G,gBAAJ,CAAqB,EACxB,GAAG8G,IAAI,CAACmb,QAAL,EADqB;AAExB5f,MAAAA,IAAI,EAAE6rB,WAFkB;AAGxBnlB,MAAAA,OAAO,EAAEjC,IAAI,CAACiC,OAAL,IAAgB,IAAhB,GACHjC,IAAI,CAACiC,OADF,GAEH,EACE,GAAGjC,IAAI,CAACiC,OADV;AAEE1G,QAAAA,IAAI,EAAE,EACF,GAAGyE,IAAI,CAACiC,OAAL,CAAa1G,IADd;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAFR,OALkB;AAYxBllB,MAAAA,iBAAiB,EAAElC,IAAI,CAACkC,iBAAL,IAA0B,IAA1B,GACblC,IAAI,CAACkC,iBADQ,GAEblC,IAAI,CAACkC,iBAAL,CAAuB7D,GAAvB,CAA2BiB,IAAI,KAAK,EAClC,GAAGA,IAD+B;AAElC/D,QAAAA,IAAI,EAAE,EACF,GAAG+D,IAAI,CAAC/D,IADN;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAF4B,OAAL,CAA/B;AAdkB,KAArB,CAAP;AAsBH,GAvBI,MAwBA,IAAI3vB,iBAAiB,CAACuI,IAAD,CAArB,EAA6B;AAC9B,WAAO,IAAIhH,sBAAJ,CAA2B,EAC9B,GAAGgH,IAAI,CAACmb,QAAL,EAD2B;AAE9B5f,MAAAA,IAAI,EAAE6rB,WAFwB;AAG9BnlB,MAAAA,OAAO,EAAEjC,IAAI,CAACiC,OAAL,IAAgB,IAAhB,GACHjC,IAAI,CAACiC,OADF,GAEH,EACE,GAAGjC,IAAI,CAACiC,OADV;AAEE1G,QAAAA,IAAI,EAAE,EACF,GAAGyE,IAAI,CAACiC,OAAL,CAAa1G,IADd;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAFR,OALwB;AAY9BllB,MAAAA,iBAAiB,EAAElC,IAAI,CAACkC,iBAAL,IAA0B,IAA1B,GACblC,IAAI,CAACkC,iBADQ,GAEblC,IAAI,CAACkC,iBAAL,CAAuB7D,GAAvB,CAA2BiB,IAAI,KAAK,EAClC,GAAGA,IAD+B;AAElC/D,QAAAA,IAAI,EAAE,EACF,GAAG+D,IAAI,CAAC/D,IADN;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAF4B,OAAL,CAA/B;AAdwB,KAA3B,CAAP;AAsBH,GAvBI,MAwBA,IAAI1vB,UAAU,CAACsI,IAAD,CAAd,EAAsB;AACvB,WAAO,IAAI7G,eAAJ,CAAoB,EACvB,GAAG6G,IAAI,CAACmb,QAAL,EADoB;AAEvB5f,MAAAA,IAAI,EAAE6rB,WAFiB;AAGvBnlB,MAAAA,OAAO,EAAEjC,IAAI,CAACiC,OAAL,IAAgB,IAAhB,GACHjC,IAAI,CAACiC,OADF,GAEH,EACE,GAAGjC,IAAI,CAACiC,OADV;AAEE1G,QAAAA,IAAI,EAAE,EACF,GAAGyE,IAAI,CAACiC,OAAL,CAAa1G,IADd;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAFR,OALiB;AAYvBllB,MAAAA,iBAAiB,EAAElC,IAAI,CAACkC,iBAAL,IAA0B,IAA1B,GACblC,IAAI,CAACkC,iBADQ,GAEblC,IAAI,CAACkC,iBAAL,CAAuB7D,GAAvB,CAA2BiB,IAAI,KAAK,EAClC,GAAGA,IAD+B;AAElC/D,QAAAA,IAAI,EAAE,EACF,GAAG+D,IAAI,CAAC/D,IADN;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAF4B,OAAL,CAA/B;AAdiB,KAApB,CAAP;AAsBH,GAvBI,MAwBA,IAAIzvB,YAAY,CAACqI,IAAD,CAAhB,EAAwB;AACzB,WAAO,IAAI5G,iBAAJ,CAAsB,EACzB,GAAG4G,IAAI,CAACmb,QAAL,EADsB;AAEzB5f,MAAAA,IAAI,EAAE6rB,WAFmB;AAGzBnlB,MAAAA,OAAO,EAAEjC,IAAI,CAACiC,OAAL,IAAgB,IAAhB,GACHjC,IAAI,CAACiC,OADF,GAEH,EACE,GAAGjC,IAAI,CAACiC,OADV;AAEE1G,QAAAA,IAAI,EAAE,EACF,GAAGyE,IAAI,CAACiC,OAAL,CAAa1G,IADd;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAFR,OALmB;AAYzBllB,MAAAA,iBAAiB,EAAElC,IAAI,CAACkC,iBAAL,IAA0B,IAA1B,GACblC,IAAI,CAACkC,iBADQ,GAEblC,IAAI,CAACkC,iBAAL,CAAuB7D,GAAvB,CAA2BiB,IAAI,KAAK,EAClC,GAAGA,IAD+B;AAElC/D,QAAAA,IAAI,EAAE,EACF,GAAG+D,IAAI,CAAC/D,IADN;AAEFE,UAAAA,KAAK,EAAE2rB;AAFL;AAF4B,OAAL,CAA/B;AAdmB,KAAtB,CAAP;AAsBH;;AACD,QAAM,IAAIjrB,KAAJ,CAAW,gBAAe6D,IAAK,GAA/B,CAAN;AACH;AAED;AACA;AACA;AACA;;;AACA,SAASqnB,gBAAT,CAA0BC,QAA1B,EAAoCC,QAApC,EAA8CC,cAA9C,EAA8D;AAC1D,MAAIC,OAAJ;AACA,MAAIC,WAAJ;;AACA,MAAI,OAAOJ,QAAQ,CAACK,MAAhB,KAA2B,UAA/B,EAA2C;AACvCF,IAAAA,OAAO,GAAGH,QAAQ,CAACK,MAAnB;;AACAD,IAAAA,WAAW,GAAI9qB,KAAD,IAAW;AACrB,YAAMgrB,OAAO,GAAG,MAAMzZ,OAAO,CAAC0Z,MAAR,CAAejrB,KAAf,CAAtB;;AACA,aAAO6qB,OAAO,CAACvoB,IAAR,CAAaooB,QAAb,EAAuBQ,IAAvB,CAA4BF,OAA5B,EAAqCA,OAArC,CAAP;AACH,KAHD;AAIH;;AACD,WAASG,SAAT,CAAmB5lB,MAAnB,EAA2B;AACvB,WAAOA,MAAM,CAAC6lB,IAAP,GAAc7lB,MAAd,GAAuB8lB,aAAa,CAAC9lB,MAAM,CAAC1G,KAAR,EAAe8rB,QAAf,CAAb,CAAsCO,IAAtC,CAA2CI,cAA3C,EAA2DR,WAA3D,CAA9B;AACH;;AACD,MAAIS,SAAJ;;AACA,MAAIX,cAAJ,EAAoB;AAChB;AACA,UAAMK,MAAM,GAAGL,cAAf;;AACAW,IAAAA,SAAS,GAAIvrB,KAAD,IAAWqrB,aAAa,CAACrrB,KAAD,EAAQirB,MAAR,CAAb,CAA6BC,IAA7B,CAAkCI,cAAlC,EAAkDR,WAAlD,CAAvB;AACH;;AACD,SAAO;AACH3R,IAAAA,IAAI,GAAG;AACH,aAAOuR,QAAQ,CAACvR,IAAT,GAAgB+R,IAAhB,CAAqBC,SAArB,EAAgCI,SAAhC,CAAP;AACH,KAHE;;AAIHR,IAAAA,MAAM,GAAG;AACL,aAAOF,OAAO,GACRA,OAAO,CAACvoB,IAAR,CAAaooB,QAAb,EAAuBQ,IAAvB,CAA4BC,SAA5B,EAAuCI,SAAvC,CADQ,GAERha,OAAO,CAACgW,OAAR,CAAgB;AAAE1oB,QAAAA,KAAK,EAAE4E,SAAT;AAAoB2nB,QAAAA,IAAI,EAAE;AAA1B,OAAhB,CAFN;AAGH,KARE;;AASHI,IAAAA,KAAK,CAACxrB,KAAD,EAAQ;AACT,UAAI,OAAO0qB,QAAQ,CAACc,KAAhB,KAA0B,UAA9B,EAA0C;AACtC,eAAOd,QAAQ,CAACc,KAAT,CAAexrB,KAAf,EAAsBkrB,IAAtB,CAA2BC,SAA3B,EAAsCI,SAAtC,CAAP;AACH;;AACD,aAAOha,OAAO,CAAC0Z,MAAR,CAAejrB,KAAf,EAAsByrB,KAAtB,CAA4BX,WAA5B,CAAP;AACH,KAdE;;AAeH,KAACY,MAAM,CAACC,aAAR,IAAyB;AACrB,aAAO,IAAP;AACH;;AAjBE,GAAP;AAmBH;;AACD,SAASN,aAAT,CAAuBxsB,KAAvB,EAA8B8rB,QAA9B,EAAwC;AACpC,SAAO,IAAIpZ,OAAJ,CAAYgW,OAAO,IAAIA,OAAO,CAACoD,QAAQ,CAAC9rB,KAAD,CAAT,CAA9B,CAAP;AACH;;AACD,SAASysB,cAAT,CAAwBzsB,KAAxB,EAA+B;AAC3B,SAAO;AAAEA,IAAAA,KAAF;AAASusB,IAAAA,IAAI,EAAE;AAAf,GAAP;AACH;;AAED,SAASQ,cAAT,CAAwB5oB,aAAxB,EAAuC6oB,sBAAvC,EAA+DlpB,cAA/D,EAA+EwN,OAA/E,EAAwF2b,OAAxF,EAAiG1oB,IAAjG,EAAuGvE,KAAvG,EAA8G;AAC1GmE,EAAAA,aAAa,CAACmN,OAAD,CAAb,GAAyB;AACrBrR,IAAAA,IAAI,EAAE5E,IAAI,CAACmW,QADU;AAErB1R,IAAAA,IAAI,EAAE;AACFG,MAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,MAAAA,KAAK,EAAEsR;AAFL,KAFe;AAMrBtR,IAAAA,KAAK,EAAE;AACHC,MAAAA,IAAI,EAAE5E,IAAI,CAAC2J,QADR;AAEHlF,MAAAA,IAAI,EAAE;AACFG,QAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,QAAAA,KAAK,EAAEitB;AAFL;AAFH;AANc,GAAzB;AAcAD,EAAAA,sBAAsB,CAACC,OAAD,CAAtB,GAAkC;AAC9BhtB,IAAAA,IAAI,EAAE5E,IAAI,CAACwiB,mBADmB;AAE9B9G,IAAAA,QAAQ,EAAE;AACN9W,MAAAA,IAAI,EAAE5E,IAAI,CAAC2J,QADL;AAENlF,MAAAA,IAAI,EAAE;AACFG,QAAAA,IAAI,EAAE5E,IAAI,CAACmO,IADT;AAEFxJ,QAAAA,KAAK,EAAEitB;AAFL;AAFA,KAFoB;AAS9B1oB,IAAAA,IAAI,EAAE2E,WAAW,CAAC3E,IAAD;AATa,GAAlC;;AAWA,MAAIvE,KAAK,KAAK4E,SAAd,EAAyB;AACrBd,IAAAA,cAAc,CAACmpB,OAAD,CAAd,GAA0BjtB,KAA1B;AACA;AACH,GA7ByG,CA8B1G;AACA;AACA;;;AACA,MAAIitB,OAAO,IAAInpB,cAAf,EAA+B;AAC3B,WAAOA,cAAc,CAACmpB,OAAD,CAArB;AACH;AACJ;;AACD,SAASC,2BAAT,CAAqCC,qBAArC,EAA4D;AACxD,MAAIC,UAAU,GAAG,CAAjB;AACA,SAAQ9b,OAAD,IAAa;AAChB,QAAI2b,OAAJ;;AACA,OAAG;AACCA,MAAAA,OAAO,GAAI,KAAI,CAACG,UAAU,EAAX,EAAevrB,QAAf,EAA0B,IAAGyP,OAAQ,EAApD;AACH,KAFD,QAES2b,OAAO,IAAIE,qBAFpB;;AAGA,WAAOF,OAAP;AACH,GAND;AAOH;;AAED,SAASI,sBAAT,CAAgClnB,MAAhC,EAAwCmnB,KAAxC,EAA+CC,KAA/C,EAAsD;AAClD,MAAIA,KAAK,IAAI,IAAT,IAAiBD,KAAK,IAAI,IAA9B,EAAoC;AAChC,WAAO,KAAP;AACH,GAFD,MAGK,IAAIA,KAAK,KAAKC,KAAd,EAAqB;AACtB,WAAO,IAAP;AACH,GAFI,MAGA,IAAItvB,eAAe,CAACqvB,KAAD,CAAf,IAA0BrvB,eAAe,CAACsvB,KAAD,CAA7C,EAAsD;AACvD,WAAOrvB,cAAc,CAACiI,MAAD,EAASmnB,KAAT,EAAgBC,KAAhB,CAArB;AACH;;AACD,SAAO,KAAP;AACH;;AAED,SAASC,cAAT,CAAwBC,aAAxB,EAAuC1Y,IAAvC,EAA6C;AACzC,SAAO,IAAI5Z,YAAJ,CAAiBsyB,aAAa,CAAChtB,OAA/B,EAAwCgtB,aAAa,CAACxf,KAAtD,EAA6Dwf,aAAa,CAACnD,MAA3E,EAAmFmD,aAAa,CAACC,SAAjG,EAA4G3Y,IAAI,KAAK,IAAT,GAAgBnQ,SAAhB,GAA4BmQ,IAAI,KAAKnQ,SAAT,GAAqB6oB,aAAa,CAAC1Y,IAAnC,GAA0CA,IAAlL,EAAwL0Y,aAAa,CAACA,aAAtM,EAAqNA,aAAa,CAACloB,UAAnO,CAAP;AACH;;AAED,SAASooB,yBAAT,CAAmCC,UAAnC,EAA+C;AAC3C,QAAMC,SAAS,GAAG,EAAlB;AACA,QAAMC,SAAS,GAAG,EAAlB;AACA,MAAIC,SAAS,GAAG,IAAhB;;AACA,QAAMC,SAAS,GAAIhuB,KAAD,IAAW;AACzB,QAAI6tB,SAAS,CAACprB,MAAV,KAAqB,CAAzB,EAA4B;AACxB;AACAorB,MAAAA,SAAS,CAAC/S,KAAV,GAAkB;AAAE9a,QAAAA,KAAF;AAASusB,QAAAA,IAAI,EAAE;AAAf,OAAlB;AACH,KAHD,MAIK;AACDuB,MAAAA,SAAS,CAACxqB,IAAV,CAAe;AAAEtD,QAAAA,KAAF;AAASusB,QAAAA,IAAI,EAAE;AAAf,OAAf;AACH;AACJ,GARD;;AASA,QAAM0B,SAAS,GAAI9sB,KAAD,IAAW;AACzB,QAAI0sB,SAAS,CAACprB,MAAV,KAAqB,CAAzB,EAA4B;AACxB;AACAorB,MAAAA,SAAS,CAAC/S,KAAV,GAAkB;AAAE9a,QAAAA,KAAK,EAAE;AAAEgB,UAAAA,MAAM,EAAE,CAACG,KAAD;AAAV,SAAT;AAA8BorB,QAAAA,IAAI,EAAE;AAApC,OAAlB;AACH,KAHD,MAIK;AACDuB,MAAAA,SAAS,CAACxqB,IAAV,CAAe;AAAEtD,QAAAA,KAAK,EAAE;AAAEgB,UAAAA,MAAM,EAAE,CAACG,KAAD;AAAV,SAAT;AAA8BorB,QAAAA,IAAI,EAAE;AAApC,OAAf;AACH;AACJ,GARD;;AASA,QAAM2B,QAAQ,GAAG,MAAM;AACnB,QAAIL,SAAS,CAACprB,MAAV,KAAqB,CAAzB,EAA4B;AACxB;AACAorB,MAAAA,SAAS,CAAC/S,KAAV,GAAkB;AAAEyR,QAAAA,IAAI,EAAE;AAAR,OAAlB;AACH,KAHD,MAIK;AACDuB,MAAAA,SAAS,CAACxqB,IAAV,CAAe;AAAEipB,QAAAA,IAAI,EAAE;AAAR,OAAf;AACH;AACJ,GARD;;AASA,QAAM4B,SAAS,GAAG,MAAM,IAAIzb,OAAJ,CAAYgW,OAAO,IAAI;AAC3C,QAAIoF,SAAS,CAACrrB,MAAV,KAAqB,CAAzB,EAA4B;AACxB,YAAM2rB,OAAO,GAAGN,SAAS,CAAChT,KAAV,EAAhB,CADwB,CAExB;;AACA4N,MAAAA,OAAO,CAAC0F,OAAD,CAAP;AACH,KAJD,MAKK;AACDP,MAAAA,SAAS,CAACvqB,IAAV,CAAeolB,OAAf;AACH;AACJ,GATuB,CAAxB;;AAUA,QAAM1G,YAAY,GAAG4L,UAAU,CAACnF,SAAX,CAAqB;AACtCnO,IAAAA,IAAI,CAACta,KAAD,EAAQ;AACRguB,MAAAA,SAAS,CAAChuB,KAAD,CAAT;AACH,KAHqC;;AAItCmB,IAAAA,KAAK,CAACktB,GAAD,EAAM;AACPJ,MAAAA,SAAS,CAACI,GAAD,CAAT;AACH,KANqC;;AAOtCC,IAAAA,QAAQ,GAAG;AACPJ,MAAAA,QAAQ;AACX;;AATqC,GAArB,CAArB;;AAWA,QAAMK,UAAU,GAAG,MAAM;AACrB,QAAIR,SAAJ,EAAe;AACXA,MAAAA,SAAS,GAAG,KAAZ;AACA/L,MAAAA,YAAY,CAACwM,WAAb;;AACA,WAAK,MAAM9F,OAAX,IAAsBmF,SAAtB,EAAiC;AAC7BnF,QAAAA,OAAO,CAAC;AAAE1oB,UAAAA,KAAK,EAAE4E,SAAT;AAAoB2nB,UAAAA,IAAI,EAAE;AAA1B,SAAD,CAAP;AACH;;AACDsB,MAAAA,SAAS,CAACprB,MAAV,GAAmB,CAAnB;AACAqrB,MAAAA,SAAS,CAACrrB,MAAV,GAAmB,CAAnB;AACH;AACJ,GAVD;;AAWA,SAAO;AACH6X,IAAAA,IAAI,GAAG;AACH;AACA,aAAOyT,SAAS,GAAGI,SAAS,EAAZ,GAAiB,KAAKjC,MAAL,EAAjC;AACH,KAJE;;AAKHA,IAAAA,MAAM,GAAG;AACLqC,MAAAA,UAAU;AACV,aAAO7b,OAAO,CAACgW,OAAR,CAAgB;AAAE1oB,QAAAA,KAAK,EAAE4E,SAAT;AAAoB2nB,QAAAA,IAAI,EAAE;AAA1B,OAAhB,CAAP;AACH,KARE;;AASHI,IAAAA,KAAK,CAACxrB,KAAD,EAAQ;AACTotB,MAAAA,UAAU;AACV,aAAO7b,OAAO,CAAC0Z,MAAR,CAAejrB,KAAf,CAAP;AACH,KAZE;;AAaH,KAAC0rB,MAAM,CAACC,aAAR,IAAyB;AACrB,aAAO,IAAP;AACH;;AAfE,GAAP;AAiBH;;AAED,SAAS2B,2BAAT,CAAqC5mB,YAArC,EAAmD8U,aAAnD,EAAkE;AAC9D,QAAM+R,GAAG,GAAGvwB,eAAe,CAAC0J,YAAD,EAAe8U,aAAf,CAA3B;;AACA,MAAI,CAAC+R,GAAL,EAAU;AACN,UAAM,IAAIhuB,KAAJ,CAAW,0BAAyBic,aAAa,IAAI,EAAG,EAAxD,CAAN;AACH;;AACD,SAAO+R,GAAP;AACH;;AACD,MAAMC,0BAA0B,GAAGtkB,QAAQ,CAAC,SAASskB,0BAAT,CAAoCC,OAApC,EAA6C;AACrF,SAAOH,2BAA2B,CAACG,OAAO,CAACxc,QAAT,EAAmBwc,OAAO,CAACjS,aAA3B,CAAlC;AACH,CAF0C,CAA3C,C,CAIA;;AACA,SAASkS,aAAT,CAAuB1oB,MAAvB,EAA+B2oB,SAA/B,EAA0ChrB,cAA1C,EAA0DirB,WAA1D,EAAuElY,YAAvE,EAAqFlP,MAArF,EAA6FqnB,oBAA7F,EAAmH;AAC/G,OAAK,MAAMC,SAAX,IAAwBpY,YAAY,CAACI,UAArC,EAAiD;AAC7C,YAAQgY,SAAS,CAAChvB,IAAlB;AACI,WAAK5E,IAAI,CAACqiB,KAAV;AAAiB;AACb,cAAI,CAACwR,iBAAiB,CAACprB,cAAD,EAAiBmrB,SAAjB,CAAtB,EAAmD;AAC/C;AACH;;AACD,gBAAMnvB,IAAI,GAAGqvB,gBAAgB,CAACF,SAAD,CAA7B;AACA,gBAAMG,SAAS,GAAGznB,MAAM,CAACiD,GAAP,CAAW9K,IAAX,CAAlB;;AACA,cAAIsvB,SAAS,KAAKxqB,SAAlB,EAA6B;AACzBwqB,YAAAA,SAAS,CAAC9rB,IAAV,CAAe2rB,SAAf;AACH,WAFD,MAGK;AACDtnB,YAAAA,MAAM,CAACmD,GAAP,CAAWhL,IAAX,EAAiB,CAACmvB,SAAD,CAAjB;AACH;;AACD;AACH;;AACD,WAAK5zB,IAAI,CAACgiB,eAAV;AAA2B;AACvB,cAAI,CAAC6R,iBAAiB,CAACprB,cAAD,EAAiBmrB,SAAjB,CAAlB,IACA,CAACI,0BAA0B,CAAClpB,MAAD,EAAS8oB,SAAT,EAAoBF,WAApB,CAD/B,EACiE;AAC7D;AACH;;AACDF,UAAAA,aAAa,CAAC1oB,MAAD,EAAS2oB,SAAT,EAAoBhrB,cAApB,EAAoCirB,WAApC,EAAiDE,SAAS,CAACpY,YAA3D,EAAyElP,MAAzE,EAAiFqnB,oBAAjF,CAAb;AACA;AACH;;AACD,WAAK3zB,IAAI,CAACi0B,eAAV;AAA2B;AACvB,gBAAMC,QAAQ,GAAGN,SAAS,CAACnvB,IAAV,CAAeE,KAAhC;;AACA,cAAIgvB,oBAAoB,CAACzR,GAArB,CAAyBgS,QAAzB,KAAsC,CAACL,iBAAiB,CAACprB,cAAD,EAAiBmrB,SAAjB,CAA5D,EAAyF;AACrF;AACH;;AACDD,UAAAA,oBAAoB,CAACQ,GAArB,CAAyBD,QAAzB;AACA,gBAAME,QAAQ,GAAGX,SAAS,CAACS,QAAD,CAA1B;;AACA,cAAI,CAACE,QAAD,IAAa,CAACJ,0BAA0B,CAAClpB,MAAD,EAASspB,QAAT,EAAmBV,WAAnB,CAA5C,EAA6E;AACzE;AACH;;AACDF,UAAAA,aAAa,CAAC1oB,MAAD,EAAS2oB,SAAT,EAAoBhrB,cAApB,EAAoCirB,WAApC,EAAiDU,QAAQ,CAAC5Y,YAA1D,EAAwElP,MAAxE,EAAgFqnB,oBAAhF,CAAb;AACA;AACH;AAnCL;AAqCH;;AACD,SAAOrnB,MAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASunB,iBAAT,CAA2BprB,cAA3B,EAA2CD,IAA3C,EAAiD;AAC7C,QAAM6rB,IAAI,GAAGtxB,kBAAkB,CAACC,oBAAD,EAAuBwF,IAAvB,EAA6BC,cAA7B,CAA/B;;AACA,MAAI,CAAC4rB,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAAC,IAAD,CAAjD,MAA6D,IAAjE,EAAuE;AACnE,WAAO,KAAP;AACH;;AACD,QAAMC,OAAO,GAAGvxB,kBAAkB,CAACE,uBAAD,EAA0BuF,IAA1B,EAAgCC,cAAhC,CAAlC;;AACA,MAAI,CAAC6rB,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC,IAAD,CAA1D,MAAsE,KAA1E,EAAiF;AAC7E,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH;AACD;AACA;AACA;;;AACA,SAASN,0BAAT,CAAoClpB,MAApC,EAA4CspB,QAA5C,EAAsDlrB,IAAtD,EAA4D;AACxD,QAAMqrB,iBAAiB,GAAGH,QAAQ,CAAClY,aAAnC;;AACA,MAAI,CAACqY,iBAAL,EAAwB;AACpB,WAAO,IAAP;AACH;;AACD,QAAMC,eAAe,GAAGtxB,WAAW,CAAC4H,MAAD,EAASypB,iBAAT,CAAnC;;AACA,MAAIC,eAAe,KAAKtrB,IAAxB,EAA8B;AAC1B,WAAO,IAAP;AACH;;AACD,MAAI/F,cAAc,CAACqxB,eAAD,CAAlB,EAAqC;AACjC,UAAMC,aAAa,GAAG3pB,MAAM,CAAC4pB,gBAAP,CAAwBF,eAAxB,CAAtB;AACA,WAAOC,aAAa,CAAC7tB,QAAd,CAAuBsC,IAAvB,CAAP;AACH;;AACD,SAAO,KAAP;AACH;AACD;AACA;AACA;;;AACA,SAAS4qB,gBAAT,CAA0BtrB,IAA1B,EAAgC;AAC5B,SAAOA,IAAI,CAAC9D,KAAL,GAAa8D,IAAI,CAAC9D,KAAL,CAAWC,KAAxB,GAAgC6D,IAAI,CAAC/D,IAAL,CAAUE,KAAjD;AACH;;AACD,MAAMgwB,gBAAgB,GAAGrkB,QAAQ,CAAC,SAASqkB,gBAAT,CAA0B7pB,MAA1B,EAAkC2oB,SAAlC,EAA6ChrB,cAA7C,EAA6DS,IAA7D,EAAmEsF,UAAnE,EAA+E;AAC7G,QAAMomB,aAAa,GAAG,IAAIvjB,GAAJ,EAAtB;AACA,QAAMsiB,oBAAoB,GAAG,IAAIviB,GAAJ,EAA7B;;AACA,OAAK,MAAMyjB,SAAX,IAAwBrmB,UAAxB,EAAoC;AAChC,QAAIqmB,SAAS,CAACrZ,YAAd,EAA4B;AACxBgY,MAAAA,aAAa,CAAC1oB,MAAD,EAAS2oB,SAAT,EAAoBhrB,cAApB,EAAoCS,IAApC,EAA0C2rB,SAAS,CAACrZ,YAApD,EAAkEoZ,aAAlE,EAAiFjB,oBAAjF,CAAb;AACH;AACJ;;AACD,SAAOiB,aAAP;AACH,CATgC,CAAjC;;AAWA,SAASE,SAAT,CAAmBlc,IAAnB,EAAyBmc,KAAzB,EAAgC9Z,KAAhC,EAAuC;AACnC,MAAIxX,KAAK,CAACC,OAAN,CAAckV,IAAd,CAAJ,EAAyB;AACrB,WAAOA,IAAI,CAACrR,GAAL,CAAS5C,KAAK,IAAImwB,SAAS,CAACnwB,KAAD,EAAQowB,KAAR,EAAe9Z,KAAf,CAA3B,CAAP;AACH,GAFD,MAGK,IAAI,OAAOrC,IAAP,KAAgB,QAApB,EAA8B;AAC/B,UAAMoc,OAAO,GAAGD,KAAK,IAAI,IAAT,GAAgBA,KAAK,CAACnc,IAAD,CAArB,GAA8BA,IAA9C;;AACA,QAAIoc,OAAO,IAAI,IAAf,EAAqB;AACjB,WAAK,MAAMxtB,GAAX,IAAkBwtB,OAAlB,EAA2B;AACvB,cAAMrwB,KAAK,GAAGqwB,OAAO,CAACxtB,GAAD,CAArB;AACAL,QAAAA,MAAM,CAACqoB,cAAP,CAAsBwF,OAAtB,EAA+BxtB,GAA/B,EAAoC;AAChC7C,UAAAA,KAAK,EAAEmwB,SAAS,CAACnwB,KAAD,EAAQowB,KAAR,EAAe9Z,KAAf;AADgB,SAApC;AAGH;AACJ;;AACD,WAAOA,KAAK,IAAI,IAAT,GAAgBA,KAAK,CAAC+Z,OAAD,CAArB,GAAiCA,OAAxC;AACH;;AACD,SAAOpc,IAAP;AACH;;AACD,SAASqc,WAAT,CAAqBtvB,MAArB,EAA6BuvB,OAA7B,EAAsC;AAClC,SAAOvvB,MAAM,CAAC4B,GAAP,CAAWzB,KAAK,IAAIovB,OAAO,CAACpvB,KAAD,CAA3B,CAAP;AACH;;AACD,SAASqvB,WAAT,CAAqB9pB,MAArB,EAA6BkoB,OAA7B,EAAsCzoB,MAAtC,EAA8CsqB,gBAA9C,EAAgEC,eAAhE,EAAiF;AAC7E,QAAM5B,SAAS,GAAGF,OAAO,CAACxc,QAAR,CAAiBlK,WAAjB,CAA6BlE,MAA7B,CAAoC,CAACqB,GAAD,EAAMzB,GAAN,KAAc;AAChE,QAAIA,GAAG,CAAC3D,IAAJ,KAAa5E,IAAI,CAACkX,mBAAtB,EAA2C;AACvClN,MAAAA,GAAG,CAACzB,GAAG,CAAC9D,IAAJ,CAASE,KAAV,CAAH,GAAsB4D,GAAtB;AACH;;AACD,WAAOyB,GAAP;AACH,GALiB,EAKf,EALe,CAAlB;AAMA,QAAMvB,cAAc,GAAG8qB,OAAO,CAAC+B,SAAR,IAAqB,EAA5C;AACA,QAAMC,SAAS,GAAG;AACdC,IAAAA,cAAc,EAAE,IAAInkB,GAAJ,EADF;AAEdokB,IAAAA,cAAc,EAAE,IAAIrkB,GAAJ;AAFF,GAAlB;AAIA,QAAMwH,IAAI,GAAGvN,MAAM,CAACuN,IAApB;AACA,QAAMjT,MAAM,GAAG0F,MAAM,CAAC1F,MAAtB;AACA,QAAM+vB,cAAc,GAAG/vB,MAAM,IAAI,IAAV,IAAkB0vB,eAAe,IAAI,IAA5D;AACA,QAAMM,qBAAqB,GAAGrC,0BAA0B,CAACC,OAAD,CAAxD;;AACA,MAAI3a,IAAI,IAAI,IAAR,IAAgB+c,qBAAqB,IAAI,IAA7C,EAAmD;AAC/CtqB,IAAAA,MAAM,CAACuN,IAAP,GAAcgd,SAAS,CAAChd,IAAD,EAAO+c,qBAAP,EAA8B7qB,MAA9B,EAAsC2oB,SAAtC,EAAiDhrB,cAAjD,EAAiE2sB,gBAAjE,EAAmFM,cAAc,GAAG/vB,MAAH,GAAY4D,SAA7G,EAAwHgsB,SAAxH,CAAvB;AACH;;AACD,MAAI5vB,MAAM,IAAI,IAAV,IAAkB0vB,eAAtB,EAAuC;AACnChqB,IAAAA,MAAM,CAAC1F,MAAP,GAAgBkwB,iBAAiB,CAAClwB,MAAD,EAAS0vB,eAAT,EAA0BE,SAA1B,CAAjC;AACH;;AACD,SAAOlqB,MAAP;AACH;;AACD,SAASwqB,iBAAT,CAA2BlwB,MAA3B,EAAmC0vB,eAAnC,EAAoDE,SAApD,EAA+D;AAC3D,QAAMC,cAAc,GAAGD,SAAS,CAACC,cAAjC;AACA,QAAMC,cAAc,GAAGF,SAAS,CAACE,cAAjC;AACA,QAAMK,oBAAoB,GAAGT,eAAe,CAAC,YAAD,CAA5C;AACA,SAAO1vB,MAAM,CAAC4B,GAAP,CAAW6qB,aAAa,IAAI;AAC/B,UAAM2D,gBAAgB,GAAGP,cAAc,CAACjmB,GAAf,CAAmB6iB,aAAnB,CAAzB;AACA,UAAM4D,QAAQ,GAAGD,gBAAgB,IAAI,IAApB,GACX3D,aADW,GAEX2D,gBAAgB,CAACE,WAAjB,CAA6B,CAACjsB,GAAD,EAAMksB,WAAN,KAAsB;AACjD,YAAMnpB,QAAQ,GAAGmpB,WAAW,CAAChtB,IAAZ,CAAiBzE,IAAlC;AACA,YAAM0xB,cAAc,GAAGd,eAAe,CAACtoB,QAAD,CAAtC;;AACA,UAAIopB,cAAc,IAAI,IAAtB,EAA4B;AACxB,eAAOnsB,GAAP;AACH;;AACD,YAAMosB,YAAY,GAAGD,cAAc,CAACD,WAAW,CAACjpB,SAAb,CAAnC;AACA,aAAOmpB,YAAY,IAAI,IAAhB,GAAuBpsB,GAAvB,GAA6BosB,YAAY,CAACpsB,GAAD,EAAMksB,WAAW,CAACG,SAAlB,CAAhD;AACH,KARC,EAQCjE,aARD,CAFN;;AAWA,QAAI0D,oBAAoB,IAAIL,cAAc,CAACvT,GAAf,CAAmBkQ,aAAnB,CAA5B,EAA+D;AAC3D,aAAO0D,oBAAoB,CAACE,QAAD,CAA3B;AACH;;AACD,WAAOA,QAAP;AACH,GAjBM,CAAP;AAkBH;;AACD,SAASJ,SAAT,CAAmBU,IAAnB,EAAyBzlB,SAAzB,EAAoC/F,MAApC,EAA4C2oB,SAA5C,EAAuDhrB,cAAvD,EAAuE2sB,gBAAvE,EAAyFzvB,MAAzF,EAAiG4vB,SAAjG,EAA4G;AACxG,QAAMgB,iBAAiB,GAAGnzB,oBAAoB,CAAC0H,MAAD,EAAS+F,SAAT,CAA9C;AACA,QAAM2lB,eAAe,GAAGhD,aAAa,CAAC1oB,MAAD,EAAS2oB,SAAT,EAAoBhrB,cAApB,EAAoC8tB,iBAApC,EAAuD1lB,SAAS,CAAC2K,YAAjE,EAA+E,IAAInK,GAAJ,EAA/E,EAA0F,IAAID,GAAJ,EAA1F,CAArC;AACA,SAAOqlB,gBAAgB,CAACH,IAAD,EAAOC,iBAAP,EAA0BC,eAA1B,EAA2C1rB,MAA3C,EAAmD2oB,SAAnD,EAA8DhrB,cAA9D,EAA8E2sB,gBAA9E,EAAgG,CAAhG,EAAmGzvB,MAAnG,EAA2G4vB,SAA3G,CAAvB;AACH;;AACD,SAASkB,gBAAT,CAA0BxvB,MAA1B,EAAkCiC,IAAlC,EAAwCwtB,YAAxC,EAAsD5rB,MAAtD,EAA8D2oB,SAA9D,EAAyEhrB,cAAzE,EAAyF2sB,gBAAzF,EAA2GiB,SAA3G,EAAsH1wB,MAAtH,EAA8H4vB,SAA9H,EAAyI;AACrI,QAAM9I,QAAQ,GAAGvjB,IAAI,CAACwL,SAAL,EAAjB;AACA,QAAMyhB,cAAc,GAAGf,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,gBAAgB,CAAClsB,IAAI,CAACzE,IAAN,CAA3G;AACA,QAAMkyB,WAAW,GAAGR,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACS,OAAnG;AACA,QAAMC,SAAS,GAAGF,WAAW,IAAI,IAAf,GAAsBA,WAAW,CAAC1vB,MAAD,CAAjC,GAA4CA,MAA9D;AACA,MAAI6vB,YAAJ;AACA,MAAIC,QAAQ,GAAG,IAAf;;AACA,MAAIpxB,MAAM,IAAI,IAAd,EAAoB;AAChBmxB,IAAAA,YAAY,GAAGE,uBAAuB,CAACrxB,MAAD,EAAS0wB,SAAT,CAAtC;AACAU,IAAAA,QAAQ,GAAGD,YAAY,CAACC,QAAxB;;AACA,SAAK,MAAMjxB,KAAX,IAAoBgxB,YAAY,CAACrB,cAAjC,EAAiD;AAC7CF,MAAAA,SAAS,CAACE,cAAV,CAAyBtB,GAAzB,CAA6BruB,KAA7B;AACH;AACJ;;AACD,OAAK,MAAM,CAACmxB,WAAD,EAAcrC,aAAd,CAAX,IAA2C8B,YAA3C,EAAyD;AACrD,UAAMzpB,SAAS,GAAG2nB,aAAa,CAAC,CAAD,CAAb,CAAiBnwB,IAAjB,CAAsBE,KAAxC;AACA,UAAMuyB,SAAS,GAAGjqB,SAAS,KAAK,YAAd,GAA6B5J,oBAAoB,CAAC6F,IAAlD,GAAyDujB,QAAQ,CAACxf,SAAD,CAAR,CAAoB/D,IAA/F;AACA,UAAMiuB,YAAY,GAAGd,SAAS,GAAG,CAAjC;AACA,QAAIe,WAAJ;;AACA,QAAIL,QAAJ,EAAc;AACVK,MAAAA,WAAW,GAAGL,QAAQ,CAACE,WAAD,CAAtB;;AACA,UAAIG,WAAW,IAAI,IAAnB,EAAyB;AACrB,eAAOL,QAAQ,CAACE,WAAD,CAAf;AACH;;AACDI,MAAAA,kBAAkB,CAACnuB,IAAD,EAAO+D,SAAP,EAAkBkqB,YAAlB,EAAgCC,WAAhC,EAA6C7B,SAA7C,CAAlB;AACH;;AACD,UAAM/lB,QAAQ,GAAG8nB,eAAe,CAACrwB,MAAM,CAACgwB,WAAD,CAAP,EAAsBC,SAAtB,EAAiCtC,aAAjC,EAAgD9pB,MAAhD,EAAwD2oB,SAAxD,EAAmEhrB,cAAnE,EAAmF2sB,gBAAnF,EAAqG+B,YAArG,EAAmHC,WAAnH,EAAgI7B,SAAhI,CAAhC;AACAgC,IAAAA,YAAY,CAACV,SAAD,EAAYI,WAAZ,EAAyBznB,QAAzB,EAAmC2mB,cAAnC,EAAmDlpB,SAAnD,CAAZ;AACH;;AACD,QAAMuqB,WAAW,GAAGX,SAAS,CAACY,UAA9B;;AACA,MAAID,WAAW,IAAI,IAAnB,EAAyB;AACrBD,IAAAA,YAAY,CAACV,SAAD,EAAY,YAAZ,EAA0BW,WAA1B,EAAuCrB,cAAvC,EAAuD,YAAvD,CAAZ;AACH;;AACD,MAAIY,QAAJ,EAAc;AACV,SAAK,MAAMW,SAAX,IAAwBX,QAAxB,EAAkC;AAC9B,YAAMpxB,MAAM,GAAGoxB,QAAQ,CAACW,SAAD,CAAvB;;AACA,WAAK,MAAM5xB,KAAX,IAAoBH,MAApB,EAA4B;AACxB4vB,QAAAA,SAAS,CAACE,cAAV,CAAyBtB,GAAzB,CAA6BruB,KAA7B;AACH;AACJ;AACJ;;AACD,QAAM6xB,WAAW,GAAGxB,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACyB,OAAnG;AACA,SAAOD,WAAW,IAAI,IAAf,GAAsBA,WAAW,CAACd,SAAD,CAAjC,GAA+CA,SAAtD;AACH;;AACD,SAASU,YAAT,CAAsBtwB,MAAtB,EAA8BgwB,WAA9B,EAA2CznB,QAA3C,EAAqD2mB,cAArD,EAAqElpB,SAArE,EAAgF;AAC5E,MAAIkpB,cAAc,IAAI,IAAtB,EAA4B;AACxBlvB,IAAAA,MAAM,CAACgwB,WAAD,CAAN,GAAsBznB,QAAtB;AACA;AACH;;AACD,QAAMqoB,YAAY,GAAG1B,cAAc,CAAClpB,SAAD,CAAnC;;AACA,MAAI4qB,YAAY,IAAI,IAApB,EAA0B;AACtB5wB,IAAAA,MAAM,CAACgwB,WAAD,CAAN,GAAsBznB,QAAtB;AACA;AACH;;AACD,QAAMsoB,YAAY,GAAGD,YAAY,CAACroB,QAAD,CAAjC;;AACA,MAAIsoB,YAAY,KAAKvuB,SAArB,EAAgC;AAC5B,WAAOtC,MAAM,CAACgwB,WAAD,CAAb;AACA;AACH;;AACDhwB,EAAAA,MAAM,CAACgwB,WAAD,CAAN,GAAsBa,YAAtB;AACH;;AACD,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,UAA9B,EAA0CzpB,UAA1C,EAAsD1D,MAAtD,EAA8D2oB,SAA9D,EAAyEhrB,cAAzE,EAAyF2sB,gBAAzF,EAA2GiB,SAA3G,EAAsH1wB,MAAtH,EAA8H4vB,SAA9H,EAAyI;AACrI,SAAOyC,IAAI,CAACzwB,GAAL,CAASke,UAAU,IAAI6R,eAAe,CAAC7R,UAAD,EAAawS,UAAb,EAAyBzpB,UAAzB,EAAqC1D,MAArC,EAA6C2oB,SAA7C,EAAwDhrB,cAAxD,EAAwE2sB,gBAAxE,EAA0FiB,SAAS,GAAG,CAAtG,EAAyG1wB,MAAzG,EAAiH4vB,SAAjH,CAAtC,CAAP;AACH;;AACD,SAAS+B,eAAT,CAAyB3yB,KAAzB,EAAgCszB,UAAhC,EAA4CzpB,UAA5C,EAAwD1D,MAAxD,EAAgE2oB,SAAhE,EAA2EhrB,cAA3E,EAA2F2sB,gBAA3F,EAA6GiB,SAA7G,EAAgJ;AAAA,MAAxB1wB,MAAwB,uEAAf,EAAe;AAAA,MAAX4vB,SAAW;;AAC5I,MAAI5wB,KAAK,IAAI,IAAb,EAAmB;AACf,WAAOA,KAAP;AACH;;AACD,QAAM6gB,YAAY,GAAGhjB,eAAe,CAACy1B,UAAD,CAApC;;AACA,MAAI73B,UAAU,CAAColB,YAAD,CAAd,EAA8B;AAC1B,WAAOuS,cAAc,CAACpzB,KAAD,EAAQ6gB,YAAY,CAACzX,MAArB,EAA6BS,UAA7B,EAAyC1D,MAAzC,EAAiD2oB,SAAjD,EAA4DhrB,cAA5D,EAA4E2sB,gBAA5E,EAA8FiB,SAA9F,EAAyG1wB,MAAzG,EAAiH4vB,SAAjH,CAArB;AACH,GAFD,MAGK,IAAIpyB,cAAc,CAACqiB,YAAD,CAAlB,EAAkC;AACnC,UAAM0S,SAAS,GAAGptB,MAAM,CAACwe,OAAP,CAAe3kB,KAAK,CAAC8yB,UAArB,CAAlB;AACA,UAAMjB,eAAe,GAAG7B,gBAAgB,CAAC7pB,MAAD,EAAS2oB,SAAT,EAAoBhrB,cAApB,EAAoCyvB,SAApC,EAA+C1pB,UAA/C,CAAxC;AACA,WAAOioB,gBAAgB,CAAC9xB,KAAD,EAAQuzB,SAAR,EAAmB1B,eAAnB,EAAoC1rB,MAApC,EAA4C2oB,SAA5C,EAAuDhrB,cAAvD,EAAuE2sB,gBAAvE,EAAyFiB,SAAzF,EAAoG1wB,MAApG,EAA4G4vB,SAA5G,CAAvB;AACH,GAJI,MAKA,IAAIp1B,YAAY,CAACqlB,YAAD,CAAhB,EAAgC;AACjC,UAAMgR,eAAe,GAAG7B,gBAAgB,CAAC7pB,MAAD,EAAS2oB,SAAT,EAAoBhrB,cAApB,EAAoC+c,YAApC,EAAkDhX,UAAlD,CAAxC;AACA,WAAOioB,gBAAgB,CAAC9xB,KAAD,EAAQ6gB,YAAR,EAAsBgR,eAAtB,EAAuC1rB,MAAvC,EAA+C2oB,SAA/C,EAA0DhrB,cAA1D,EAA0E2sB,gBAA1E,EAA4FiB,SAA5F,EAAuG1wB,MAAvG,EAA+G4vB,SAA/G,CAAvB;AACH;;AACD,QAAMY,cAAc,GAAGf,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,gBAAgB,CAAC5P,YAAY,CAAC/gB,IAAd,CAA3G;;AACA,MAAI0xB,cAAc,IAAI,IAAtB,EAA4B;AACxB,WAAOxxB,KAAP;AACH;;AACD,QAAMmzB,YAAY,GAAG3B,cAAc,CAACxxB,KAAD,CAAnC;AACA,SAAOmzB,YAAY,KAAKvuB,SAAjB,GAA6B5E,KAA7B,GAAqCmzB,YAA5C;AACH;;AACD,SAASd,uBAAT,CAAiCrxB,MAAjC,EAAyC0wB,SAAzC,EAAoD;AAChD,MAAI9xB,EAAJ;;AACA,QAAMwyB,QAAQ,GAAG5vB,MAAM,CAAC0c,MAAP,CAAc,IAAd,CAAjB;AACA,QAAM4R,cAAc,GAAG,IAAIrkB,GAAJ,EAAvB;;AACA,OAAK,MAAMtL,KAAX,IAAoBH,MAApB,EAA4B;AACxB,UAAMsE,WAAW,GAAG,CAAC1F,EAAE,GAAGuB,KAAK,CAAC4T,IAAZ,MAAsB,IAAtB,IAA8BnV,EAAE,KAAK,KAAK,CAA1C,GAA8C,KAAK,CAAnD,GAAuDA,EAAE,CAAC8xB,SAAD,CAA7E;;AACA,QAAIpsB,WAAW,IAAI,IAAnB,EAAyB;AACrBwrB,MAAAA,cAAc,CAACtB,GAAf,CAAmBruB,KAAnB;AACA;AACH;;AACD,QAAImE,WAAW,IAAI8sB,QAAnB,EAA6B;AACzBA,MAAAA,QAAQ,CAAC9sB,WAAD,CAAR,CAAsBhC,IAAtB,CAA2BnC,KAA3B;AACH,KAFD,MAGK;AACDixB,MAAAA,QAAQ,CAAC9sB,WAAD,CAAR,GAAwB,CAACnE,KAAD,CAAxB;AACH;AACJ;;AACD,SAAO;AACHixB,IAAAA,QADG;AAEHtB,IAAAA;AAFG,GAAP;AAIH;;AACD,SAAS4B,kBAAT,CAA4BnuB,IAA5B,EAAkC+D,SAAlC,EAA6CopB,SAA7C,EAAgF;AAAA,MAAxB1wB,MAAwB,uEAAf,EAAe;AAAA,MAAX4vB,SAAW;;AAC5E,OAAK,MAAMzvB,KAAX,IAAoBH,MAApB,EAA4B;AACxB,UAAMuwB,WAAW,GAAG;AAChBhtB,MAAAA,IADgB;AAEhB+D,MAAAA,SAFgB;AAGhBopB,MAAAA;AAHgB,KAApB;AAKA,UAAMN,gBAAgB,GAAGR,SAAS,CAACC,cAAV,CAAyBjmB,GAAzB,CAA6BzJ,KAA7B,CAAzB;;AACA,QAAIiwB,gBAAgB,IAAI,IAAxB,EAA8B;AAC1BR,MAAAA,SAAS,CAACC,cAAV,CAAyB/lB,GAAzB,CAA6B3J,KAA7B,EAAoC,CAACowB,WAAD,CAApC;AACH,KAFD,MAGK;AACDH,MAAAA,gBAAgB,CAAC9tB,IAAjB,CAAsBiuB,WAAtB;AACH;AACJ;AACJ;;AAED,SAASiC,oBAAT,CAA8BxzB,KAA9B,EAAqCyzB,QAArC,EAA+C;AAC3C,MAAIzzB,KAAK,IAAI,IAAb,EAAmB;AACf,WAAOA,KAAK,KAAKyzB,QAAjB;AACH,GAFD,MAGK,IAAI30B,KAAK,CAACC,OAAN,CAAciB,KAAd,CAAJ,EAA0B;AAC3B,WAAOlB,KAAK,CAACC,OAAN,CAAc00B,QAAd,KAA2BzzB,KAAK,CAAC0zB,KAAN,CAAY,CAACC,GAAD,EAAMvgB,KAAN,KAAgBogB,oBAAoB,CAACG,GAAD,EAAMF,QAAQ,CAACrgB,KAAD,CAAd,CAAhD,CAAlC;AACH,GAFI,MAGA,IAAI,OAAOpT,KAAP,KAAiB,QAArB,EAA+B;AAChC,WAAQ,OAAOyzB,QAAP,KAAoB,QAApB,IACJA,QADI,IAEJjxB,MAAM,CAACsS,IAAP,CAAY2e,QAAZ,EAAsBC,KAAtB,CAA4BE,YAAY,IAAIJ,oBAAoB,CAACxzB,KAAK,CAAC4zB,YAAD,CAAN,EAAsBH,QAAQ,CAACG,YAAD,CAA9B,CAAhE,CAFJ;AAGH,GAJI,MAKA,IAAIH,QAAQ,YAAYI,MAAxB,EAAgC;AACjC,WAAOJ,QAAQ,CAACt0B,IAAT,CAAca,KAAd,CAAP;AACH;;AACD,SAAOA,KAAK,KAAKyzB,QAAjB;AACH;;AAED,SAASK,eAAT,CAAyB9zB,KAAzB,EAAgC;AAC5B,SAAQ,OAAOA,KAAP,KAAiB,QAAjB,IACJA,KAAK,IAAI,IADL,IAEJ6sB,MAAM,CAACC,aAAP,IAAwB9sB,KAFpB,IAGJ,OAAOA,KAAK,CAAC6sB,MAAM,CAACC,aAAR,CAAZ,KAAuC,UAH3C;AAIH;;AAED,SAASiH,cAAT,CAAwBzxB,MAAxB,EAAgC;AAC5B,SAAOA,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAA5B,IAAwC,UAAUA,MAAlD,IAA4DA,MAAM,CAACrC,IAAP,KAAgB5E,IAAI,CAACyS,QAAxF;AACH;;AAED,SAASkmB,UAAT,CAAoBC,iBAApB,EAAuCC,QAAvC,EAAiD;AAC7C,QAAMpH,aAAa,GAAGmH,iBAAiB,CAACpH,MAAM,CAACC,aAAR,CAAjB,EAAtB;;AACA,MAAI,CAACA,aAAa,CAACZ,MAAnB,EAA2B;AACvBY,IAAAA,aAAa,CAACZ,MAAd,GAAuB,MAAMxZ,OAAO,CAACgW,OAAR,CAAgB;AAAE1oB,MAAAA,KAAK,EAAE4E,SAAT;AAAoB2nB,MAAAA,IAAI,EAAE;AAA1B,KAAhB,CAA7B;AACH;;AACD,QAAM4H,WAAW,GAAGrH,aAAa,CAACZ,MAAd,CAAqBkI,IAArB,CAA0BtH,aAA1B,CAApB;;AACAA,EAAAA,aAAa,CAACZ,MAAd,GAAuB,MAAM;AACzBgI,IAAAA,QAAQ;AACR,WAAOC,WAAW,EAAlB;AACH,GAHD;;AAIA,SAAOrH,aAAP;AACH;;AAED,SAASuH,gBAAT,CAA0BluB,MAA1B,EAAkC2B,OAAlC,EAA2C;AACvC,QAAMsK,QAAQ,GAAGnF,yBAAyB,CAAC9G,MAAD,CAA1C;AACA,SAAOxH,cAAc,CAACyT,QAAD,EAAW,EAC5B,IAAItK,OAAO,IAAI,EAAf;AAD4B,GAAX,CAArB;AAGH;;AACD,SAASwsB,YAAT,CAAsBnuB,MAAtB,EAA8B2B,OAA9B,EAAuC;AACnC;AACA,MAAIysB,kBAAkB,GAAG3vB,SAAzB;;AACA,MAAI,CAACuB,MAAM,CAACK,OAAR,IAAmB,CAACL,MAAM,CAACM,iBAA/B,EAAkD;AAC9C8tB,IAAAA,kBAAkB,GAAGF,gBAAgB,CAACluB,MAAD,EAAS2B,OAAT,CAArC;AACH;;AACD,MAAI,CAAC3B,MAAM,CAACK,OAAR,KAAoB+tB,kBAAkB,KAAK,IAAvB,IAA+BA,kBAAkB,KAAK,KAAK,CAA3D,GAA+D,KAAK,CAApE,GAAwEA,kBAAkB,CAAC/tB,OAA/G,CAAJ,EAA6H;AACzHL,IAAAA,MAAM,CAACK,OAAP,GAAiB+tB,kBAAkB,CAAC/tB,OAApC;AACH;;AACD,MAAI,CAACL,MAAM,CAACM,iBAAR,KAA8B8tB,kBAAkB,KAAK,IAAvB,IAA+BA,kBAAkB,KAAK,KAAK,CAA3D,GAA+D,KAAK,CAApE,GAAwEA,kBAAkB,CAAC/tB,OAAzH,CAAJ,EAAuI;AACnIL,IAAAA,MAAM,CAACM,iBAAP,GAA2B8tB,kBAAkB,CAAC9tB,iBAA9C;AACH;;AACD,SAAON,MAAP;AACH;;AAED,SAASxF,kBAAkB,IAAIE,cAA/B,EAA+Cyd,UAA/C,EAA2DuK,QAA3D,EAAqEqC,kBAArE,EAAyFtsB,OAAzF,EAAkG4B,UAAlG,EAA8GwO,UAA9G,EAA0H3B,gBAA1H,EAA4IO,eAA5I,EAA6J+C,gBAA7J,EAA+KX,YAA/K,EAA6LQ,iBAA7L,EAAgN7C,sBAAhN,EAAwOF,oBAAxO,EAA8PD,iBAA9P,EAAiRK,iBAAjR,EAAoST,aAApS,EAAmTM,gBAAnT,EAAqUjE,mBAArU,EAA0VuS,0BAA1V,EAAsXlJ,qBAAtX,EAA6YyB,cAA7Y,EAA6Zsa,aAA7Z,EAA4amB,gBAA5a,EAA8b9vB,YAA9b,EAA4cX,cAA5c,EAA4dyjB,eAA5d,EAA6ehR,kBAA7e,EAAigB0M,eAAjgB,EAAkhBE,UAAlhB,EAA8hBsO,2BAA9hB,EAA2jBlT,sBAA3jB,EAAmlBuM,YAAnlB,EAAimB+N,YAAjmB,EAA+mB1L,mBAA/mB,EAAooBD,YAApoB,EAAkpBhlB,iBAAlpB,EAAqqBiX,yBAArqB,EAAgsBkE,iBAAhsB,EAAmtBjK,UAAntB,EAA+tB5I,kBAA/tB,EAAmvBuD,6BAAnvB,EAAkxBoK,cAAlxB,EAAkyB/S,YAAlyB,EAAgzBd,wBAAhzB,EAA00ByI,iBAA10B,EAA61BtI,aAA71B,EAA42Bf,yBAA52B,EAAu4B8H,yBAAv4B,EAAk6BrF,uBAAl6B,EAA27BY,oBAA37B,EAAi9BuR,sBAAj9B,EAAy+B0U,2BAAz+B,EAAsgCE,0BAAtgC,EAAkiCxG,sBAAliC,EAA0jC6C,sBAA1jC,EAAklC5e,cAAllC,EAAkmCE,gBAAlmC,EAAonCE,YAApnC,EAAkoC2a,UAAloC,EAA8oCC,SAA9oC,EAAypCiG,sBAAzpC,EAAirC/rB,OAAjrC,EAA0rCJ,gBAA1rC,EAA4sC4yB,eAA5sC,EAA6tCtY,aAA7tC,EAA4uCuY,cAA5uC,EAA4vC90B,gBAA5vC,EAA8wC4f,WAA9wC,EAA2xCve,MAA3xC,EAAmyChB,WAAnyC,EAAgzCsQ,uBAAhzC,EAAy0CoB,iBAAz0C,EAA41CzB,kBAA51C,EAAg3Cqc,gBAAh3C,EAAk4CvK,SAAl4C,EAA64ChX,QAA74C,EAAu5CU,QAAv5C,EAAi6CiB,WAAj6C,EAA86Cb,QAA96C,EAAw7CI,QAAx7C,EAAk8CI,QAAl8C,EAA48Coe,SAA58C,EAAu9CyB,kBAAv9C,EAA2+C7rB,YAA3+C,EAAy/CguB,yBAAz/C,EAAohD7Z,gBAAphD,EAAsiDmH,eAAtiD,EAAujDgG,eAAvjD,EAAwkDE,sBAAxkD,EAAgmD4J,iBAAhmD,EAAmnD/V,YAAnnD,EAAioDjH,yBAAjoD,EAA4pD4L,iBAA5pD,EAA+qDsP,WAA/qD,EAA4rDxU,WAA5rD,EAAysD+Y,cAAzsD,EAAytDpC,kBAAztD,EAA6uDM,UAA7uD,EAAyvDpX,aAAzvD,EAAwwDyK,WAAxwD,EAAqxDwM,kBAArxD,EAAyyDxK,mBAAzyD,EAA8zD7F,+BAA9zD,EAA+1DwF,mBAA/1D,EAAo3DqM,cAAp3D,EAAo4Dlb,wBAAp4D,EAA85D2hB,oBAA95D,EAAo7DrD,SAAp7D,EAA+7DG,WAA/7D,EAA48DE,WAA58D,EAAy9DwD,UAAz9D","sourcesContent":["import { parse, GraphQLError, isNonNullType, Kind, valueFromAST, print, isObjectType, isListType, isSpecifiedDirective, astFromValue, isSpecifiedScalarType, isIntrospectionType, isInterfaceType, isUnionType, isInputObjectType, isEnumType, isScalarType, GraphQLDeprecatedDirective, specifiedRules, concatAST, validate, versionInfo, buildClientSchema, visit, TokenKind, Source, isTypeSystemDefinitionNode, getNamedType, GraphQLString, GraphQLNonNull, GraphQLList, GraphQLID, GraphQLBoolean, GraphQLFloat, GraphQLInt, GraphQLObjectType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLDirective, GraphQLUnionType, GraphQLEnumType, GraphQLScalarType, isNamedType, getNullableType, isLeafType, GraphQLSchema, isDirective, isCompositeType, doTypesOverlap, getOperationAST, getDirectiveValues, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST, isAbstractType, getOperationRootType, TypeNameMetaFieldDef, buildASTSchema } from 'graphql';\n\nconst asArray = (fns) => (Array.isArray(fns) ? fns : fns ? [fns] : []);\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\nfunction isDocumentString(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (invalidDocRegex.test(str)) {\n        return false;\n    }\n    try {\n        parse(str);\n        return true;\n    }\n    catch (e) { }\n    return false;\n}\nconst invalidPathRegex = /[‘“!%&^<=>`]/;\nfunction isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nfunction compareStrings(a, b) {\n    if (String(a) < String(b)) {\n        return -1;\n    }\n    if (String(a) > String(b)) {\n        return 1;\n    }\n    return 0;\n}\nfunction nodeToString(a) {\n    var _a, _b;\n    let name;\n    if ('alias' in a) {\n        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    if (name == null && 'name' in a) {\n        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n    }\n    if (name == null) {\n        name = a.kind;\n    }\n    return name;\n}\nfunction compareNodes(a, b, customFn) {\n    const aStr = nodeToString(a);\n    const bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\nfunction isSome(input) {\n    return input != null;\n}\nfunction assertSome(input, message = 'Value should be something') {\n    if (input == null) {\n        throw new Error(message);\n    }\n}\n\nlet AggregateErrorImpl = globalThis.AggregateError;\nif (typeof AggregateErrorImpl === 'undefined') {\n    class AggregateErrorClass extends Error {\n        constructor(errors, message = '') {\n            super(message);\n            this.errors = errors;\n            this.name = 'AggregateError';\n            Error.captureStackTrace(this, AggregateErrorClass);\n        }\n    }\n    AggregateErrorImpl = function (errors, message) {\n        return new AggregateErrorClass(errors, message);\n    };\n}\nfunction isAggregateError(error) {\n    return 'errors' in error && Array.isArray(error['errors']);\n}\n\n// Taken from graphql-js\n/* eslint-disable @typescript-eslint/ban-types */\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\nfunction inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch (typeof value) {\n        case 'string':\n            return JSON.stringify(value);\n        case 'function':\n            return value.name ? `[function ${value.name}]` : '[function]';\n        case 'object':\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatError(value) {\n    if (value instanceof GraphQLError) {\n        return value.toString();\n    }\n    return `${value.name}: ${value.message};\\n ${value.stack}`;\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (value === null) {\n        return 'null';\n    }\n    if (value instanceof Error) {\n        if (isAggregateError(value)) {\n            return formatError(value) + '\\n' + formatArray(value.errors, previouslySeenValues);\n        }\n        return formatError(value);\n    }\n    if (previouslySeenValues.includes(value)) {\n        return '[Circular]';\n    }\n    const seenValues = [...previouslySeenValues, value];\n    if (isJSONable(value)) {\n        const jsonValue = value.toJSON();\n        // check for infinite recursion\n        if (jsonValue !== value) {\n            return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n        }\n    }\n    else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction isJSONable(value) {\n    return typeof value.toJSON === 'function';\n}\nfunction formatObject(object, seenValues) {\n    const entries = Object.entries(object);\n    if (entries.length === 0) {\n        return '{}';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[' + getObjectTag(object) + ']';\n    }\n    const properties = entries.map(([key, value]) => key + ': ' + formatValue(value, seenValues));\n    return '{ ' + properties.join(', ') + ' }';\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return '[]';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[Array]';\n    }\n    const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n    const remaining = array.length - len;\n    const items = [];\n    for (let i = 0; i < len; ++i) {\n        items.push(formatValue(array[i], seenValues));\n    }\n    if (remaining === 1) {\n        items.push('... 1 more item');\n    }\n    else if (remaining > 1) {\n        items.push(`... ${remaining} more items`);\n    }\n    return '[' + items.join(', ') + ']';\n}\nfunction getObjectTag(object) {\n    const tag = Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object /, '')\n        .replace(/]$/, '');\n    if (tag === 'Object' && typeof object.constructor === 'function') {\n        const name = object.constructor.name;\n        if (typeof name === 'string' && name !== '') {\n            return name;\n        }\n    }\n    return tag;\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getArgumentValues(def, node, variableValues = {}) {\n    var _a;\n    const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({\n        ...prev,\n        [key]: value,\n    }), {});\n    const coercedValues = {};\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n    const argNodeMap = argumentNodes.reduce((prev, arg) => ({\n        ...prev,\n        [arg.name.value]: arg,\n    }), {});\n    for (const { name, type: argType, defaultValue } of def.args) {\n        const argumentNode = argNodeMap[name];\n        if (!argumentNode) {\n            if (defaultValue !== undefined) {\n                coercedValues[name] = defaultValue;\n            }\n            else if (isNonNullType(argType)) {\n                throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n            }\n            continue;\n        }\n        const valueNode = argumentNode.value;\n        let isNull = valueNode.kind === Kind.NULL;\n        if (valueNode.kind === Kind.VARIABLE) {\n            const variableName = valueNode.name.value;\n            if (variableValues == null || !variableMap[variableName]) {\n                if (defaultValue !== undefined) {\n                    coercedValues[name] = defaultValue;\n                }\n                else if (isNonNullType(argType)) {\n                    throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n                        `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n                }\n                continue;\n            }\n            isNull = variableValues[variableName] == null;\n        }\n        if (isNull && isNonNullType(argType)) {\n            throw new GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n        }\n        const coercedValue = valueFromAST(valueNode, argType, variableValues);\n        if (coercedValue === undefined) {\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\n            // execution. This is a runtime check to ensure execution does not\n            // continue with an invalid argument value.\n            throw new GraphQLError(`Argument \"${name}\" has invalid value ${print(valueNode)}.`, valueNode);\n        }\n        coercedValues[name] = coercedValue;\n    }\n    return coercedValues;\n}\n\nfunction getDirectivesInExtensions(node, pathToDirectivesInExtensions = ['directives']) {\n    return pathToDirectivesInExtensions.reduce((acc, pathSegment) => (acc == null ? acc : acc[pathSegment]), node === null || node === void 0 ? void 0 : node.extensions);\n}\nfunction _getDirectiveInExtensions(directivesInExtensions, directiveName) {\n    const directiveInExtensions = directivesInExtensions.filter(directiveAnnotation => directiveAnnotation.name === directiveName);\n    if (!directiveInExtensions.length) {\n        return undefined;\n    }\n    return directiveInExtensions.map(directive => { var _a; return (_a = directive.args) !== null && _a !== void 0 ? _a : {}; });\n}\nfunction getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => (acc == null ? acc : acc[pathSegment]), node === null || node === void 0 ? void 0 : node.extensions);\n    if (directivesInExtensions === undefined) {\n        return undefined;\n    }\n    if (Array.isArray(directivesInExtensions)) {\n        return _getDirectiveInExtensions(directivesInExtensions, directiveName);\n    }\n    // Support condensed format by converting to longer format\n    // The condensed format does not preserve ordering of directives when  repeatable directives are used.\n    // See https://github.com/ardatan/graphql-tools/issues/2534\n    const reformattedDirectivesInExtensions = [];\n    for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {\n        if (Array.isArray(argsOrArrayOfArgs)) {\n            for (const args of argsOrArrayOfArgs) {\n                reformattedDirectivesInExtensions.push({ name, args });\n            }\n        }\n        else {\n            reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });\n        }\n    }\n    return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);\n}\nfunction getDirectives(schema, node, pathToDirectivesInExtensions = ['directives']) {\n    const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n    if (directivesInExtensions != null && directivesInExtensions.length > 0) {\n        return directivesInExtensions;\n    }\n    const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n    const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n        schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n        return schemaDirectiveMap;\n    }, {});\n    let astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = [...astNodes, ...node.extensionASTNodes];\n    }\n    const result = [];\n    for (const astNode of astNodes) {\n        if (astNode.directives) {\n            for (const directiveNode of astNode.directives) {\n                const schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n                if (schemaDirective) {\n                    result.push({ name: directiveNode.name.value, args: getArgumentValues(schemaDirective, directiveNode) });\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);\n    if (directiveInExtensions != null) {\n        return directiveInExtensions;\n    }\n    const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;\n    if (schemaDirective == null) {\n        return undefined;\n    }\n    let astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = [...astNodes, ...node.extensionASTNodes];\n    }\n    const result = [];\n    for (const astNode of astNodes) {\n        if (astNode.directives) {\n            for (const directiveNode of astNode.directives) {\n                if (directiveNode.name.value === directiveName) {\n                    result.push(getArgumentValues(schemaDirective, directiveNode));\n                }\n            }\n        }\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    return result;\n}\n\nfunction parseDirectiveValue(value) {\n    switch (value.kind) {\n        case Kind.INT:\n            return parseInt(value.value);\n        case Kind.FLOAT:\n            return parseFloat(value.value);\n        case Kind.BOOLEAN:\n            return Boolean(value.value);\n        case Kind.STRING:\n        case Kind.ENUM:\n            return value.value;\n        case Kind.LIST:\n            return value.values.map(v => parseDirectiveValue(v));\n        case Kind.OBJECT:\n            return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});\n        case Kind.NULL:\n            return null;\n        default:\n            return null;\n    }\n}\nfunction getFieldsWithDirectives(documentNode, options = {}) {\n    const result = {};\n    let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n    if (options.includeInputTypes) {\n        selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n    }\n    const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n    for (const type of allTypes) {\n        const typeName = type.name.value;\n        if (type.fields == null) {\n            continue;\n        }\n        for (const field of type.fields) {\n            if (field.directives && field.directives.length > 0) {\n                const fieldName = field.name.value;\n                const key = `${typeName}.${fieldName}`;\n                const directives = field.directives.map(d => ({\n                    name: d.name.value,\n                    args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {}),\n                }));\n                result[key] = directives;\n            }\n        }\n    }\n    return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n    const allTypesMap = schema.getTypeMap();\n    const result = [];\n    for (const graphqlTypeName in allTypesMap) {\n        const graphqlType = allTypesMap[graphqlTypeName];\n        if (isObjectType(graphqlType)) {\n            const allInterfaces = graphqlType.getInterfaces();\n            if (allInterfaces.find(int => int.name === interfaceName)) {\n                result.push(graphqlType.name);\n            }\n        }\n    }\n    return result;\n}\n\nfunction astFromType(type) {\n    if (isNonNullType(type)) {\n        const innerType = astFromType(type.ofType);\n        if (innerType.kind === Kind.NON_NULL_TYPE) {\n            throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n        }\n        return {\n            kind: Kind.NON_NULL_TYPE,\n            type: innerType,\n        };\n    }\n    else if (isListType(type)) {\n        return {\n            kind: Kind.LIST_TYPE,\n            type: astFromType(type.ofType),\n        };\n    }\n    return {\n        kind: Kind.NAMED_TYPE,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n    };\n}\n\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\nfunction astFromValueUntyped(value) {\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (Array.isArray(value)) {\n        const valuesNodes = [];\n        for (const item of value) {\n            const itemNode = astFromValueUntyped(item);\n            if (itemNode != null) {\n                valuesNodes.push(itemNode);\n            }\n        }\n        return { kind: Kind.LIST, values: valuesNodes };\n    }\n    if (typeof value === 'object') {\n        const fieldNodes = [];\n        for (const fieldName in value) {\n            const fieldValue = value[fieldName];\n            const ast = astFromValueUntyped(fieldValue);\n            if (ast) {\n                fieldNodes.push({\n                    kind: Kind.OBJECT_FIELD,\n                    name: { kind: Kind.NAME, value: fieldName },\n                    value: ast,\n                });\n            }\n        }\n        return { kind: Kind.OBJECT, fields: fieldNodes };\n    }\n    // Others serialize based on their corresponding JavaScript scalar types.\n    if (typeof value === 'boolean') {\n        return { kind: Kind.BOOLEAN, value };\n    }\n    // JavaScript numbers can be Int or Float values.\n    if (typeof value === 'number' && isFinite(value)) {\n        const stringNum = String(value);\n        return integerStringRegExp.test(stringNum)\n            ? { kind: Kind.INT, value: stringNum }\n            : { kind: Kind.FLOAT, value: stringNum };\n    }\n    if (typeof value === 'string') {\n        return { kind: Kind.STRING, value };\n    }\n    throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n\nfunction memoize1(fn) {\n    const memoize1cache = new WeakMap();\n    return function memoized(a1) {\n        const cachedValue = memoize1cache.get(a1);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1);\n            memoize1cache.set(a1, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize2(fn) {\n    const memoize2cache = new WeakMap();\n    return function memoized(a1, a2) {\n        let cache2 = memoize2cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2cache.set(a1, cache2);\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize3(fn) {\n    const memoize3Cache = new WeakMap();\n    return function memoized(a1, a2, a3) {\n        let cache2 = memoize3Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize3Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        const cachedValue = cache3.get(a3);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize4(fn) {\n    const memoize4Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize4Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize4Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cache4 = cache3.get(a3);\n        if (!cache4) {\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cachedValue = cache4.get(a4);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize5(fn) {\n    const memoize5Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4, a5) {\n        let cache2 = memoize5Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize5Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache4 = cache3.get(a3);\n        if (!cache4) {\n            cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache5 = cache4.get(a4);\n        if (!cache5) {\n            cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        const cachedValue = cache5.get(a5);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nconst memoize2of4cache = new WeakMap();\nfunction memoize2of4(fn) {\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize2of4cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2of4cache.set(a1, cache2);\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\n\nfunction getDefinedRootType(schema, operation) {\n    const rootTypeMap = getRootTypeMap(schema);\n    const rootType = rootTypeMap.get(operation);\n    if (rootType == null) {\n        throw new Error(`Root type for operation \"${operation}\" not defined by the given schema.`);\n    }\n    return rootType;\n}\nconst getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n    const rootTypes = getRootTypes(schema);\n    return new Set([...rootTypes].map(type => type.name));\n});\nconst getRootTypes = memoize1(function getRootTypes(schema) {\n    const rootTypeMap = getRootTypeMap(schema);\n    return new Set(rootTypeMap.values());\n});\nconst getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n    const rootTypeMap = new Map();\n    const queryType = schema.getQueryType();\n    if (queryType) {\n        rootTypeMap.set('query', queryType);\n    }\n    const mutationType = schema.getMutationType();\n    if (mutationType) {\n        rootTypeMap.set('mutation', mutationType);\n    }\n    const subscriptionType = schema.getSubscriptionType();\n    if (subscriptionType) {\n        rootTypeMap.set('subscription', subscriptionType);\n    }\n    return rootTypeMap;\n});\n\nfunction getDocumentNodeFromSchema(schema, options = {}) {\n    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n    const typesMap = schema.getTypeMap();\n    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n    const definitions = schemaNode != null ? [schemaNode] : [];\n    const directives = schema.getDirectives();\n    for (const directive of directives) {\n        if (isSpecifiedDirective(directive)) {\n            continue;\n        }\n        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n    }\n    for (const typeName in typesMap) {\n        const type = typesMap[typeName];\n        const isPredefinedScalar = isSpecifiedScalarType(type);\n        const isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (isObjectType(type)) {\n            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInterfaceType(type)) {\n            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isUnionType(type)) {\n            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInputObjectType(type)) {\n            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isEnumType(type)) {\n            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isScalarType(type)) {\n            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n        }\n        else {\n            throw new Error(`Unknown type ${type}.`);\n        }\n    }\n    return {\n        kind: Kind.DOCUMENT,\n        definitions,\n    };\n}\n// this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\nfunction printSchemaWithDirectives(schema, options = {}) {\n    const documentNode = getDocumentNodeFromSchema(schema, options);\n    return print(documentNode);\n}\nfunction astFromSchema(schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    const operationTypeMap = new Map([\n        ['query', undefined],\n        ['mutation', undefined],\n        ['subscription', undefined],\n    ]);\n    const nodes = [];\n    if (schema.astNode != null) {\n        nodes.push(schema.astNode);\n    }\n    if (schema.extensionASTNodes != null) {\n        for (const extensionASTNode of schema.extensionASTNodes) {\n            nodes.push(extensionASTNode);\n        }\n    }\n    for (const node of nodes) {\n        if (node.operationTypes) {\n            for (const operationTypeDefinitionNode of node.operationTypes) {\n                operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n            }\n        }\n    }\n    const rootTypeMap = getRootTypeMap(schema);\n    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n        const rootType = rootTypeMap.get(operationTypeNode);\n        if (rootType != null) {\n            const rootTypeAST = astFromType(rootType);\n            if (operationTypeDefinitionNode != null) {\n                operationTypeDefinitionNode.type = rootTypeAST;\n            }\n            else {\n                operationTypeMap.set(operationTypeNode, {\n                    kind: Kind.OPERATION_TYPE_DEFINITION,\n                    operation: operationTypeNode,\n                    type: rootTypeAST,\n                });\n            }\n        }\n    }\n    const operationTypes = [...operationTypeMap.values()].filter(isSome);\n    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n    if (!operationTypes.length && !directives.length) {\n        return null;\n    }\n    const schemaNode = {\n        kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,\n        operationTypes,\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n    // This code is so weird because it needs to support GraphQL.js 14\n    // In GraphQL.js 14 there is no `description` value on schemaNode\n    schemaNode.description =\n        ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null)\n            ? {\n                kind: Kind.STRING,\n                value: schema.description,\n                block: true,\n            }\n            : undefined;\n    return schemaNode;\n}\nfunction astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c, _d;\n    return {\n        kind: Kind.DIRECTIVE_DEFINITION,\n        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (directive.description\n            ? {\n                kind: Kind.STRING,\n                value: directive.description,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: directive.name,\n        },\n        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        repeatable: directive.isRepeatable,\n        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map(location => ({\n            kind: Kind.NAME,\n            value: location,\n        }))) || [],\n    };\n}\nfunction getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let nodes = [];\n    if (entity.astNode != null) {\n        nodes.push(entity.astNode);\n    }\n    if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n        nodes = nodes.concat(entity.extensionASTNodes);\n    }\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = [];\n        for (const node of nodes) {\n            if (node.directives) {\n                directives.push(...node.directives);\n            }\n        }\n    }\n    return directives;\n}\nfunction getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    let directiveNodesBesidesDeprecated = [];\n    let deprecatedDirectiveNode = null;\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n    }\n    if (directives != null) {\n        directiveNodesBesidesDeprecated = directives.filter(directive => directive.name.value !== 'deprecated');\n        if (entity.deprecationReason != null) {\n            deprecatedDirectiveNode = (_b = directives.filter(directive => directive.name.value === 'deprecated')) === null || _b === void 0 ? void 0 : _b[0];\n        }\n    }\n    if (entity.deprecationReason != null &&\n        deprecatedDirectiveNode == null) {\n        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n    }\n    return deprecatedDirectiveNode == null\n        ? directiveNodesBesidesDeprecated\n        : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\nfunction astFromArg(arg, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (arg.description\n            ? {\n                kind: Kind.STRING,\n                value: arg.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: arg.name,\n        },\n        type: astFromType(arg.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        defaultValue: arg.defaultValue !== undefined ? (_c = astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,\n        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    const node = {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n    if ('getInterfaces' in type) {\n        node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n    }\n    return node;\n}\nfunction astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.UNION_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n        types: type.getTypes().map(type => astFromType(type)),\n    };\n}\nfunction astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.ENUM_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n    const directives = directivesInExtensions\n        ? makeDirectiveNodes(schema, directivesInExtensions)\n        : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];\n    const specifiedByValue = (type['specifiedByUrl'] || type['specifiedByURL']);\n    if (specifiedByValue && !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n        const specifiedByArgs = {\n            url: specifiedByValue,\n        };\n        directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n    }\n    return {\n        kind: Kind.SCALAR_TYPE_DEFINITION,\n        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : (type.description\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n}\nfunction astFromField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.FIELD_DEFINITION,\n        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (field.description\n            ? {\n                kind: Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromInputField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (field.description\n            ? {\n                kind: Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n        defaultValue: (_c = astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined,\n    };\n}\nfunction astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.ENUM_VALUE_DEFINITION,\n        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (value.description\n            ? {\n                kind: Kind.STRING,\n                value: value.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: value.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction makeDeprecatedDirective(deprecationReason) {\n    return makeDirectiveNode('deprecated', { reason: deprecationReason }, GraphQLDeprecatedDirective);\n}\nfunction makeDirectiveNode(name, args, directive) {\n    const directiveArguments = [];\n    if (directive != null) {\n        for (const arg of directive.args) {\n            const argName = arg.name;\n            const argValue = args[argName];\n            if (argValue !== undefined) {\n                const value = astFromValue(argValue, arg.type);\n                if (value) {\n                    directiveArguments.push({\n                        kind: Kind.ARGUMENT,\n                        name: {\n                            kind: Kind.NAME,\n                            value: argName,\n                        },\n                        value,\n                    });\n                }\n            }\n        }\n    }\n    else {\n        for (const argName in args) {\n            const argValue = args[argName];\n            const value = astFromValueUntyped(argValue);\n            if (value) {\n                directiveArguments.push({\n                    kind: Kind.ARGUMENT,\n                    name: {\n                        kind: Kind.NAME,\n                        value: argName,\n                    },\n                    value,\n                });\n            }\n        }\n    }\n    return {\n        kind: Kind.DIRECTIVE,\n        name: {\n            kind: Kind.NAME,\n            value: name,\n        },\n        arguments: directiveArguments,\n    };\n}\nfunction makeDirectiveNodes(schema, directiveValues) {\n    const directiveNodes = [];\n    for (const directiveName in directiveValues) {\n        const arrayOrSingleValue = directiveValues[directiveName];\n        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n        if (Array.isArray(arrayOrSingleValue)) {\n            for (const value of arrayOrSingleValue) {\n                directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n            }\n        }\n        else {\n            directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n        }\n    }\n    return directiveNodes;\n}\n\nasync function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {\n    const allFragmentMap = new Map();\n    const documentFileObjectsToValidate = [];\n    for (const documentFile of documentFiles) {\n        if (documentFile.document) {\n            const definitionsToValidate = [];\n            for (const definitionNode of documentFile.document.definitions) {\n                if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {\n                    allFragmentMap.set(definitionNode.name.value, definitionNode);\n                }\n                else {\n                    definitionsToValidate.push(definitionNode);\n                }\n            }\n            documentFileObjectsToValidate.push({\n                location: documentFile.location,\n                document: {\n                    kind: Kind.DOCUMENT,\n                    definitions: definitionsToValidate,\n                },\n            });\n        }\n    }\n    const allErrors = [];\n    const allFragmentsDocument = {\n        kind: Kind.DOCUMENT,\n        definitions: [...allFragmentMap.values()],\n    };\n    await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {\n        const documentToValidate = concatAST([allFragmentsDocument, documentFile.document]);\n        const errors = validate(schema, documentToValidate, effectiveRules);\n        if (errors.length > 0) {\n            allErrors.push({\n                filePath: documentFile.location,\n                errors,\n            });\n        }\n    }));\n    return allErrors;\n}\nfunction checkValidationErrors(loadDocumentErrors) {\n    if (loadDocumentErrors.length > 0) {\n        const errors = [];\n        for (const loadDocumentError of loadDocumentErrors) {\n            for (const graphQLError of loadDocumentError.errors) {\n                const error = new Error();\n                error.name = 'GraphQLDocumentError';\n                error.message = `${error.name}: ${graphQLError.message}`;\n                error.stack = error.message;\n                if (graphQLError.locations) {\n                    for (const location of graphQLError.locations) {\n                        error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;\n                    }\n                }\n                errors.push(error);\n            }\n        }\n        throw new AggregateErrorImpl(errors, `GraphQL Document Validation failed with ${errors.length} errors;\n  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join('\\n\\n')}`);\n    }\n}\nfunction createDefaultRules() {\n    let ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n    if (versionInfo.major < 15) {\n        ignored = ignored.map(rule => rule.replace(/Rule$/, ''));\n    }\n    return specifiedRules.filter((f) => !ignored.includes(f.name));\n}\n\nfunction stripBOM(content) {\n    content = content.toString();\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (content.charCodeAt(0) === 0xfeff) {\n        content = content.slice(1);\n    }\n    return content;\n}\nfunction parseBOM(content) {\n    return JSON.parse(stripBOM(content));\n}\nfunction parseGraphQLJSON(location, jsonContent, options) {\n    let parsedJson = parseBOM(jsonContent);\n    if (parsedJson.data) {\n        parsedJson = parsedJson.data;\n    }\n    if (parsedJson.kind === 'Document') {\n        return {\n            location,\n            document: parsedJson,\n        };\n    }\n    else if (parsedJson.__schema) {\n        const schema = buildClientSchema(parsedJson, options);\n        return {\n            location,\n            schema,\n        };\n    }\n    else if (typeof parsedJson === 'string') {\n        return {\n            location,\n            rawSDL: parsedJson,\n        };\n    }\n    throw new Error(`Not valid JSON content`);\n}\n\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction resetComments() {\n    commentsRegistry = {};\n}\nfunction collectComment(node) {\n    var _a;\n    const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n    if (entityName == null) {\n        return;\n    }\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            if (node.values) {\n                for (const value of node.values) {\n                    pushComment(value, entityName, value.name.value);\n                }\n            }\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                for (const field of node.fields) {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        for (const arg of field.arguments) {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}\nfunction pushComment(node, entity, field, argument) {\n    const comment = getComment(node);\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nfunction printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n    var _a;\n    return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        var _a;\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n        const items = [];\n        if (node.kind.includes('Definition') && commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n    const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n    Name: { leave: node => node.value },\n    Variable: { leave: node => '$' + node.name },\n    // Document\n    Document: {\n        leave: node => join(node.definitions, '\\n\\n'),\n    },\n    OperationDefinition: {\n        leave: node => {\n            const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n            const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n            // the query short form.\n            return prefix + ' ' + node.selectionSet;\n        },\n    },\n    VariableDefinition: {\n        leave: ({ variable, type, defaultValue, directives }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' ')),\n    },\n    SelectionSet: { leave: ({ selections }) => block(selections) },\n    Field: {\n        leave({ alias, name, arguments: args, directives, selectionSet }) {\n            const prefix = wrap('', alias, ': ') + name;\n            let argsLine = prefix + wrap('(', join(args, ', '), ')');\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n            }\n            return join([argsLine, join(directives, ' '), selectionSet], ' ');\n        },\n    },\n    Argument: { leave: ({ name, value }) => name + ': ' + value },\n    // Fragments\n    FragmentSpread: {\n        leave: ({ name, directives }) => '...' + name + wrap(' ', join(directives, ' ')),\n    },\n    InlineFragment: {\n        leave: ({ typeCondition, directives, selectionSet }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' '),\n    },\n    FragmentDefinition: {\n        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => \n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n            `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n            selectionSet,\n    },\n    // Value\n    IntValue: { leave: ({ value }) => value },\n    FloatValue: { leave: ({ value }) => value },\n    StringValue: {\n        leave: ({ value, block: isBlockString }) => {\n            if (isBlockString) {\n                return printBlockString(value);\n            }\n            return JSON.stringify(value);\n        },\n    },\n    BooleanValue: { leave: ({ value }) => (value ? 'true' : 'false') },\n    NullValue: { leave: () => 'null' },\n    EnumValue: { leave: ({ value }) => value },\n    ListValue: { leave: ({ values }) => '[' + join(values, ', ') + ']' },\n    ObjectValue: { leave: ({ fields }) => '{' + join(fields, ', ') + '}' },\n    ObjectField: { leave: ({ name, value }) => name + ': ' + value },\n    // Directive\n    Directive: {\n        leave: ({ name, arguments: args }) => '@' + name + wrap('(', join(args, ', '), ')'),\n    },\n    // Type\n    NamedType: { leave: ({ name }) => name },\n    ListType: { leave: ({ type }) => '[' + type + ']' },\n    NonNullType: { leave: ({ type }) => type + '!' },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    OperationTypeDefinition: {\n        leave: ({ operation, type }) => operation + ': ' + type,\n    },\n    ScalarTypeDefinition: {\n        leave: ({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    FieldDefinition: {\n        leave: ({ name, arguments: args, type, directives }) => name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            ': ' +\n            type +\n            wrap(' ', join(directives, ' ')),\n    },\n    InputValueDefinition: {\n        leave: ({ name, type, defaultValue, directives }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' '),\n    },\n    InterfaceTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeDefinition: {\n        leave: ({ name, directives, types }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeDefinition: {\n        leave: ({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    EnumValueDefinition: {\n        leave: ({ name, directives }) => join([name, join(directives, ' ')], ' '),\n    },\n    InputObjectTypeDefinition: {\n        leave: ({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' '),\n    },\n    DirectiveDefinition: {\n        leave: ({ name, arguments: args, repeatable, locations }) => 'directive @' +\n            name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            (repeatable ? ' repeatable' : '') +\n            ' on ' +\n            join(locations, ' | '),\n    },\n    SchemaExtension: {\n        leave: ({ directives, operationTypes }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    ScalarTypeExtension: {\n        leave: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    InterfaceTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeExtension: {\n        leave: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeExtension: {\n        leave: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    InputObjectTypeExtension: {\n        leave: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n    },\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n    ...prev,\n    [key]: {\n        leave: addDescription(printDocASTReducer[key].leave),\n    },\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n    return visit(ast, printDocASTReducerWithComments);\n}\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nfunction getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n        return getComment(node);\n    }\n}\nfunction getComment(node) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n        return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n}\nfunction getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nfunction dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\n/**\n * @internal\n */\nfunction getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL, options = {}) {\n    let document;\n    try {\n        if (options.commentDescriptions && rawSDL.includes('#')) {\n            document = transformCommentsToDescriptions(rawSDL, options);\n            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n            // into descriptions.\n            if (options.noLocation) {\n                document = parse(print(document), options);\n            }\n        }\n        else {\n            document = parse(new Source(rawSDL, location), options);\n        }\n    }\n    catch (e) {\n        if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n            document = {\n                kind: Kind.DOCUMENT,\n                definitions: [],\n            };\n        }\n        else {\n            throw e;\n        }\n    }\n    return {\n        location,\n        document,\n    };\n}\nfunction transformCommentsToDescriptions(sourceSdl, options = {}) {\n    const parsedDoc = parse(sourceSdl, {\n        ...options,\n        noLocation: false,\n    });\n    const modifiedDoc = visit(parsedDoc, {\n        leave: (node) => {\n            if (isDescribable(node)) {\n                const rawValue = getLeadingCommentBlock(node);\n                if (rawValue !== undefined) {\n                    const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n                    const isBlock = commentsBlock.includes('\\n');\n                    if (!node.description) {\n                        return {\n                            ...node,\n                            description: {\n                                kind: Kind.STRING,\n                                value: commentsBlock,\n                                block: isBlock,\n                            },\n                        };\n                    }\n                    else {\n                        return {\n                            ...node,\n                            description: {\n                                ...node.description,\n                                value: node.description.value + '\\n' + commentsBlock,\n                                block: true,\n                            },\n                        };\n                    }\n                }\n            }\n        },\n    });\n    return modifiedDoc;\n}\nfunction isDescribable(node) {\n    return (isTypeSystemDefinitionNode(node) ||\n        node.kind === Kind.FIELD_DEFINITION ||\n        node.kind === Kind.INPUT_VALUE_DEFINITION ||\n        node.kind === Kind.ENUM_VALUE_DEFINITION);\n}\n\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true, }) {\n    resetOperationVariables();\n    resetFieldMap();\n    const rootTypeNames = getRootTypeNames(schema);\n    const operationNode = buildOperationAndCollectVariables({\n        schema,\n        fieldName: field,\n        kind,\n        models: models || [],\n        ignore,\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames,\n        selectedFields,\n        rootTypeNames,\n    });\n    // attach variables\n    operationNode.variableDefinitions = [...operationVariables];\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nfunction buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames, }) {\n    const type = getDefinedRootType(schema, kind);\n    const field = type.getFields()[fieldName];\n    const operationName = `${fieldName}_${kind}`;\n    if (field.args) {\n        for (const arg of field.args) {\n            const argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        }\n    }\n    return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: Kind.NAME,\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type,\n                    field,\n                    models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore,\n                    depthLimit,\n                    circularReferenceDepth,\n                    schema,\n                    depth: 0,\n                    argNames,\n                    selectedFields,\n                    rootTypeNames,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if (isUnionType(type)) {\n        const types = type.getTypes();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isInterfaceType(type)) {\n        const types = Object.values(schema.getTypeMap()).filter((t) => isObjectType(t) && t.getInterfaces().includes(type));\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isObjectType(type) && !rootTypeNames.has(type.name)) {\n        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n        const isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: Kind.FIELD,\n                        name: {\n                            kind: Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        const fields = type.getFields();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: Object.keys(fields)\n                .filter(fieldName => {\n                return !hasCircularRef([...ancestors, getNamedType(fields[fieldName].type)], {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(fieldName => {\n                const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type: type,\n                        field: fields[fieldName],\n                        models,\n                        path: [...path, fieldName],\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields: selectedSubFields,\n                        rootTypeNames,\n                    });\n                }\n                return null;\n            })\n                .filter((f) => {\n                var _a, _b;\n                if (f == null) {\n                    return false;\n                }\n                else if ('selectionSet' in f) {\n                    return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n                }\n                return true;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if (isListType(type)) {\n            return {\n                kind: Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if (isNonNullType(type)) {\n            return {\n                kind: Kind.NON_NULL_TYPE,\n                // for v16 compatibility\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: Kind.NAMED_TYPE,\n            name: {\n                kind: Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return [...path, name].join('_');\n}\nfunction resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    const namedType = getNamedType(field.type);\n    let args = [];\n    let removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(arg => {\n            const argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if (isNonNullType(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: Kind.ARGUMENT,\n                name: {\n                    kind: Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: Kind.VARIABLE,\n                    name: {\n                        kind: Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    const fieldPath = [...path, field.name];\n    const fieldPathStr = fieldPath.join('.');\n    let fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!isScalarType(namedType) && !isEnumType(namedType)) {\n        return {\n            kind: Kind.FIELD,\n            name: {\n                kind: Kind.NAME,\n                value: field.name,\n            },\n            ...(fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } }),\n            selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models,\n                firstCall,\n                path: fieldPath,\n                ancestors: [...ancestors, type],\n                ignore,\n                depthLimit,\n                circularReferenceDepth,\n                schema,\n                depth: depth + 1,\n                argNames,\n                selectedFields,\n                rootTypeNames,\n            }) || undefined,\n            arguments: args,\n        };\n    }\n    return {\n        kind: Kind.FIELD,\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        ...(fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } }),\n        arguments: args,\n    };\n}\nfunction hasCircularRef(types, config = {\n    depth: 1,\n}) {\n    const type = types[types.length - 1];\n    if (isScalarType(type)) {\n        return false;\n    }\n    const size = types.filter(t => t.name === type.name).length;\n    return size > config.depth;\n}\n\nvar MapperKind;\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n\nfunction getObjectTypeFromTypeMap(typeMap, type) {\n    if (type) {\n        const maybeObjectType = typeMap[type.name];\n        if (isObjectType(maybeObjectType)) {\n            return maybeObjectType;\n        }\n    }\n}\n\nfunction createNamedStub(name, type) {\n    let constructor;\n    if (type === 'object') {\n        constructor = GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = GraphQLInterfaceType;\n    }\n    else {\n        constructor = GraphQLInputObjectType;\n    }\n    return new constructor({\n        name,\n        fields: {\n            _fake: {\n                type: GraphQLString,\n            },\n        },\n    });\n}\nfunction createStub(node, type) {\n    switch (node.kind) {\n        case Kind.LIST_TYPE:\n            return new GraphQLList(createStub(node.type, type));\n        case Kind.NON_NULL_TYPE:\n            return new GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nfunction isNamedStub(type) {\n    if ('getFields' in type) {\n        const fields = type.getFields();\n        // eslint-disable-next-line no-unreachable-loop\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            return field.name === '_fake';\n        }\n    }\n    return false;\n}\nfunction getBuiltInForStub(type) {\n    switch (type.name) {\n        case GraphQLInt.name:\n            return GraphQLInt;\n        case GraphQLFloat.name:\n            return GraphQLFloat;\n        case GraphQLString.name:\n            return GraphQLString;\n        case GraphQLBoolean.name:\n            return GraphQLBoolean;\n        case GraphQLID.name:\n            return GraphQLID;\n        default:\n            return type;\n    }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n    const referenceTypeMap = Object.create(null);\n    for (const typeName in originalTypeMap) {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    }\n    const newTypeMap = Object.create(null);\n    for (const typeName in referenceTypeMap) {\n        const namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const newName = namedType.name;\n        if (newName.startsWith('__')) {\n            continue;\n        }\n        if (newTypeMap[newName] != null) {\n            throw new Error(`Duplicate schema type name ${newName}`);\n        }\n        newTypeMap[newName] = namedType;\n    }\n    for (const typeName in newTypeMap) {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    }\n    const newDirectives = directives.map(directive => rewireDirective(directive));\n    return {\n        typeMap: newTypeMap,\n        directives: newDirectives,\n    };\n    function rewireDirective(directive) {\n        if (isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        const directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        const rewiredArgs = {};\n        for (const argName in args) {\n            const arg = args[argName];\n            const rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        }\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (isObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n                interfaces: () => rewireNamedTypes(config.interfaces),\n            };\n            return new GraphQLObjectType(newConfig);\n        }\n        else if (isInterfaceType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n            };\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n            }\n            return new GraphQLInterfaceType(newConfig);\n        }\n        else if (isUnionType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                types: () => rewireNamedTypes(config.types),\n            };\n            return new GraphQLUnionType(newConfig);\n        }\n        else if (isInputObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireInputFields(config.fields),\n            };\n            return new GraphQLInputObjectType(newConfig);\n        }\n        else if (isEnumType(type)) {\n            const enumConfig = type.toConfig();\n            return new GraphQLEnumType(enumConfig);\n        }\n        else if (isScalarType(type)) {\n            if (isSpecifiedScalarType(type)) {\n                return type;\n            }\n            const scalarConfig = type.toConfig();\n            return new GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function rewireFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null && field.args) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        const rewiredTypes = [];\n        for (const namedType of namedTypes) {\n            const rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        }\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (isListType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n        }\n        else if (isNamedType(type)) {\n            let rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n\nfunction transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = getNullableType(type);\n    if (isLeafType(nullableType)) {\n        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n    }\n    else if (isListType(nullableType)) {\n        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n    }\n    else if (isInputObjectType(nullableType)) {\n        const fields = nullableType.getFields();\n        const newValue = {};\n        for (const key in value) {\n            const field = fields[key];\n            if (field != null) {\n                newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n            }\n        }\n        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n    }\n    // unreachable, no other possible return value\n}\nfunction serializeInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\nfunction parseInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\nfunction parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n\nfunction mapSchema(schema, schemaMapper = {}) {\n    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n    return new GraphQLSchema({\n        ...schema.toConfig(),\n        query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n        mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n        subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    }\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            for (const externalValue in originalEnumValueConfigMap) {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            }\n            return correctASTNodes(new GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => isEnumType(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if (isListType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLList(newType) : null;\n    }\n    else if (isNonNullType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLNonNull(newType) : null;\n    }\n    else if (isNamedType(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            }\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const newArgumentConfigMap = {};\n                for (const argumentName of argumentNames) {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                }\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            }\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    for (const directive of originalDirectives) {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    }\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.TYPE];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n    }\n    else if (isUnionType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n    }\n    else if (isEnumType(type)) {\n        specifiers.push(MapperKind.ENUM_TYPE);\n    }\n    else if (isScalarType(type)) {\n        specifiers.push(MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.FIELD];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        // TODO: fix this as unknown cast\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type) {\n    if (isObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLObjectType(config);\n    }\n    else if (isInterfaceType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInterfaceType(config);\n    }\n    else if (isInputObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInputObjectType(config);\n    }\n    else if (isEnumType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            for (const enumKey in config.values) {\n                const enumValueConfig = config.values[enumKey];\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\n\nfunction filterSchema({ schema, typeFilter = () => true, fieldFilter = undefined, rootFieldFilter = undefined, objectFieldFilter = undefined, interfaceFieldFilter = undefined, inputObjectFieldFilter = undefined, argumentFilter = undefined, }) {\n    const filteredSchema = mapSchema(schema, {\n        [MapperKind.QUERY]: (type) => filterRootFields(type, 'Query', rootFieldFilter, argumentFilter),\n        [MapperKind.MUTATION]: (type) => filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter),\n        [MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter),\n        [MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter)\n            : null,\n        [MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter)\n            : null,\n        [MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter)\n            : null,\n        [MapperKind.UNION_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [MapperKind.ENUM_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [MapperKind.SCALAR_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n    });\n    return filteredSchema;\n}\nfunction filterRootFields(type, operation, rootFieldFilter, argumentFilter) {\n    if (rootFieldFilter || argumentFilter) {\n        const config = type.toConfig();\n        for (const fieldName in config.fields) {\n            const field = config.fields[fieldName];\n            if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n                delete config.fields[fieldName];\n            }\n            else if (argumentFilter && field.args) {\n                for (const argName in field.args) {\n                    if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {\n                        delete field.args[argName];\n                    }\n                }\n            }\n        }\n        return new GraphQLObjectType(config);\n    }\n    return type;\n}\nfunction filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {\n    if (fieldFilter || argumentFilter) {\n        const config = type.toConfig();\n        for (const fieldName in config.fields) {\n            const field = config.fields[fieldName];\n            if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n                delete config.fields[fieldName];\n            }\n            else if (argumentFilter && 'args' in field) {\n                for (const argName in field.args) {\n                    if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {\n                        delete field.args[argName];\n                    }\n                }\n            }\n        }\n        return new ElementConstructor(config);\n    }\n}\n\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nfunction healSchema(schema) {\n    healTypes(schema.getTypeMap(), schema.getDirectives());\n    return schema;\n}\nfunction healTypes(originalTypeMap, directives) {\n    const actualNamedTypeMap = Object.create(null);\n    // If any of the .name properties of the GraphQLNamedType objects in\n    // schema.getTypeMap() have changed, the keys of the type map need to\n    // be updated accordingly.\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const actualName = namedType.name;\n        if (actualName.startsWith('__')) {\n            continue;\n        }\n        if (actualName in actualNamedTypeMap) {\n            throw new Error(`Duplicate schema type name ${actualName}`);\n        }\n        actualNamedTypeMap[actualName] = namedType;\n        // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n    }\n    // Now add back every named type by its actual name.\n    for (const typeName in actualNamedTypeMap) {\n        const namedType = actualNamedTypeMap[typeName];\n        originalTypeMap[typeName] = namedType;\n    }\n    // Directive declaration argument types can refer to named types.\n    for (const decl of directives) {\n        decl.args = decl.args.filter(arg => {\n            arg.type = healType(arg.type);\n            return arg.type !== null;\n        });\n    }\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        // Heal all named types, except for dangling references, kept only to redirect.\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n            if (namedType != null) {\n                healNamedType(namedType);\n            }\n        }\n    }\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n            delete originalTypeMap[typeName];\n        }\n    }\n    function healNamedType(type) {\n        if (isObjectType(type)) {\n            healFields(type);\n            healInterfaces(type);\n            return;\n        }\n        else if (isInterfaceType(type)) {\n            healFields(type);\n            if ('getInterfaces' in type) {\n                healInterfaces(type);\n            }\n            return;\n        }\n        else if (isUnionType(type)) {\n            healUnderlyingTypes(type);\n            return;\n        }\n        else if (isInputObjectType(type)) {\n            healInputFields(type);\n            return;\n        }\n        else if (isLeafType(type)) {\n            return;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function healFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.args\n                .map(arg => {\n                arg.type = healType(arg.type);\n                return arg.type === null ? null : arg;\n            })\n                .filter(Boolean);\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healInterfaces(type) {\n        if ('getInterfaces' in type) {\n            const interfaces = type.getInterfaces();\n            interfaces.push(...interfaces\n                .splice(0)\n                .map(iface => healType(iface))\n                .filter(Boolean));\n        }\n    }\n    function healInputFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healUnderlyingTypes(type) {\n        const types = type.getTypes();\n        types.push(...types\n            .splice(0)\n            .map(t => healType(t))\n            .filter(Boolean));\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (isListType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLList(healedType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLNonNull(healedType) : null;\n        }\n        else if (isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            // Note that new types can still be simply added by adding a field, as\n            // the official type will be undefined, not null.\n            const officialType = originalTypeMap[type.name];\n            if (officialType && type !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\n\nfunction getResolversFromSchema(schema) {\n    var _a, _b;\n    const resolvers = Object.create(null);\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        if (!typeName.startsWith('__')) {\n            const type = typeMap[typeName];\n            if (isScalarType(type)) {\n                if (!isSpecifiedScalarType(type)) {\n                    const config = type.toConfig();\n                    delete config.astNode; // avoid AST duplication elsewhere\n                    resolvers[typeName] = new GraphQLScalarType(config);\n                }\n            }\n            else if (isEnumType(type)) {\n                resolvers[typeName] = {};\n                const values = type.getValues();\n                for (const value of values) {\n                    resolvers[typeName][value.name] = value.value;\n                }\n            }\n            else if (isInterfaceType(type)) {\n                if (type.resolveType != null) {\n                    resolvers[typeName] = {\n                        __resolveType: type.resolveType,\n                    };\n                }\n            }\n            else if (isUnionType(type)) {\n                if (type.resolveType != null) {\n                    resolvers[typeName] = {\n                        __resolveType: type.resolveType,\n                    };\n                }\n            }\n            else if (isObjectType(type)) {\n                resolvers[typeName] = {};\n                if (type.isTypeOf != null) {\n                    resolvers[typeName].__isTypeOf = type.isTypeOf;\n                }\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    if (field.subscribe != null) {\n                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n                        resolvers[typeName][fieldName].subscribe = field.subscribe;\n                    }\n                    if (field.resolve != null &&\n                        ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== 'defaultFieldResolver' &&\n                        ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== 'defaultMergedResolver') {\n                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n                        resolvers[typeName][fieldName].resolve = field.resolve;\n                    }\n                }\n            }\n        }\n    }\n    return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n            const fields = type.getFields();\n            for (const fieldName in fields) {\n                const field = fields[fieldName];\n                fn(field, typeName, fieldName);\n            }\n        }\n    }\n}\n\nfunction forEachDefaultValue(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if (!getNamedType(type).name.startsWith('__')) {\n            if (isObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    for (const arg of field.args) {\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\n                    }\n                }\n            }\n            else if (isInputObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    field.defaultValue = fn(field.type, field.defaultValue);\n                }\n            }\n        }\n    }\n}\n\n// addTypes uses toConfig to create a new schema with a new or replaced\nfunction addTypes(schema, newTypesOrDirectives) {\n    const config = schema.toConfig();\n    const originalTypeMap = {};\n    for (const type of config.types) {\n        originalTypeMap[type.name] = type;\n    }\n    const originalDirectiveMap = {};\n    for (const directive of config.directives) {\n        originalDirectiveMap[directive.name] = directive;\n    }\n    for (const newTypeOrDirective of newTypesOrDirectives) {\n        if (isNamedType(newTypeOrDirective)) {\n            originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n        else if (isDirective(newTypeOrDirective)) {\n            originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n    }\n    const { typeMap, directives } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));\n    return new GraphQLSchema({\n        ...config,\n        query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),\n        mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),\n        subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\n\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\nfunction pruneSchema(schema, options = {}) {\n    const pruningContext = {\n        schema,\n        unusedTypes: Object.create(null),\n        implementations: Object.create(null),\n    };\n    for (const typeName in schema.getTypeMap()) {\n        const type = schema.getType(typeName);\n        if (type && 'getInterfaces' in type) {\n            for (const iface of type.getInterfaces()) {\n                const implementations = getImplementations(pruningContext, iface);\n                if (implementations == null) {\n                    pruningContext.implementations[iface.name] = Object.create(null);\n                }\n                pruningContext.implementations[iface.name][type.name] = true;\n            }\n        }\n    }\n    visitTypes(pruningContext, schema);\n    return mapSchema(schema, {\n        [MapperKind.TYPE]: (type) => {\n            // If we should NOT prune the type, return it immediately as unmodified\n            if (options.skipPruning && options.skipPruning(type)) {\n                return type;\n            }\n            if (isObjectType(type) || isInputObjectType(type)) {\n                if ((!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else if (isUnionType(type)) {\n                if ((!type.getTypes().length && !options.skipEmptyUnionPruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else if (isInterfaceType(type)) {\n                const implementations = getImplementations(pruningContext, type);\n                if ((!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning) ||\n                    (implementations && !Object.keys(implementations).length && !options.skipUnimplementedInterfacesPruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else {\n                if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n                    return null;\n                }\n            }\n        },\n    });\n}\nfunction visitOutputType(visitedTypes, pruningContext, type) {\n    if (visitedTypes[type.name]) {\n        return;\n    }\n    visitedTypes[type.name] = true;\n    pruningContext.unusedTypes[type.name] = false;\n    if (isObjectType(type) || isInterfaceType(type)) {\n        const fields = type.getFields();\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const namedType = getNamedType(field.type);\n            visitOutputType(visitedTypes, pruningContext, namedType);\n            for (const arg of field.args) {\n                const type = getNamedType(arg.type);\n                visitInputType(visitedTypes, pruningContext, type);\n            }\n        }\n        if (isInterfaceType(type)) {\n            const implementations = getImplementations(pruningContext, type);\n            if (implementations) {\n                for (const typeName in implementations) {\n                    visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));\n                }\n            }\n        }\n        if ('getInterfaces' in type) {\n            for (const iFace of type.getInterfaces()) {\n                visitOutputType(visitedTypes, pruningContext, iFace);\n            }\n        }\n    }\n    else if (isUnionType(type)) {\n        const types = type.getTypes();\n        for (const type of types) {\n            visitOutputType(visitedTypes, pruningContext, type);\n        }\n    }\n}\n/**\n * Get the implementations of an interface. May return undefined.\n */\nfunction getImplementations(pruningContext, type) {\n    return pruningContext.implementations[type.name];\n}\nfunction visitInputType(visitedTypes, pruningContext, type) {\n    if (visitedTypes[type.name]) {\n        return;\n    }\n    pruningContext.unusedTypes[type.name] = false;\n    visitedTypes[type.name] = true;\n    if (isInputObjectType(type)) {\n        const fields = type.getFields();\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const namedType = getNamedType(field.type);\n            visitInputType(visitedTypes, pruningContext, namedType);\n        }\n    }\n}\nfunction visitTypes(pruningContext, schema) {\n    for (const typeName in schema.getTypeMap()) {\n        if (!typeName.startsWith('__')) {\n            pruningContext.unusedTypes[typeName] = true;\n        }\n    }\n    const visitedTypes = Object.create(null);\n    const rootTypes = getRootTypes(schema);\n    for (const rootType of rootTypes) {\n        visitOutputType(visitedTypes, pruningContext, rootType);\n    }\n    for (const directive of schema.getDirectives()) {\n        for (const arg of directive.args) {\n            const type = getNamedType(arg.type);\n            visitInputType(visitedTypes, pruningContext, type);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction mergeDeep(sources, respectPrototype = false) {\n    const target = sources[0] || {};\n    const output = {};\n    if (respectPrototype) {\n        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));\n    }\n    for (const source of sources) {\n        if (isObject(target) && isObject(source)) {\n            if (respectPrototype) {\n                const outputPrototype = Object.getPrototypeOf(output);\n                const sourcePrototype = Object.getPrototypeOf(source);\n                if (sourcePrototype) {\n                    for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n                        const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n                        if (isSome(descriptor)) {\n                            Object.defineProperty(outputPrototype, key, descriptor);\n                        }\n                    }\n                }\n            }\n            for (const key in source) {\n                if (isObject(source[key])) {\n                    if (!(key in output)) {\n                        Object.assign(output, { [key]: source[key] });\n                    }\n                    else {\n                        output[key] = mergeDeep([output[key], source[key]], respectPrototype);\n                    }\n                }\n                else {\n                    Object.assign(output, { [key]: source[key] });\n                }\n            }\n        }\n    }\n    return output;\n}\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction parseSelectionSet(selectionSet, options) {\n    const query = parse(selectionSet, options).definitions[0];\n    return query.selectionSet;\n}\n\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\nfunction getResponseKeyFromInfo(info) {\n    return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n    if (schema.getType(typeName) == null) {\n        return addTypes(schema, [\n            new GraphQLObjectType({\n                name: typeName,\n                fields: additionalFields,\n            }),\n        ]);\n    }\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n                }\n                for (const fieldName in additionalFields) {\n                    newFieldConfigMap[fieldName] = additionalFields[fieldName];\n                }\n                return correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n}\nfunction removeObjectFields(schema, typeName, testFn) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                }\n                return correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\nfunction selectObjectFields(schema, typeName, testFn) {\n    const selectedFields = {};\n    mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        selectedFields[fieldName] = originalFieldConfig;\n                    }\n                }\n            }\n            return undefined;\n        },\n    });\n    return selectedFields;\n}\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                }\n                for (const fieldName in newFields) {\n                    const fieldConfig = newFields[fieldName];\n                    newFieldConfigMap[fieldName] = fieldConfig;\n                }\n                return correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n    if (isObjectType(type)) {\n        return new GraphQLObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isInterfaceType(type)) {\n        return new GraphQLInterfaceType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isUnionType(type)) {\n        return new GraphQLUnionType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isInputObjectType(type)) {\n        return new GraphQLInputObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isEnumType(type)) {\n        return new GraphQLEnumType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isScalarType(type)) {\n        return new GraphQLScalarType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    throw new Error(`Unknown type ${type}.`);\n}\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n    let $return;\n    let abruptClose;\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => Promise.reject(error);\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n    }\n    let mapReject;\n    if (rejectCallback) {\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = rejectCallback;\n        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            return $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            return Promise.reject(error).catch(abruptClose);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction asyncMapValue(value, callback) {\n    return new Promise(resolve => resolve(callback(value)));\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\n\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {\n    argumentNodes[argName] = {\n        kind: Kind.ARGUMENT,\n        name: {\n            kind: Kind.NAME,\n            value: argName,\n        },\n        value: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: varName,\n            },\n        },\n    };\n    variableDefinitionsMap[varName] = {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: varName,\n            },\n        },\n        type: astFromType(type),\n    };\n    if (value !== undefined) {\n        variableValues[varName] = value;\n        return;\n    }\n    // including the variable in the map with value of `undefined`\n    // will actually be translated by graphql-js into `null`\n    // see https://github.com/graphql/graphql-js/issues/2533\n    if (varName in variableValues) {\n        delete variableValues[varName];\n    }\n}\nfunction createVariableNameGenerator(variableDefinitionMap) {\n    let varCounter = 0;\n    return (argName) => {\n        let varName;\n        do {\n            varName = `_v${(varCounter++).toString()}_${argName}`;\n        } while (varName in variableDefinitionMap);\n        return varName;\n    };\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n    if (typeB == null || typeA == null) {\n        return false;\n    }\n    else if (typeA === typeB) {\n        return true;\n    }\n    else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n        return doTypesOverlap(schema, typeA, typeB);\n    }\n    return false;\n}\n\nfunction relocatedError(originalError, path) {\n    return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction observableToAsyncIterable(observable) {\n    const pullQueue = [];\n    const pushQueue = [];\n    let listening = true;\n    const pushValue = (value) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value, done: false });\n        }\n        else {\n            pushQueue.push({ value, done: false });\n        }\n    };\n    const pushError = (error) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\n        }\n        else {\n            pushQueue.push({ value: { errors: [error] }, done: false });\n        }\n    };\n    const pushDone = () => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ done: true });\n        }\n        else {\n            pushQueue.push({ done: true });\n        }\n    };\n    const pullValue = () => new Promise(resolve => {\n        if (pushQueue.length !== 0) {\n            const element = pushQueue.shift();\n            // either {value: {errors: [...]}} or {value: ...}\n            resolve(element);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const subscription = observable.subscribe({\n        next(value) {\n            pushValue(value);\n        },\n        error(err) {\n            pushError(err);\n        },\n        complete() {\n            pushDone();\n        },\n    });\n    const emptyQueue = () => {\n        if (listening) {\n            listening = false;\n            subscription.unsubscribe();\n            for (const resolve of pullQueue) {\n                resolve({ value: undefined, done: true });\n            }\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    return {\n        next() {\n            // return is a defined method, so it is safe to call it.\n            return listening ? pullValue() : this.return();\n        },\n        return() {\n            emptyQueue();\n            return Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            emptyQueue();\n            return Promise.reject(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n\nfunction getOperationASTFromDocument(documentNode, operationName) {\n    const doc = getOperationAST(documentNode, operationName);\n    if (!doc) {\n        throw new Error(`Cannot infer operation ${operationName || ''}`);\n    }\n    return doc;\n}\nconst getOperationASTFromRequest = memoize1(function getOperationASTFromRequest(request) {\n    return getOperationASTFromDocument(request.document, request.operationName);\n});\n\n// Taken from GraphQL-JS v16 for backwards compat\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case Kind.FIELD: {\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                const name = getFieldEntryKey(selection);\n                const fieldList = fields.get(name);\n                if (fieldList !== undefined) {\n                    fieldList.push(selection);\n                }\n                else {\n                    fields.set(name, [selection]);\n                }\n                break;\n            }\n            case Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(variableValues, selection) ||\n                    !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n            case Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                visitedFragmentNames.add(fragName);\n                const fragment = fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n        }\n    }\n    return fields;\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(variableValues, node) {\n    const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n    if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n        return false;\n    }\n    const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n    if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = typeFromAST(schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if (isAbstractType(conditionalType)) {\n        const possibleTypes = schema.getPossibleTypes(conditionalType);\n        return possibleTypes.includes(type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\nconst collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n    const subFieldNodes = new Map();\n    const visitedFragmentNames = new Set();\n    for (const fieldNode of fieldNodes) {\n        if (fieldNode.selectionSet) {\n            collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n        }\n    }\n    return subFieldNodes;\n});\n\nfunction visitData(data, enter, leave) {\n    if (Array.isArray(data)) {\n        return data.map(value => visitData(value, enter, leave));\n    }\n    else if (typeof data === 'object') {\n        const newData = enter != null ? enter(data) : data;\n        if (newData != null) {\n            for (const key in newData) {\n                const value = newData[key];\n                Object.defineProperty(newData, key, {\n                    value: visitData(value, enter, leave),\n                });\n            }\n        }\n        return leave != null ? leave(newData) : newData;\n    }\n    return data;\n}\nfunction visitErrors(errors, visitor) {\n    return errors.map(error => visitor(error));\n}\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n    const fragments = request.document.definitions.reduce((acc, def) => {\n        if (def.kind === Kind.FRAGMENT_DEFINITION) {\n            acc[def.name.value] = def;\n        }\n        return acc;\n    }, {});\n    const variableValues = request.variables || {};\n    const errorInfo = {\n        segmentInfoMap: new Map(),\n        unpathedErrors: new Set(),\n    };\n    const data = result.data;\n    const errors = result.errors;\n    const visitingErrors = errors != null && errorVisitorMap != null;\n    const operationDocumentNode = getOperationASTFromRequest(request);\n    if (data != null && operationDocumentNode != null) {\n        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n    }\n    if (errors != null && errorVisitorMap) {\n        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n    }\n    return result;\n}\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n    const segmentInfoMap = errorInfo.segmentInfoMap;\n    const unpathedErrors = errorInfo.unpathedErrors;\n    const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n    return errors.map(originalError => {\n        const pathSegmentsInfo = segmentInfoMap.get(originalError);\n        const newError = pathSegmentsInfo == null\n            ? originalError\n            : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n                const typeName = segmentInfo.type.name;\n                const typeVisitorMap = errorVisitorMap[typeName];\n                if (typeVisitorMap == null) {\n                    return acc;\n                }\n                const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n                return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n            }, originalError);\n        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n            return unpathedErrorVisitor(newError);\n        }\n        return newError;\n    });\n}\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n    const operationRootType = getOperationRootType(schema, operation);\n    const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n    return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    const fieldMap = type.getFields();\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n    const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n    const newObject = enterObject != null ? enterObject(object) : object;\n    let sortedErrors;\n    let errorMap = null;\n    if (errors != null) {\n        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n        errorMap = sortedErrors.errorMap;\n        for (const error of sortedErrors.unpathedErrors) {\n            errorInfo.unpathedErrors.add(error);\n        }\n    }\n    for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n        const fieldName = subFieldNodes[0].name.value;\n        const fieldType = fieldName === '__typename' ? TypeNameMetaFieldDef.type : fieldMap[fieldName].type;\n        const newPathIndex = pathIndex + 1;\n        let fieldErrors;\n        if (errorMap) {\n            fieldErrors = errorMap[responseKey];\n            if (fieldErrors != null) {\n                delete errorMap[responseKey];\n            }\n            addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n        }\n        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n    }\n    const oldTypename = newObject.__typename;\n    if (oldTypename != null) {\n        updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n    }\n    if (errorMap) {\n        for (const errorsKey in errorMap) {\n            const errors = errorMap[errorsKey];\n            for (const error of errors) {\n                errorInfo.unpathedErrors.add(error);\n            }\n        }\n    }\n    const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n    return leaveObject != null ? leaveObject(newObject) : newObject;\n}\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n    if (typeVisitorMap == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const fieldVisitor = typeVisitorMap[fieldName];\n    if (fieldVisitor == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const visitedValue = fieldVisitor(newValue);\n    if (visitedValue === undefined) {\n        delete object[responseKey];\n        return;\n    }\n    object[responseKey] = visitedValue;\n}\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = getNullableType(returnType);\n    if (isListType(nullableType)) {\n        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (isAbstractType(nullableType)) {\n        const finalType = schema.getType(value.__typename);\n        const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);\n        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (isObjectType(nullableType)) {\n        const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);\n        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n    if (typeVisitorMap == null) {\n        return value;\n    }\n    const visitedValue = typeVisitorMap(value);\n    return visitedValue === undefined ? value : visitedValue;\n}\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n    var _a;\n    const errorMap = Object.create(null);\n    const unpathedErrors = new Set();\n    for (const error of errors) {\n        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n        if (pathSegment == null) {\n            unpathedErrors.add(error);\n            continue;\n        }\n        if (pathSegment in errorMap) {\n            errorMap[pathSegment].push(error);\n        }\n        else {\n            errorMap[pathSegment] = [error];\n        }\n    }\n    return {\n        errorMap,\n        unpathedErrors,\n    };\n}\nfunction addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {\n    for (const error of errors) {\n        const segmentInfo = {\n            type,\n            fieldName,\n            pathIndex,\n        };\n        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n        if (pathSegmentsInfo == null) {\n            errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n        }\n        else {\n            pathSegmentsInfo.push(segmentInfo);\n        }\n    }\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n    if (value == null) {\n        return value === criteria;\n    }\n    else if (Array.isArray(value)) {\n        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n    }\n    else if (typeof value === 'object') {\n        return (typeof criteria === 'object' &&\n            criteria &&\n            Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName])));\n    }\n    else if (criteria instanceof RegExp) {\n        return criteria.test(value);\n    }\n    return value === criteria;\n}\n\nfunction isAsyncIterable(value) {\n    return (typeof value === 'object' &&\n        value != null &&\n        Symbol.asyncIterator in value &&\n        typeof value[Symbol.asyncIterator] === 'function');\n}\n\nfunction isDocumentNode(object) {\n    return object && typeof object === 'object' && 'kind' in object && object.kind === Kind.DOCUMENT;\n}\n\nfunction withCancel(asyncIteratorLike, onCancel) {\n    const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();\n    if (!asyncIterator.return) {\n        asyncIterator.return = () => Promise.resolve({ value: undefined, done: true });\n    }\n    const savedReturn = asyncIterator.return.bind(asyncIterator);\n    asyncIterator.return = () => {\n        onCancel();\n        return savedReturn();\n    };\n    return asyncIterator;\n}\n\nfunction buildFixedSchema(schema, options) {\n    const document = getDocumentNodeFromSchema(schema);\n    return buildASTSchema(document, {\n        ...(options || {}),\n    });\n}\nfunction fixSchemaAst(schema, options) {\n    // eslint-disable-next-line no-undef-init\n    let schemaWithValidAst = undefined;\n    if (!schema.astNode || !schema.extensionASTNodes) {\n        schemaWithValidAst = buildFixedSchema(schema, options);\n    }\n    if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n        schema.astNode = schemaWithValidAst.astNode;\n    }\n    if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n    }\n    return schema;\n}\n\nexport { AggregateErrorImpl as AggregateError, MapperKind, addTypes, appendObjectFields, asArray, assertSome, astFromArg, astFromDirective, astFromEnumType, astFromEnumValue, astFromField, astFromInputField, astFromInputObjectType, astFromInterfaceType, astFromObjectType, astFromScalarType, astFromSchema, astFromUnionType, astFromValueUntyped, buildOperationNodeForField, checkValidationErrors, collectComment, collectFields, collectSubFields, compareNodes, compareStrings, correctASTNodes, createDefaultRules, createNamedStub, createStub, createVariableNameGenerator, dedentBlockStringValue, filterSchema, fixSchemaAst, forEachDefaultValue, forEachField, getArgumentValues, getBlockStringIndentation, getBuiltInForStub, getComment, getDefinedRootType, getDeprecatableDirectiveNodes, getDescription, getDirective, getDirectiveInExtensions, getDirectiveNodes, getDirectives, getDirectivesInExtensions, getDocumentNodeFromSchema, getFieldsWithDirectives, getImplementingTypes, getLeadingCommentBlock, getOperationASTFromDocument, getOperationASTFromRequest, getResolversFromSchema, getResponseKeyFromInfo, getRootTypeMap, getRootTypeNames, getRootTypes, healSchema, healTypes, implementsAbstractType, inspect, isAggregateError, isAsyncIterable, isDescribable, isDocumentNode, isDocumentString, isNamedStub, isSome, isValidPath, makeDeprecatedDirective, makeDirectiveNode, makeDirectiveNodes, mapAsyncIterator, mapSchema, memoize1, memoize2, memoize2of4, memoize3, memoize4, memoize5, mergeDeep, modifyObjectFields, nodeToString, observableToAsyncIterable, parseGraphQLJSON, parseGraphQLSDL, parseInputValue, parseInputValueLiteral, parseSelectionSet, printComment, printSchemaWithDirectives, printWithComments, pruneSchema, pushComment, relocatedError, removeObjectFields, renameType, resetComments, rewireTypes, selectObjectFields, serializeInputValue, transformCommentsToDescriptions, transformInputValue, updateArgument, validateGraphQlDocuments, valueMatchesCriteria, visitData, visitErrors, visitResult, withCancel };\n"]},"metadata":{},"sourceType":"module"}