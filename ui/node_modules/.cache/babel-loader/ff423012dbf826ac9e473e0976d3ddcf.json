{"ast":null,"code":"import { mergeDeep, isSome, compareNodes, collectComment, resetComments, printWithComments, getDocumentNodeFromSchema, isDocumentNode } from '@graphql-tools/utils';\nimport { print, Kind, Source, isSchema, parse, isDefinitionNode, isScalarType, isSpecifiedScalarType, isIntrospectionType, isObjectType, isInterfaceType, isInputObjectType, isUnionType, isEnumType } from 'graphql';\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\n\nfunction mergeResolvers(resolversDefinitions, options) {\n  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {\n    return {};\n  }\n\n  if (!Array.isArray(resolversDefinitions)) {\n    return resolversDefinitions;\n  }\n\n  if (resolversDefinitions.length === 1) {\n    return resolversDefinitions[0] || {};\n  }\n\n  const resolvers = new Array();\n\n  for (let resolversDefinition of resolversDefinitions) {\n    if (Array.isArray(resolversDefinition)) {\n      resolversDefinition = mergeResolvers(resolversDefinition);\n    }\n\n    if (typeof resolversDefinition === 'object' && resolversDefinition) {\n      resolvers.push(resolversDefinition);\n    }\n  }\n\n  const result = mergeDeep(resolvers, true);\n\n  if (options === null || options === void 0 ? void 0 : options.exclusions) {\n    for (const exclusion of options.exclusions) {\n      const [typeName, fieldName] = exclusion.split('.');\n\n      if (!fieldName || fieldName === '*') {\n        delete result[typeName];\n      } else if (result[typeName]) {\n        delete result[typeName][fieldName];\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n  const result = deduplicateArguments([...args2, ...args1].filter(isSome));\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  return result;\n}\n\nfunction deduplicateArguments(args) {\n  return args.reduce((acc, current) => {\n    const dup = acc.find(arg => arg.name.value === current.name.value);\n\n    if (!dup) {\n      return acc.concat([current]);\n    }\n\n    return acc;\n  }, []);\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n  return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\n\nfunction nameAlreadyExists(name, namesArr) {\n  return namesArr.some(_ref => {\n    let {\n      value\n    } = _ref;\n    return value === name.value;\n  });\n}\n\nfunction mergeArguments$1(a1, a2) {\n  const result = [...a2];\n\n  for (const argument of a1) {\n    const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n\n    if (existingIndex > -1) {\n      const existingArg = result[existingIndex];\n\n      if (existingArg.value.kind === 'ListValue') {\n        const source = existingArg.value.values;\n        const target = argument.value.values; // merge values of two lists\n\n        existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n          const value = targetVal.value;\n          return !value || !source.some(sourceVal => sourceVal.value === value);\n        });\n      } else {\n        existingArg.value = argument.value;\n      }\n    } else {\n      result.push(argument);\n    }\n  }\n\n  return result;\n}\n\nfunction deduplicateDirectives(directives) {\n  return directives.map((directive, i, all) => {\n    const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n\n    if (firstAt !== i) {\n      const dup = all[firstAt];\n      directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n      return null;\n    }\n\n    return directive;\n  }).filter(isSome);\n}\n\nfunction mergeDirectives() {\n  let d1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let d2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let config = arguments.length > 2 ? arguments[2] : undefined;\n  const reverseOrder = config && config.reverseDirectives;\n  const asNext = reverseOrder ? d1 : d2;\n  const asFirst = reverseOrder ? d2 : d1;\n  const result = deduplicateDirectives([...asNext]);\n\n  for (const directive of asFirst) {\n    if (directiveAlreadyExists(result, directive)) {\n      const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n      const existingDirective = result[existingDirectiveIndex];\n      result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n    } else {\n      result.push(directive);\n    }\n  }\n\n  return result;\n}\n\nfunction validateInputs(node, existingNode) {\n  const printedNode = print({ ...node,\n    description: undefined\n  });\n  const printedExistingNode = print({ ...existingNode,\n    description: undefined\n  }); // eslint-disable-next-line\n\n  const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n  const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n\n  if (!sameArguments) {\n    throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n  }\n}\n\nfunction mergeDirective(node, existingNode) {\n  if (existingNode) {\n    validateInputs(node, existingNode);\n    return { ...node,\n      locations: [...existingNode.locations, ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations))]\n    };\n  }\n\n  return node;\n}\n\nfunction deduplicateLists(source, target, filterFn) {\n  return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n  if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {\n    const reversed = [];\n\n    if (first) {\n      reversed.push(...first);\n    }\n\n    first = second;\n    second = reversed;\n  }\n\n  const enumValueMap = new Map();\n\n  if (first) {\n    for (const firstValue of first) {\n      enumValueMap.set(firstValue.name.value, firstValue);\n    }\n  }\n\n  if (second) {\n    for (const secondValue of second) {\n      const enumValue = secondValue.name.value;\n\n      if (enumValueMap.has(enumValue)) {\n        const firstValue = enumValueMap.get(enumValue);\n        firstValue.description = secondValue.description || firstValue.description;\n        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n      } else {\n        enumValueMap.set(enumValue, secondValue);\n      }\n    }\n  }\n\n  const result = [...enumValueMap.values()];\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n  if (e2) {\n    return {\n      name: e1.name,\n      description: e1['description'] || e2['description'],\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition' ? 'EnumTypeDefinition' : 'EnumTypeExtension',\n      loc: e1.loc,\n      directives: mergeDirectives(e1.directives, e2.directives, config),\n      values: mergeEnumValues(e1.values, e2.values, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...e1,\n    kind: Kind.ENUM_TYPE_DEFINITION\n  } : e1;\n}\n\nfunction isStringTypes(types) {\n  return typeof types === 'string';\n}\n\nfunction isSourceTypes(types) {\n  return types instanceof Source;\n}\n\nfunction extractType(type) {\n  let visitedType = type;\n\n  while (visitedType.kind === Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n    visitedType = visitedType.type;\n  }\n\n  return visitedType;\n}\n\nfunction isWrappingTypeNode(type) {\n  return type.kind !== Kind.NAMED_TYPE;\n}\n\nfunction isListTypeNode(type) {\n  return type.kind === Kind.LIST_TYPE;\n}\n\nfunction isNonNullTypeNode(type) {\n  return type.kind === Kind.NON_NULL_TYPE;\n}\n\nfunction printTypeNode(type) {\n  if (isListTypeNode(type)) {\n    return `[${printTypeNode(type.type)}]`;\n  }\n\n  if (isNonNullTypeNode(type)) {\n    return `${printTypeNode(type.type)}!`;\n  }\n\n  return type.name.value;\n}\n\nvar CompareVal;\n\n(function (CompareVal) {\n  CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n  CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n  CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(CompareVal || (CompareVal = {}));\n\nfunction defaultStringComparator(a, b) {\n  if (a == null && b == null) {\n    return CompareVal.A_EQUALS_B;\n  }\n\n  if (a == null) {\n    return CompareVal.A_SMALLER_THAN_B;\n  }\n\n  if (b == null) {\n    return CompareVal.A_GREATER_THAN_B;\n  }\n\n  if (a < b) return CompareVal.A_SMALLER_THAN_B;\n  if (a > b) return CompareVal.A_GREATER_THAN_B;\n  return CompareVal.A_EQUALS_B;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n  const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n\n  if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n    const t1 = extractType(result.type);\n    const t2 = extractType(otherField.type);\n\n    if (t1.name.value !== t2.name.value) {\n      throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n    }\n  }\n\n  return !!result;\n}\n\nfunction mergeFields(type, f1, f2, config) {\n  const result = [];\n\n  if (f2 != null) {\n    result.push(...f2);\n  }\n\n  if (f1 != null) {\n    for (const field of f1) {\n      if (fieldAlreadyExists(result, field, config)) {\n        const existing = result.find(f => f.name.value === field.name.value);\n\n        if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n          if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n            preventConflicts(type, existing, field, false);\n          } else {\n            preventConflicts(type, existing, field, true);\n          }\n\n          if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n            existing.type = field.type;\n          }\n        }\n\n        existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n        existing.directives = mergeDirectives(field.directives, existing.directives, config);\n        existing.description = field.description || existing.description;\n      } else {\n        result.push(field);\n      }\n    }\n  }\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  if (config && config.exclusions) {\n    const exclusions = config.exclusions;\n    return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n  }\n\n  return result;\n}\n\nfunction preventConflicts(type, a, b) {\n  let ignoreNullability = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const aType = printTypeNode(a.type);\n  const bType = printTypeNode(b.type);\n\n  if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n    throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n  }\n}\n\nfunction safeChangeForFieldType(oldType, newType) {\n  let ignoreNullability = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // both are named\n  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n    return oldType.toString() === newType.toString();\n  } // new is non-null\n\n\n  if (isNonNullTypeNode(newType)) {\n    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n    return safeChangeForFieldType(ofType, newType.type);\n  } // old is non-null\n\n\n  if (isNonNullTypeNode(oldType)) {\n    return safeChangeForFieldType(newType, oldType, ignoreNullability);\n  } // old is list\n\n\n  if (isListTypeNode(oldType)) {\n    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type']);\n  }\n\n  return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InputObjectTypeDefinition' || existingNode.kind === 'InputObjectTypeDefinition' ? 'InputObjectTypeDefinition' : 'InputObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InterfaceTypeDefinition' || existingNode.kind === 'InterfaceTypeDefinition' ? 'InterfaceTypeDefinition' : 'InterfaceTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: Kind.INTERFACE_TYPE_DEFINITION\n  } : node;\n}\n\nfunction alreadyExists(arr, other) {\n  return !!arr.find(i => i.name.value === other.name.value);\n}\n\nfunction mergeNamedTypeArray() {\n  let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ObjectTypeDefinition' || existingNode.kind === 'ObjectTypeDefinition' ? 'ObjectTypeDefinition' : 'ObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config),\n        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: Kind.OBJECT_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeScalar(node, existingNode, config) {\n  if (existingNode) {\n    return {\n      name: node.name,\n      description: node['description'] || existingNode['description'],\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ScalarTypeDefinition' || existingNode.kind === 'ScalarTypeDefinition' ? 'ScalarTypeDefinition' : 'ScalarTypeExtension',\n      loc: node.loc,\n      directives: mergeDirectives(node.directives, existingNode.directives, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: Kind.SCALAR_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeUnion(first, second, config) {\n  if (second) {\n    return {\n      name: first.name,\n      description: first['description'] || second['description'],\n      // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n      directives: mergeDirectives(first.directives, second.directives, config),\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition' ? Kind.UNION_TYPE_DEFINITION : Kind.UNION_TYPE_EXTENSION,\n      loc: first.loc,\n      types: mergeNamedTypeArray(first.types, second.types, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...first,\n    kind: Kind.UNION_TYPE_DEFINITION\n  } : first;\n}\n\nconst DEFAULT_OPERATION_TYPE_NAME_MAP = {\n  query: 'Query',\n  mutation: 'Mutation',\n  subscription: 'Subscription'\n};\n\nfunction mergeOperationTypes() {\n  let opNodeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let existingOpNodeList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const finalOpNodeList = [];\n\n  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n    const opNode = opNodeList.find(n => n.operation === opNodeType) || existingOpNodeList.find(n => n.operation === opNodeType);\n\n    if (opNode) {\n      finalOpNodeList.push(opNode);\n    }\n  }\n\n  return finalOpNodeList;\n}\n\nfunction mergeSchemaDefs(node, existingNode, config) {\n  if (existingNode) {\n    return {\n      kind: node.kind === Kind.SCHEMA_DEFINITION || existingNode.kind === Kind.SCHEMA_DEFINITION ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,\n      description: node['description'] || existingNode['description'],\n      directives: mergeDirectives(node.directives, existingNode.directives, config),\n      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: Kind.SCHEMA_DEFINITION\n  } : node;\n}\n\nconst schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\n\nfunction isNamedDefinitionNode(definitionNode) {\n  return 'name' in definitionNode;\n}\n\nfunction mergeGraphQLNodes(nodes, config) {\n  var _a, _b, _c;\n\n  const mergedResultMap = {};\n\n  for (const nodeDefinition of nodes) {\n    if (isNamedDefinitionNode(nodeDefinition)) {\n      const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;\n\n      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        collectComment(nodeDefinition);\n      }\n\n      if (name == null) {\n        continue;\n      }\n\n      if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {\n        delete mergedResultMap[name];\n      } else {\n        switch (nodeDefinition.kind) {\n          case Kind.OBJECT_TYPE_DEFINITION:\n          case Kind.OBJECT_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case Kind.ENUM_TYPE_DEFINITION:\n          case Kind.ENUM_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case Kind.UNION_TYPE_DEFINITION:\n          case Kind.UNION_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case Kind.SCALAR_TYPE_DEFINITION:\n          case Kind.SCALAR_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n          case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case Kind.INTERFACE_TYPE_DEFINITION:\n          case Kind.INTERFACE_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case Kind.DIRECTIVE_DEFINITION:\n            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);\n            break;\n        }\n      }\n    } else if (nodeDefinition.kind === Kind.SCHEMA_DEFINITION || nodeDefinition.kind === Kind.SCHEMA_EXTENSION) {\n      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);\n    }\n  }\n\n  return mergedResultMap;\n}\n\nfunction mergeTypeDefs(typeSource, config) {\n  resetComments();\n  const doc = {\n    kind: Kind.DOCUMENT,\n    definitions: mergeGraphQLTypes(typeSource, {\n      useSchemaDefinition: true,\n      forceSchemaDefinition: false,\n      throwOnConflict: false,\n      commentDescriptions: false,\n      ...config\n    })\n  };\n  let result;\n\n  if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n    result = printWithComments(doc);\n  } else {\n    result = doc;\n  }\n\n  resetComments();\n  return result;\n}\n\nfunction visitTypeSources(typeSource, options) {\n  let allNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let visitedTypeSources = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();\n\n  if (typeSource && !visitedTypeSources.has(typeSource)) {\n    visitedTypeSources.add(typeSource);\n\n    if (typeof typeSource === 'function') {\n      visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n    } else if (Array.isArray(typeSource)) {\n      for (const type of typeSource) {\n        visitTypeSources(type, options, allNodes, visitedTypeSources);\n      }\n    } else if (isSchema(typeSource)) {\n      const documentNode = getDocumentNodeFromSchema(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {\n      const documentNode = parse(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if (typeof typeSource === 'object' && isDefinitionNode(typeSource)) {\n      allNodes.push(typeSource);\n    } else if (isDocumentNode(typeSource)) {\n      visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n    } else {\n      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n    }\n  }\n\n  return allNodes;\n}\n\nfunction mergeGraphQLTypes(typeSource, config) {\n  var _a, _b, _c;\n\n  resetComments();\n  const allNodes = visitTypeSources(typeSource, config);\n  const mergedNodes = mergeGraphQLNodes(allNodes, config);\n\n  if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n    // XXX: right now we don't handle multiple schema definitions\n    const schemaDef = mergedNodes[schemaDefSymbol] || {\n      kind: Kind.SCHEMA_DEFINITION,\n      operationTypes: []\n    };\n    const operationTypes = schemaDef.operationTypes;\n\n    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n      const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n\n      if (!opTypeDefNode) {\n        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n        const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n\n        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n          operationTypes.push({\n            kind: Kind.OPERATION_TYPE_DEFINITION,\n            type: {\n              kind: Kind.NAMED_TYPE,\n              name: existingPossibleRootType.name\n            },\n            operation: opTypeDefNodeType\n          });\n        }\n      }\n    }\n\n    if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n      mergedNodes[schemaDefSymbol] = schemaDef;\n    }\n  }\n\n  if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n    mergedNodes[schemaDefSymbol] = {\n      kind: Kind.SCHEMA_DEFINITION,\n      operationTypes: [{\n        kind: Kind.OPERATION_TYPE_DEFINITION,\n        operation: 'query',\n        type: {\n          kind: Kind.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: 'Query'\n          }\n        }\n      }]\n    };\n  }\n\n  const mergedNodeDefinitions = Object.values(mergedNodes);\n\n  if (config === null || config === void 0 ? void 0 : config.sort) {\n    const sortFn = typeof config.sort === 'function' ? config.sort : defaultStringComparator;\n    mergedNodeDefinitions.sort((a, b) => {\n      var _a, _b;\n\n      return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);\n    });\n  }\n\n  return mergedNodeDefinitions;\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n  hooks.onSchema(schema);\n  const typesMap = schema.getTypeMap();\n\n  for (const [, type] of Object.entries(typesMap)) {\n    const isPredefinedScalar = isScalarType(type) && isSpecifiedScalarType(type);\n    const isIntrospection = isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    }\n\n    if (isObjectType(type)) {\n      hooks.onObjectType(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onObjectField(type, field);\n        const args = field.args || [];\n\n        for (const arg of args) {\n          hooks.onObjectFieldArg(type, field, arg);\n        }\n      }\n    } else if (isInterfaceType(type)) {\n      hooks.onInterface(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onInterfaceField(type, field);\n        const args = field.args || [];\n\n        for (const arg of args) {\n          hooks.onInterfaceFieldArg(type, field, arg);\n        }\n      }\n    } else if (isInputObjectType(type)) {\n      hooks.onInputType(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onInputFieldType(type, field);\n      }\n    } else if (isUnionType(type)) {\n      hooks.onUnion(type);\n    } else if (isScalarType(type)) {\n      hooks.onScalar(type);\n    } else if (isEnumType(type)) {\n      hooks.onEnum(type);\n\n      for (const value of type.getValues()) {\n        hooks.onEnumValue(type, value);\n      }\n    }\n  }\n}\n\nfunction mergeExtensions(extensions) {\n  return mergeDeep(extensions);\n}\n\nfunction applyExtensionObject(obj, extensions) {\n  if (!obj) {\n    return;\n  }\n\n  obj.extensions = mergeDeep([obj.extensions || {}, extensions || {}]);\n}\n\nfunction applyExtensions(schema, extensions) {\n  applyExtensionObject(schema, extensions.schemaExtensions);\n\n  for (const [typeName, data] of Object.entries(extensions.types || {})) {\n    const type = schema.getType(typeName);\n\n    if (type) {\n      applyExtensionObject(type, data.extensions);\n\n      if (data.type === 'object' || data.type === 'interface') {\n        for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n          const field = type.getFields()[fieldName];\n\n          if (field) {\n            applyExtensionObject(field, fieldData.extensions);\n\n            for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n              applyExtensionObject(field.args.find(a => a.name === arg), argData);\n            }\n          }\n        }\n      } else if (data.type === 'input') {\n        for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n          const field = type.getFields()[fieldName];\n          applyExtensionObject(field, fieldData.extensions);\n        }\n      } else if (data.type === 'enum') {\n        for (const [valueName, valueData] of Object.entries(data.values)) {\n          const value = type.getValue(valueName);\n          applyExtensionObject(value, valueData);\n        }\n      }\n    }\n  }\n\n  return schema;\n}\n\nfunction extractExtensionsFromSchema(schema) {\n  const result = {\n    schemaExtensions: {},\n    types: {}\n  };\n  travelSchemaPossibleExtensions(schema, {\n    onSchema: schema => result.schemaExtensions = schema.extensions || {},\n    onObjectType: type => result.types[type.name] = {\n      fields: {},\n      type: 'object',\n      extensions: type.extensions || {}\n    },\n    onObjectField: (type, field) => result.types[type.name].fields[field.name] = {\n      arguments: {},\n      extensions: field.extensions || {}\n    },\n    onObjectFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},\n    onInterface: type => result.types[type.name] = {\n      fields: {},\n      type: 'interface',\n      extensions: type.extensions || {}\n    },\n    onInterfaceField: (type, field) => result.types[type.name].fields[field.name] = {\n      arguments: {},\n      extensions: field.extensions || {}\n    },\n    onInterfaceFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},\n    onEnum: type => result.types[type.name] = {\n      values: {},\n      type: 'enum',\n      extensions: type.extensions || {}\n    },\n    onEnumValue: (type, value) => result.types[type.name].values[value.name] = value.extensions || {},\n    onScalar: type => result.types[type.name] = {\n      type: 'scalar',\n      extensions: type.extensions || {}\n    },\n    onUnion: type => result.types[type.name] = {\n      type: 'union',\n      extensions: type.extensions || {}\n    },\n    onInputType: type => result.types[type.name] = {\n      fields: {},\n      type: 'input',\n      extensions: type.extensions || {}\n    },\n    onInputFieldType: (type, field) => result.types[type.name].fields[field.name] = {\n      extensions: field.extensions || {}\n    }\n  });\n  return result;\n}\n\nexport { CompareVal, applyExtensions, defaultStringComparator, extractExtensionsFromSchema, extractType, isListTypeNode, isNamedDefinitionNode, isNonNullTypeNode, isSourceTypes, isStringTypes, isWrappingTypeNode, mergeArguments, mergeDirective, mergeDirectives, mergeEnum, mergeEnumValues, mergeExtensions, mergeFields, mergeGraphQLNodes, mergeGraphQLTypes, mergeInputType, mergeInterface, mergeNamedTypeArray, mergeResolvers, mergeScalar, mergeType, mergeTypeDefs, mergeUnion, printTypeNode, schemaDefSymbol, travelSchemaPossibleExtensions };","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/@graphql-tools/merge/index.mjs"],"names":["mergeDeep","isSome","compareNodes","collectComment","resetComments","printWithComments","getDocumentNodeFromSchema","isDocumentNode","print","Kind","Source","isSchema","parse","isDefinitionNode","isScalarType","isSpecifiedScalarType","isIntrospectionType","isObjectType","isInterfaceType","isInputObjectType","isUnionType","isEnumType","mergeResolvers","resolversDefinitions","options","Array","isArray","length","resolvers","resolversDefinition","push","result","exclusions","exclusion","typeName","fieldName","split","mergeArguments","args1","args2","config","deduplicateArguments","filter","sort","args","reduce","acc","current","dup","find","arg","name","value","concat","directiveAlreadyExists","directivesArr","otherDirective","directive","nameAlreadyExists","namesArr","some","mergeArguments$1","a1","a2","argument","existingIndex","findIndex","a","existingArg","kind","source","values","target","deduplicateLists","targetVal","sourceVal","deduplicateDirectives","directives","map","i","all","firstAt","d","arguments","mergeDirectives","d1","d2","reverseOrder","reverseDirectives","asNext","asFirst","existingDirectiveIndex","existingDirective","validateInputs","node","existingNode","printedNode","description","undefined","printedExistingNode","leaveInputs","RegExp","sameArguments","replace","Error","mergeDirective","locations","filterFn","val","mergeEnumValues","first","second","consistentEnumMerge","reversed","enumValueMap","Map","firstValue","set","secondValue","enumValue","has","get","mergeEnum","e1","e2","convertExtensions","loc","ENUM_TYPE_DEFINITION","isStringTypes","types","isSourceTypes","extractType","type","visitedType","LIST_TYPE","isWrappingTypeNode","NAMED_TYPE","isListTypeNode","isNonNullTypeNode","NON_NULL_TYPE","printTypeNode","CompareVal","defaultStringComparator","b","A_EQUALS_B","A_SMALLER_THAN_B","A_GREATER_THAN_B","fieldAlreadyExists","fieldsArr","otherField","field","ignoreFieldConflicts","t1","t2","mergeFields","f1","f2","existing","f","throwOnConflict","preventConflicts","includes","ignoreNullability","aType","bType","safeChangeForFieldType","oldType","newType","toString","ofType","mergeInputType","fields","e","message","INPUT_OBJECT_TYPE_DEFINITION","mergeInterface","INTERFACE_TYPE_DEFINITION","alreadyExists","arr","other","mergeNamedTypeArray","mergeType","interfaces","OBJECT_TYPE_DEFINITION","mergeScalar","SCALAR_TYPE_DEFINITION","mergeUnion","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","DEFAULT_OPERATION_TYPE_NAME_MAP","query","mutation","subscription","mergeOperationTypes","opNodeList","existingOpNodeList","finalOpNodeList","opNodeType","opNode","n","operation","mergeSchemaDefs","SCHEMA_DEFINITION","SCHEMA_EXTENSION","operationTypes","schemaDefSymbol","isNamedDefinitionNode","definitionNode","mergeGraphQLNodes","nodes","_a","_b","_c","mergedResultMap","nodeDefinition","commentDescriptions","OBJECT_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","SCALAR_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","DIRECTIVE_DEFINITION","mergeTypeDefs","typeSource","doc","DOCUMENT","definitions","mergeGraphQLTypes","useSchemaDefinition","forceSchemaDefinition","visitTypeSources","allNodes","visitedTypeSources","Set","add","documentNode","mergedNodes","schemaDef","opTypeDefNodeType","opTypeDefNode","operationType","possibleRootTypeName","existingPossibleRootType","OPERATION_TYPE_DEFINITION","NAME","mergedNodeDefinitions","Object","sortFn","travelSchemaPossibleExtensions","schema","hooks","onSchema","typesMap","getTypeMap","entries","isPredefinedScalar","isIntrospection","onObjectType","getFields","onObjectField","onObjectFieldArg","onInterface","onInterfaceField","onInterfaceFieldArg","onInputType","onInputFieldType","onUnion","onScalar","onEnum","getValues","onEnumValue","mergeExtensions","extensions","applyExtensionObject","obj","applyExtensions","schemaExtensions","data","getType","fieldData","argData","valueName","valueData","getValue","extractExtensionsFromSchema"],"mappings":"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","sourcesContent":["import { mergeDeep, isSome, compareNodes, collectComment, resetComments, printWithComments, getDocumentNodeFromSchema, isDocumentNode } from '@graphql-tools/utils';\nimport { print, Kind, Source, isSchema, parse, isDefinitionNode, isScalarType, isSpecifiedScalarType, isIntrospectionType, isObjectType, isInterfaceType, isInputObjectType, isUnionType, isEnumType } from 'graphql';\n\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\nfunction mergeResolvers(resolversDefinitions, options) {\n    if (!resolversDefinitions || (Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0)) {\n        return {};\n    }\n    if (!Array.isArray(resolversDefinitions)) {\n        return resolversDefinitions;\n    }\n    if (resolversDefinitions.length === 1) {\n        return resolversDefinitions[0] || {};\n    }\n    const resolvers = new Array();\n    for (let resolversDefinition of resolversDefinitions) {\n        if (Array.isArray(resolversDefinition)) {\n            resolversDefinition = mergeResolvers(resolversDefinition);\n        }\n        if (typeof resolversDefinition === 'object' && resolversDefinition) {\n            resolvers.push(resolversDefinition);\n        }\n    }\n    const result = mergeDeep(resolvers, true);\n    if (options === null || options === void 0 ? void 0 : options.exclusions) {\n        for (const exclusion of options.exclusions) {\n            const [typeName, fieldName] = exclusion.split('.');\n            if (!fieldName || fieldName === '*') {\n                delete result[typeName];\n            }\n            else if (result[typeName]) {\n                delete result[typeName][fieldName];\n            }\n        }\n    }\n    return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n    const result = deduplicateArguments([...args2, ...args1].filter(isSome));\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\nfunction deduplicateArguments(args) {\n    return args.reduce((acc, current) => {\n        const dup = acc.find(arg => arg.name.value === current.name.value);\n        if (!dup) {\n            return acc.concat([current]);\n        }\n        return acc;\n    }, []);\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments$1(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(isSome);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext]);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nfunction validateInputs(node, existingNode) {\n    const printedNode = print({\n        ...node,\n        description: undefined,\n    });\n    const printedExistingNode = print({\n        ...existingNode,\n        description: undefined,\n    });\n    // eslint-disable-next-line\n    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n    if (!sameArguments) {\n        throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n    }\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        validateInputs(node, existingNode);\n        return {\n            ...node,\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n    if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {\n        const reversed = [];\n        if (first) {\n            reversed.push(...first);\n        }\n        first = second;\n        second = reversed;\n    }\n    const enumValueMap = new Map();\n    if (first) {\n        for (const firstValue of first) {\n            enumValueMap.set(firstValue.name.value, firstValue);\n        }\n    }\n    if (second) {\n        for (const secondValue of second) {\n            const enumValue = secondValue.name.value;\n            if (enumValueMap.has(enumValue)) {\n                const firstValue = enumValueMap.get(enumValue);\n                firstValue.description = secondValue.description || firstValue.description;\n                firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n            }\n            else {\n                enumValueMap.set(enumValue, secondValue);\n            }\n        }\n    }\n    const result = [...enumValueMap.values()];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n    if (e2) {\n        return {\n            name: e1.name,\n            description: e1['description'] || e2['description'],\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition'\n                ? 'EnumTypeDefinition'\n                : 'EnumTypeExtension',\n            loc: e1.loc,\n            directives: mergeDirectives(e1.directives, e2.directives, config),\n            values: mergeEnumValues(e1.values, e2.values, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...e1,\n            kind: Kind.ENUM_TYPE_DEFINITION,\n        }\n        : e1;\n}\n\nfunction isStringTypes(types) {\n    return typeof types === 'string';\n}\nfunction isSourceTypes(types) {\n    return types instanceof Source;\n}\nfunction extractType(type) {\n    let visitedType = type;\n    while (visitedType.kind === Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n        visitedType = visitedType.type;\n    }\n    return visitedType;\n}\nfunction isWrappingTypeNode(type) {\n    return type.kind !== Kind.NAMED_TYPE;\n}\nfunction isListTypeNode(type) {\n    return type.kind === Kind.LIST_TYPE;\n}\nfunction isNonNullTypeNode(type) {\n    return type.kind === Kind.NON_NULL_TYPE;\n}\nfunction printTypeNode(type) {\n    if (isListTypeNode(type)) {\n        return `[${printTypeNode(type.type)}]`;\n    }\n    if (isNonNullTypeNode(type)) {\n        return `${printTypeNode(type.type)}!`;\n    }\n    return type.name.value;\n}\nvar CompareVal;\n(function (CompareVal) {\n    CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n    CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n    CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(CompareVal || (CompareVal = {}));\nfunction defaultStringComparator(a, b) {\n    if (a == null && b == null) {\n        return CompareVal.A_EQUALS_B;\n    }\n    if (a == null) {\n        return CompareVal.A_SMALLER_THAN_B;\n    }\n    if (b == null) {\n        return CompareVal.A_GREATER_THAN_B;\n    }\n    if (a < b)\n        return CompareVal.A_SMALLER_THAN_B;\n    if (a > b)\n        return CompareVal.A_GREATER_THAN_B;\n    return CompareVal.A_EQUALS_B;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n    const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n    if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n        const t1 = extractType(result.type);\n        const t2 = extractType(otherField.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n    }\n    return !!result;\n}\nfunction mergeFields(type, f1, f2, config) {\n    const result = [];\n    if (f2 != null) {\n        result.push(...f2);\n    }\n    if (f1 != null) {\n        for (const field of f1) {\n            if (fieldAlreadyExists(result, field, config)) {\n                const existing = result.find((f) => f.name.value === field.name.value);\n                if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n                    if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n                        preventConflicts(type, existing, field, false);\n                    }\n                    else {\n                        preventConflicts(type, existing, field, true);\n                    }\n                    if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n                        existing.type = field.type;\n                    }\n                }\n                existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n                existing.directives = mergeDirectives(field.directives, existing.directives, config);\n                existing.description = field.description || existing.description;\n            }\n            else {\n                result.push(field);\n            }\n        }\n    }\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    if (config && config.exclusions) {\n        const exclusions = config.exclusions;\n        return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = printTypeNode(a.type);\n    const bType = printTypeNode(b.type);\n    if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n    }\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if (isNonNullTypeNode(newType)) {\n        const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if (isNonNullTypeNode(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if (isListTypeNode(oldType)) {\n        return ((isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            (isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'InputObjectTypeDefinition' ||\n                    existingNode.kind === 'InputObjectTypeDefinition'\n                    ? 'InputObjectTypeDefinition'\n                    : 'InputObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'InterfaceTypeDefinition' ||\n                    existingNode.kind === 'InterfaceTypeDefinition'\n                    ? 'InterfaceTypeDefinition'\n                    : 'InterfaceTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: Kind.INTERFACE_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction alreadyExists(arr, other) {\n    return !!arr.find(i => i.name.value === other.name.value);\n}\nfunction mergeNamedTypeArray(first = [], second = [], config = {}) {\n    const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'ObjectTypeDefinition' ||\n                    existingNode.kind === 'ObjectTypeDefinition'\n                    ? 'ObjectTypeDefinition'\n                    : 'ObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n                interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: Kind.OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeScalar(node, existingNode, config) {\n    if (existingNode) {\n        return {\n            name: node.name,\n            description: node['description'] || existingNode['description'],\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                node.kind === 'ScalarTypeDefinition' ||\n                existingNode.kind === 'ScalarTypeDefinition'\n                ? 'ScalarTypeDefinition'\n                : 'ScalarTypeExtension',\n            loc: node.loc,\n            directives: mergeDirectives(node.directives, existingNode.directives, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: Kind.SCALAR_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeUnion(first, second, config) {\n    if (second) {\n        return {\n            name: first.name,\n            description: first['description'] || second['description'],\n            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n            directives: mergeDirectives(first.directives, second.directives, config),\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition'\n                ? Kind.UNION_TYPE_DEFINITION\n                : Kind.UNION_TYPE_EXTENSION,\n            loc: first.loc,\n            types: mergeNamedTypeArray(first.types, second.types, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...first,\n            kind: Kind.UNION_TYPE_DEFINITION,\n        }\n        : first;\n}\n\nconst DEFAULT_OPERATION_TYPE_NAME_MAP = {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription',\n};\nfunction mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {\n    const finalOpNodeList = [];\n    for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n        const opNode = opNodeList.find(n => n.operation === opNodeType) || existingOpNodeList.find(n => n.operation === opNodeType);\n        if (opNode) {\n            finalOpNodeList.push(opNode);\n        }\n    }\n    return finalOpNodeList;\n}\nfunction mergeSchemaDefs(node, existingNode, config) {\n    if (existingNode) {\n        return {\n            kind: node.kind === Kind.SCHEMA_DEFINITION || existingNode.kind === Kind.SCHEMA_DEFINITION\n                ? Kind.SCHEMA_DEFINITION\n                : Kind.SCHEMA_EXTENSION,\n            description: node['description'] || existingNode['description'],\n            directives: mergeDirectives(node.directives, existingNode.directives, config),\n            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes),\n        };\n    }\n    return ((config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: Kind.SCHEMA_DEFINITION,\n        }\n        : node);\n}\n\nconst schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\nfunction isNamedDefinitionNode(definitionNode) {\n    return 'name' in definitionNode;\n}\nfunction mergeGraphQLNodes(nodes, config) {\n    var _a, _b, _c;\n    const mergedResultMap = {};\n    for (const nodeDefinition of nodes) {\n        if (isNamedDefinitionNode(nodeDefinition)) {\n            const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;\n            if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n                collectComment(nodeDefinition);\n            }\n            if (name == null) {\n                continue;\n            }\n            if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {\n                delete mergedResultMap[name];\n            }\n            else {\n                switch (nodeDefinition.kind) {\n                    case Kind.OBJECT_TYPE_DEFINITION:\n                    case Kind.OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case Kind.ENUM_TYPE_DEFINITION:\n                    case Kind.ENUM_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case Kind.UNION_TYPE_DEFINITION:\n                    case Kind.UNION_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case Kind.SCALAR_TYPE_DEFINITION:\n                    case Kind.SCALAR_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n                    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case Kind.INTERFACE_TYPE_DEFINITION:\n                    case Kind.INTERFACE_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case Kind.DIRECTIVE_DEFINITION:\n                        mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);\n                        break;\n                }\n            }\n        }\n        else if (nodeDefinition.kind === Kind.SCHEMA_DEFINITION || nodeDefinition.kind === Kind.SCHEMA_EXTENSION) {\n            mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);\n        }\n    }\n    return mergedResultMap;\n}\n\nfunction mergeTypeDefs(typeSource, config) {\n    resetComments();\n    const doc = {\n        kind: Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(typeSource, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        result = printWithComments(doc);\n    }\n    else {\n        result = doc;\n    }\n    resetComments();\n    return result;\n}\nfunction visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set()) {\n    if (typeSource && !visitedTypeSources.has(typeSource)) {\n        visitedTypeSources.add(typeSource);\n        if (typeof typeSource === 'function') {\n            visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n        }\n        else if (Array.isArray(typeSource)) {\n            for (const type of typeSource) {\n                visitTypeSources(type, options, allNodes, visitedTypeSources);\n            }\n        }\n        else if (isSchema(typeSource)) {\n            const documentNode = getDocumentNodeFromSchema(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {\n            const documentNode = parse(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if (typeof typeSource === 'object' && isDefinitionNode(typeSource)) {\n            allNodes.push(typeSource);\n        }\n        else if (isDocumentNode(typeSource)) {\n            visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n        }\n        else {\n            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n        }\n    }\n    return allNodes;\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n    var _a, _b, _c;\n    resetComments();\n    const allNodes = visitTypeSources(typeSource, config);\n    const mergedNodes = mergeGraphQLNodes(allNodes, config);\n    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n        // XXX: right now we don't handle multiple schema definitions\n        const schemaDef = mergedNodes[schemaDefSymbol] || {\n            kind: Kind.SCHEMA_DEFINITION,\n            operationTypes: [],\n        };\n        const operationTypes = schemaDef.operationTypes;\n        for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n            const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n            if (!opTypeDefNode) {\n                const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n                const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n                    operationTypes.push({\n                        kind: Kind.OPERATION_TYPE_DEFINITION,\n                        type: {\n                            kind: Kind.NAMED_TYPE,\n                            name: existingPossibleRootType.name,\n                        },\n                        operation: opTypeDefNodeType,\n                    });\n                }\n            }\n        }\n        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n            mergedNodes[schemaDefSymbol] = schemaDef;\n        }\n    }\n    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n        mergedNodes[schemaDefSymbol] = {\n            kind: Kind.SCHEMA_DEFINITION,\n            operationTypes: [\n                {\n                    kind: Kind.OPERATION_TYPE_DEFINITION,\n                    operation: 'query',\n                    type: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: 'Query',\n                        },\n                    },\n                },\n            ],\n        };\n    }\n    const mergedNodeDefinitions = Object.values(mergedNodes);\n    if (config === null || config === void 0 ? void 0 : config.sort) {\n        const sortFn = typeof config.sort === 'function' ? config.sort : defaultStringComparator;\n        mergedNodeDefinitions.sort((a, b) => { var _a, _b; return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value); });\n    }\n    return mergedNodeDefinitions;\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n    hooks.onSchema(schema);\n    const typesMap = schema.getTypeMap();\n    for (const [, type] of Object.entries(typesMap)) {\n        const isPredefinedScalar = isScalarType(type) && isSpecifiedScalarType(type);\n        const isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (isObjectType(type)) {\n            hooks.onObjectType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onObjectField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onObjectFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (isInterfaceType(type)) {\n            hooks.onInterface(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInterfaceField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onInterfaceFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (isInputObjectType(type)) {\n            hooks.onInputType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInputFieldType(type, field);\n            }\n        }\n        else if (isUnionType(type)) {\n            hooks.onUnion(type);\n        }\n        else if (isScalarType(type)) {\n            hooks.onScalar(type);\n        }\n        else if (isEnumType(type)) {\n            hooks.onEnum(type);\n            for (const value of type.getValues()) {\n                hooks.onEnumValue(type, value);\n            }\n        }\n    }\n}\nfunction mergeExtensions(extensions) {\n    return mergeDeep(extensions);\n}\nfunction applyExtensionObject(obj, extensions) {\n    if (!obj) {\n        return;\n    }\n    obj.extensions = mergeDeep([obj.extensions || {}, extensions || {}]);\n}\nfunction applyExtensions(schema, extensions) {\n    applyExtensionObject(schema, extensions.schemaExtensions);\n    for (const [typeName, data] of Object.entries(extensions.types || {})) {\n        const type = schema.getType(typeName);\n        if (type) {\n            applyExtensionObject(type, data.extensions);\n            if (data.type === 'object' || data.type === 'interface') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    if (field) {\n                        applyExtensionObject(field, fieldData.extensions);\n                        for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n                            applyExtensionObject(field.args.find(a => a.name === arg), argData);\n                        }\n                    }\n                }\n            }\n            else if (data.type === 'input') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    applyExtensionObject(field, fieldData.extensions);\n                }\n            }\n            else if (data.type === 'enum') {\n                for (const [valueName, valueData] of Object.entries(data.values)) {\n                    const value = type.getValue(valueName);\n                    applyExtensionObject(value, valueData);\n                }\n            }\n        }\n    }\n    return schema;\n}\nfunction extractExtensionsFromSchema(schema) {\n    const result = {\n        schemaExtensions: {},\n        types: {},\n    };\n    travelSchemaPossibleExtensions(schema, {\n        onSchema: schema => (result.schemaExtensions = schema.extensions || {}),\n        onObjectType: type => (result.types[type.name] = { fields: {}, type: 'object', extensions: type.extensions || {} }),\n        onObjectField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onObjectFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {}),\n        onInterface: type => (result.types[type.name] = { fields: {}, type: 'interface', extensions: type.extensions || {} }),\n        onInterfaceField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onInterfaceFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] =\n            arg.extensions || {}),\n        onEnum: type => (result.types[type.name] = { values: {}, type: 'enum', extensions: type.extensions || {} }),\n        onEnumValue: (type, value) => (result.types[type.name].values[value.name] = value.extensions || {}),\n        onScalar: type => (result.types[type.name] = { type: 'scalar', extensions: type.extensions || {} }),\n        onUnion: type => (result.types[type.name] = { type: 'union', extensions: type.extensions || {} }),\n        onInputType: type => (result.types[type.name] = { fields: {}, type: 'input', extensions: type.extensions || {} }),\n        onInputFieldType: (type, field) => (result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }),\n    });\n    return result;\n}\n\nexport { CompareVal, applyExtensions, defaultStringComparator, extractExtensionsFromSchema, extractType, isListTypeNode, isNamedDefinitionNode, isNonNullTypeNode, isSourceTypes, isStringTypes, isWrappingTypeNode, mergeArguments, mergeDirective, mergeDirectives, mergeEnum, mergeEnumValues, mergeExtensions, mergeFields, mergeGraphQLNodes, mergeGraphQLTypes, mergeInputType, mergeInterface, mergeNamedTypeArray, mergeResolvers, mergeScalar, mergeType, mergeTypeDefs, mergeUnion, printTypeNode, schemaDefSymbol, travelSchemaPossibleExtensions };\n"]},"metadata":{},"sourceType":"module"}