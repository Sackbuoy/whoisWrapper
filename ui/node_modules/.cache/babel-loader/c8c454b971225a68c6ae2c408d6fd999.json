{"ast":null,"code":"'use strict';\n\nconst {\n  BalancedPoolMissingUpstreamError\n} = require('./core/errors');\n\nconst Dispatcher = require('./dispatcher');\n\nconst Pool = require('./pool');\n\nconst kPools = Symbol('kPools');\nconst kPoolOpts = Symbol('kPoolOpts');\nconst kUpstream = Symbol('kUpstream');\nconst kNeedDrain = Symbol('kNeedDrain');\n\nclass BalancedPool extends Dispatcher {\n  constructor() {\n    let upstreams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this[kPools] = [];\n    this[kPoolOpts] = opts;\n    this[kNeedDrain] = false;\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams];\n    }\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream);\n    }\n  }\n\n  addUpstream(upstream) {\n    var _this = this;\n\n    if (this[kPools].find(pool => pool[kUpstream] === upstream)) {\n      return this;\n    }\n\n    const pool = new Pool(upstream, Object.assign({}, this[kPoolOpts]));\n    pool[kUpstream] = upstream;\n    pool.on('connect', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.emit('connect', ...args);\n    });\n    pool.on('disconnect', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.emit('disconnect', ...args);\n    });\n    pool.on('drain', function () {\n      pool[kNeedDrain] = false;\n\n      if (_this[kNeedDrain]) {\n        _this[kNeedDrain] = false;\n\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        _this.emit('drain', ...args);\n      }\n    });\n    this[kPools].push(pool);\n    return this;\n  }\n\n  dispatch(opts, handler) {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kPools].length === 0) {\n      throw new BalancedPoolMissingUpstreamError();\n    }\n\n    const pool = this[kPools].find(pool => !pool[kNeedDrain]) || this[kPools][0];\n\n    if (!pool.dispatch(opts, handler)) {\n      pool[kNeedDrain] = true;\n      this[kNeedDrain] = true;\n    }\n\n    this[kPools].splice(this[kPools].indexOf(pool), 1);\n    this[kPools].push(pool);\n    return !this[kNeedDrain];\n  }\n\n  removeUpstream(upstream) {\n    const pool = this[kPools].find(pool => pool[kUpstream] === upstream);\n    const idx = this[kPools].indexOf(pool);\n    this[kPools].splice(idx, 1);\n    pool.close();\n    return this;\n  }\n\n  get upstreams() {\n    return this[kPools].map(p => p[kUpstream]);\n  }\n\n  get destroyed() {\n    return this[kPools].reduce((acc, pool) => acc && pool.destroyed, true);\n  }\n\n  get closed() {\n    return this[kPools].reduce((acc, pool) => acc && pool.closed, true);\n  }\n\n  close(cb) {\n    const p = Promise.all(this[kPools].map(p => p.close()));\n\n    if (!cb) {\n      return p;\n    }\n\n    p.then(() => process.nextTick(cb), err => process.nextTick(cb, err));\n  }\n\n  destroy(err, cb) {\n    const p = Promise.all(this[kPools].map(p => p.destroy(err)));\n\n    if (!cb) {\n      return p;\n    }\n\n    p.then(() => process.nextTick(cb));\n  }\n\n}\n\nmodule.exports = BalancedPool;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/balanced-pool.js"],"names":["BalancedPoolMissingUpstreamError","require","Dispatcher","Pool","kPools","Symbol","kPoolOpts","kUpstream","kNeedDrain","BalancedPool","constructor","upstreams","opts","Array","isArray","upstream","addUpstream","find","pool","Object","assign","on","args","emit","push","dispatch","handler","length","splice","indexOf","removeUpstream","idx","close","map","p","destroyed","reduce","acc","closed","cb","Promise","all","then","process","nextTick","err","destroy","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { BalancedPoolMissingUpstreamError } = require('./core/errors')\nconst Dispatcher = require('./dispatcher')\nconst Pool = require('./pool')\n\nconst kPools = Symbol('kPools')\nconst kPoolOpts = Symbol('kPoolOpts')\nconst kUpstream = Symbol('kUpstream')\nconst kNeedDrain = Symbol('kNeedDrain')\n\nclass BalancedPool extends Dispatcher {\n  constructor (upstreams = [], opts = {}) {\n    super()\n\n    this[kPools] = []\n    this[kPoolOpts] = opts\n    this[kNeedDrain] = false\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n  }\n\n  addUpstream (upstream) {\n    if (this[kPools].find((pool) => pool[kUpstream] === upstream)) {\n      return this\n    }\n\n    const pool = new Pool(upstream, Object.assign({}, this[kPoolOpts]))\n\n    pool[kUpstream] = upstream\n\n    pool.on('connect', (...args) => {\n      this.emit('connect', ...args)\n    })\n\n    pool.on('disconnect', (...args) => {\n      this.emit('disconnect', ...args)\n    })\n\n    pool.on('drain', (...args) => {\n      pool[kNeedDrain] = false\n\n      if (this[kNeedDrain]) {\n        this[kNeedDrain] = false\n        this.emit('drain', ...args)\n      }\n    })\n\n    this[kPools].push(pool)\n    return this\n  }\n\n  dispatch (opts, handler) {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kPools].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const pool = this[kPools].find(pool => !pool[kNeedDrain]) || this[kPools][0]\n\n    if (!pool.dispatch(opts, handler)) {\n      pool[kNeedDrain] = true\n      this[kNeedDrain] = true\n    }\n\n    this[kPools].splice(this[kPools].indexOf(pool), 1)\n    this[kPools].push(pool)\n\n    return !this[kNeedDrain]\n  }\n\n  removeUpstream (upstream) {\n    const pool = this[kPools].find((pool) => pool[kUpstream] === upstream)\n    const idx = this[kPools].indexOf(pool)\n    this[kPools].splice(idx, 1)\n    pool.close()\n    return this\n  }\n\n  get upstreams () {\n    return this[kPools].map((p) => p[kUpstream])\n  }\n\n  get destroyed () {\n    return this[kPools].reduce((acc, pool) => acc && pool.destroyed, true)\n  }\n\n  get closed () {\n    return this[kPools].reduce((acc, pool) => acc && pool.closed, true)\n  }\n\n  close (cb) {\n    const p = Promise.all(this[kPools].map((p) => p.close()))\n\n    if (!cb) {\n      return p\n    }\n\n    p.then(() => process.nextTick(cb), (err) => process.nextTick(cb, err))\n  }\n\n  destroy (err, cb) {\n    const p = Promise.all(this[kPools].map((p) => p.destroy(err)))\n\n    if (!cb) {\n      return p\n    }\n\n    p.then(() => process.nextTick(cb))\n  }\n}\n\nmodule.exports = BalancedPool\n"]},"metadata":{},"sourceType":"script"}