{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst graphql = require('graphql');\n\nconst asArray = fns => Array.isArray(fns) ? fns : fns ? [fns] : [];\n\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\n\nfunction isDocumentString(str) {\n  if (typeof str !== 'string') {\n    return false;\n  } // XXX: is-valid-path or is-glob treat SDL as a valid path\n  // (`scalar Date` for example)\n  // this why checking the extension is fast enough\n  // and prevent from parsing the string in order to find out\n  // if the string is a SDL\n\n\n  if (invalidDocRegex.test(str)) {\n    return false;\n  }\n\n  try {\n    graphql.parse(str);\n    return true;\n  } catch (e) {}\n\n  return false;\n}\n\nconst invalidPathRegex = /[‘“!%&^<=>`]/;\n\nfunction isValidPath(str) {\n  return typeof str === 'string' && !invalidPathRegex.test(str);\n}\n\nfunction compareStrings(a, b) {\n  if (String(a) < String(b)) {\n    return -1;\n  }\n\n  if (String(a) > String(b)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction nodeToString(a) {\n  var _a, _b;\n\n  let name;\n\n  if ('alias' in a) {\n    name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n  }\n\n  if (name == null && 'name' in a) {\n    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n  }\n\n  if (name == null) {\n    name = a.kind;\n  }\n\n  return name;\n}\n\nfunction compareNodes(a, b, customFn) {\n  const aStr = nodeToString(a);\n  const bStr = nodeToString(b);\n\n  if (typeof customFn === 'function') {\n    return customFn(aStr, bStr);\n  }\n\n  return compareStrings(aStr, bStr);\n}\n\nfunction isSome(input) {\n  return input != null;\n}\n\nfunction assertSome(input) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Value should be something';\n\n  if (input == null) {\n    throw new Error(message);\n  }\n}\n\nexports.AggregateError = globalThis.AggregateError;\n\nif (typeof exports.AggregateError === 'undefined') {\n  class AggregateErrorClass extends Error {\n    constructor(errors) {\n      let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      super(message);\n      this.errors = errors;\n      this.name = 'AggregateError';\n      Error.captureStackTrace(this, AggregateErrorClass);\n    }\n\n  }\n\n  exports.AggregateError = function (errors, message) {\n    return new AggregateErrorClass(errors, message);\n  };\n}\n\nfunction isAggregateError(error) {\n  return 'errors' in error && Array.isArray(error['errors']);\n} // Taken from graphql-js\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? `[function ${value.name}]` : '[function]';\n\n    case 'object':\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatError(value) {\n  if (value instanceof graphql.GraphQLError) {\n    return value.toString();\n  }\n\n  return `${value.name}: ${value.message};\\n ${value.stack}`;\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (value === null) {\n    return 'null';\n  }\n\n  if (value instanceof Error) {\n    if (isAggregateError(value)) {\n      return formatError(value) + '\\n' + formatArray(value.errors, previouslySeenValues);\n    }\n\n    return formatError(value);\n  }\n\n  if (previouslySeenValues.includes(value)) {\n    return '[Circular]';\n  }\n\n  const seenValues = [...previouslySeenValues, value];\n\n  if (isJSONable(value)) {\n    const jsonValue = value.toJSON(); // check for infinite recursion\n\n    if (jsonValue !== value) {\n      return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction isJSONable(value) {\n  return typeof value.toJSON === 'function';\n}\n\nfunction formatObject(object, seenValues) {\n  const entries = Object.entries(object);\n\n  if (entries.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  const properties = entries.map(_ref => {\n    let [key, value] = _ref;\n    return key + ': ' + formatValue(value, seenValues);\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getObjectTag(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    const name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getArgumentValues(def, node) {\n  let variableValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  const variableMap = Object.entries(variableValues).reduce((prev, _ref2) => {\n    let [key, value] = _ref2;\n    return { ...prev,\n      [key]: value\n    };\n  }, {});\n  const coercedValues = {}; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n  const argNodeMap = argumentNodes.reduce((prev, arg) => ({ ...prev,\n    [arg.name.value]: arg\n  }), {});\n\n  for (const {\n    name,\n    type: argType,\n    defaultValue\n  } of def.args) {\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (defaultValue !== undefined) {\n        coercedValues[name] = defaultValue;\n      } else if (graphql.isNonNullType(argType)) {\n        throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === graphql.Kind.NULL;\n\n    if (valueNode.kind === graphql.Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (variableValues == null || !variableMap[variableName]) {\n        if (defaultValue !== undefined) {\n          coercedValues[name] = defaultValue;\n        } else if (graphql.isNonNullType(argType)) {\n          throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && graphql.isNonNullType(argType)) {\n      throw new graphql.GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n    }\n\n    const coercedValue = graphql.valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new graphql.GraphQLError(`Argument \"${name}\" has invalid value ${graphql.print(valueNode)}.`, valueNode);\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n\nfunction getDirectivesInExtensions(node) {\n  let pathToDirectivesInExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['directives'];\n  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);\n}\n\nfunction _getDirectiveInExtensions(directivesInExtensions, directiveName) {\n  const directiveInExtensions = directivesInExtensions.filter(directiveAnnotation => directiveAnnotation.name === directiveName);\n\n  if (!directiveInExtensions.length) {\n    return undefined;\n  }\n\n  return directiveInExtensions.map(directive => {\n    var _a;\n\n    return (_a = directive.args) !== null && _a !== void 0 ? _a : {};\n  });\n}\n\nfunction getDirectiveInExtensions(node, directiveName) {\n  let pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);\n\n  if (directivesInExtensions === undefined) {\n    return undefined;\n  }\n\n  if (Array.isArray(directivesInExtensions)) {\n    return _getDirectiveInExtensions(directivesInExtensions, directiveName);\n  } // Support condensed format by converting to longer format\n  // The condensed format does not preserve ordering of directives when  repeatable directives are used.\n  // See https://github.com/ardatan/graphql-tools/issues/2534\n\n\n  const reformattedDirectivesInExtensions = [];\n\n  for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {\n    if (Array.isArray(argsOrArrayOfArgs)) {\n      for (const args of argsOrArrayOfArgs) {\n        reformattedDirectivesInExtensions.push({\n          name,\n          args\n        });\n      }\n    } else {\n      reformattedDirectivesInExtensions.push({\n        name,\n        args: argsOrArrayOfArgs\n      });\n    }\n  }\n\n  return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);\n}\n\nfunction getDirectives(schema, node) {\n  let pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n\n  if (directivesInExtensions != null && directivesInExtensions.length > 0) {\n    return directivesInExtensions;\n  }\n\n  const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n  const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n    schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n    return schemaDirectiveMap;\n  }, {});\n  let astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [...astNodes, ...node.extensionASTNodes];\n  }\n\n  const result = [];\n\n  for (const astNode of astNodes) {\n    if (astNode.directives) {\n      for (const directiveNode of astNode.directives) {\n        const schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n\n        if (schemaDirective) {\n          result.push({\n            name: directiveNode.name.value,\n            args: getArgumentValues(schemaDirective, directiveNode)\n          });\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getDirective(schema, node, directiveName) {\n  let pathToDirectivesInExtensions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['directives'];\n  const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);\n\n  if (directiveInExtensions != null) {\n    return directiveInExtensions;\n  }\n\n  const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;\n\n  if (schemaDirective == null) {\n    return undefined;\n  }\n\n  let astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [...astNodes, ...node.extensionASTNodes];\n  }\n\n  const result = [];\n\n  for (const astNode of astNodes) {\n    if (astNode.directives) {\n      for (const directiveNode of astNode.directives) {\n        if (directiveNode.name.value === directiveName) {\n          result.push(getArgumentValues(schemaDirective, directiveNode));\n        }\n      }\n    }\n  }\n\n  if (!result.length) {\n    return undefined;\n  }\n\n  return result;\n}\n\nfunction parseDirectiveValue(value) {\n  switch (value.kind) {\n    case graphql.Kind.INT:\n      return parseInt(value.value);\n\n    case graphql.Kind.FLOAT:\n      return parseFloat(value.value);\n\n    case graphql.Kind.BOOLEAN:\n      return Boolean(value.value);\n\n    case graphql.Kind.STRING:\n    case graphql.Kind.ENUM:\n      return value.value;\n\n    case graphql.Kind.LIST:\n      return value.values.map(v => parseDirectiveValue(v));\n\n    case graphql.Kind.OBJECT:\n      return value.fields.reduce((prev, v) => ({ ...prev,\n        [v.name.value]: parseDirectiveValue(v.value)\n      }), {});\n\n    case graphql.Kind.NULL:\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction getFieldsWithDirectives(documentNode) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = {};\n  let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n\n  if (options.includeInputTypes) {\n    selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n  }\n\n  const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n\n  for (const type of allTypes) {\n    const typeName = type.name.value;\n\n    if (type.fields == null) {\n      continue;\n    }\n\n    for (const field of type.fields) {\n      if (field.directives && field.directives.length > 0) {\n        const fieldName = field.name.value;\n        const key = `${typeName}.${fieldName}`;\n        const directives = field.directives.map(d => ({\n          name: d.name.value,\n          args: (d.arguments || []).reduce((prev, arg) => ({ ...prev,\n            [arg.name.value]: parseDirectiveValue(arg.value)\n          }), {})\n        }));\n        result[key] = directives;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n  const allTypesMap = schema.getTypeMap();\n  const result = [];\n\n  for (const graphqlTypeName in allTypesMap) {\n    const graphqlType = allTypesMap[graphqlTypeName];\n\n    if (graphql.isObjectType(graphqlType)) {\n      const allInterfaces = graphqlType.getInterfaces();\n\n      if (allInterfaces.find(int => int.name === interfaceName)) {\n        result.push(graphqlType.name);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction astFromType(type) {\n  if (graphql.isNonNullType(type)) {\n    const innerType = astFromType(type.ofType);\n\n    if (innerType.kind === graphql.Kind.NON_NULL_TYPE) {\n      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n    }\n\n    return {\n      kind: graphql.Kind.NON_NULL_TYPE,\n      type: innerType\n    };\n  } else if (graphql.isListType(type)) {\n    return {\n      kind: graphql.Kind.LIST_TYPE,\n      type: astFromType(type.ofType)\n    };\n  }\n\n  return {\n    kind: graphql.Kind.NAMED_TYPE,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    }\n  };\n}\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\n\n\nfunction astFromValueUntyped(value) {\n  // only explicit null, not undefined, NaN\n  if (value === null) {\n    return {\n      kind: graphql.Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if (Array.isArray(value)) {\n    const valuesNodes = [];\n\n    for (const item of value) {\n      const itemNode = astFromValueUntyped(item);\n\n      if (itemNode != null) {\n        valuesNodes.push(itemNode);\n      }\n    }\n\n    return {\n      kind: graphql.Kind.LIST,\n      values: valuesNodes\n    };\n  }\n\n  if (typeof value === 'object') {\n    const fieldNodes = [];\n\n    for (const fieldName in value) {\n      const fieldValue = value[fieldName];\n      const ast = astFromValueUntyped(fieldValue);\n\n      if (ast) {\n        fieldNodes.push({\n          kind: graphql.Kind.OBJECT_FIELD,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: fieldName\n          },\n          value: ast\n        });\n      }\n    }\n\n    return {\n      kind: graphql.Kind.OBJECT,\n      fields: fieldNodes\n    };\n  } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n  if (typeof value === 'boolean') {\n    return {\n      kind: graphql.Kind.BOOLEAN,\n      value\n    };\n  } // JavaScript numbers can be Int or Float values.\n\n\n  if (typeof value === 'number' && isFinite(value)) {\n    const stringNum = String(value);\n    return integerStringRegExp.test(stringNum) ? {\n      kind: graphql.Kind.INT,\n      value: stringNum\n    } : {\n      kind: graphql.Kind.FLOAT,\n      value: stringNum\n    };\n  }\n\n  if (typeof value === 'string') {\n    return {\n      kind: graphql.Kind.STRING,\n      value\n    };\n  }\n\n  throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\n\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n\nfunction memoize1(fn) {\n  const memoize1cache = new WeakMap();\n  return function memoized(a1) {\n    const cachedValue = memoize1cache.get(a1);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1);\n      memoize1cache.set(a1, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize2(fn) {\n  const memoize2cache = new WeakMap();\n  return function memoized(a1, a2) {\n    let cache2 = memoize2cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2cache.set(a1, cache2);\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize3(fn) {\n  const memoize3Cache = new WeakMap();\n  return function memoized(a1, a2, a3) {\n    let cache2 = memoize3Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize3Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache3.get(a3);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize4(fn) {\n  const memoize4Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4) {\n    let cache2 = memoize4Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize4Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache4.get(a4);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize5(fn) {\n  const memoize5Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4, a5) {\n    let cache2 = memoize5Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize5Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache5 = cache4.get(a4);\n\n    if (!cache5) {\n      cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache5.get(a5);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nconst memoize2of4cache = new WeakMap();\n\nfunction memoize2of4(fn) {\n  return function memoized(a1, a2, a3, a4) {\n    let cache2 = memoize2of4cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2of4cache.set(a1, cache2);\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction getDefinedRootType(schema, operation) {\n  const rootTypeMap = getRootTypeMap(schema);\n  const rootType = rootTypeMap.get(operation);\n\n  if (rootType == null) {\n    throw new Error(`Root type for operation \"${operation}\" not defined by the given schema.`);\n  }\n\n  return rootType;\n}\n\nconst getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n  const rootTypes = getRootTypes(schema);\n  return new Set([...rootTypes].map(type => type.name));\n});\nconst getRootTypes = memoize1(function getRootTypes(schema) {\n  const rootTypeMap = getRootTypeMap(schema);\n  return new Set(rootTypeMap.values());\n});\nconst getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n  const rootTypeMap = new Map();\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    rootTypeMap.set('query', queryType);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    rootTypeMap.set('mutation', mutationType);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    rootTypeMap.set('subscription', subscriptionType);\n  }\n\n  return rootTypeMap;\n});\n\nfunction getDocumentNodeFromSchema(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n  const typesMap = schema.getTypeMap();\n  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n  const definitions = schemaNode != null ? [schemaNode] : [];\n  const directives = schema.getDirectives();\n\n  for (const directive of directives) {\n    if (graphql.isSpecifiedDirective(directive)) {\n      continue;\n    }\n\n    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n  }\n\n  for (const typeName in typesMap) {\n    const type = typesMap[typeName];\n    const isPredefinedScalar = graphql.isSpecifiedScalarType(type);\n    const isIntrospection = graphql.isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    }\n\n    if (graphql.isObjectType(type)) {\n      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isInterfaceType(type)) {\n      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isUnionType(type)) {\n      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isInputObjectType(type)) {\n      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isEnumType(type)) {\n      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isScalarType(type)) {\n      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n    } else {\n      throw new Error(`Unknown type ${type}.`);\n    }\n  }\n\n  return {\n    kind: graphql.Kind.DOCUMENT,\n    definitions\n  };\n} // this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\n\n\nfunction printSchemaWithDirectives(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const documentNode = getDocumentNodeFromSchema(schema, options);\n  return graphql.print(documentNode);\n}\n\nfunction astFromSchema(schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  const operationTypeMap = new Map([['query', undefined], ['mutation', undefined], ['subscription', undefined]]);\n  const nodes = [];\n\n  if (schema.astNode != null) {\n    nodes.push(schema.astNode);\n  }\n\n  if (schema.extensionASTNodes != null) {\n    for (const extensionASTNode of schema.extensionASTNodes) {\n      nodes.push(extensionASTNode);\n    }\n  }\n\n  for (const node of nodes) {\n    if (node.operationTypes) {\n      for (const operationTypeDefinitionNode of node.operationTypes) {\n        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n      }\n    }\n  }\n\n  const rootTypeMap = getRootTypeMap(schema);\n\n  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n    const rootType = rootTypeMap.get(operationTypeNode);\n\n    if (rootType != null) {\n      const rootTypeAST = astFromType(rootType);\n\n      if (operationTypeDefinitionNode != null) {\n        operationTypeDefinitionNode.type = rootTypeAST;\n      } else {\n        operationTypeMap.set(operationTypeNode, {\n          kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n          operation: operationTypeNode,\n          type: rootTypeAST\n        });\n      }\n    }\n  }\n\n  const operationTypes = [...operationTypeMap.values()].filter(isSome);\n  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n\n  if (!operationTypes.length && !directives.length) {\n    return null;\n  }\n\n  const schemaNode = {\n    kind: operationTypes != null ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,\n    operationTypes,\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  }; // This code is so weird because it needs to support GraphQL.js 14\n  // In GraphQL.js 14 there is no `description` value on schemaNode\n\n  schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {\n    kind: graphql.Kind.STRING,\n    value: schema.description,\n    block: true\n  } : undefined;\n  return schemaNode;\n}\n\nfunction astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c, _d;\n\n  return {\n    kind: graphql.Kind.DIRECTIVE_DEFINITION,\n    description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {\n      kind: graphql.Kind.STRING,\n      value: directive.description\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: directive.name\n    },\n    arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n    repeatable: directive.isRepeatable,\n    locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map(location => ({\n      kind: graphql.Kind.NAME,\n      value: location\n    }))) || []\n  };\n}\n\nfunction getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  let nodes = [];\n\n  if (entity.astNode != null) {\n    nodes.push(entity.astNode);\n  }\n\n  if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n    nodes = nodes.concat(entity.extensionASTNodes);\n  }\n\n  let directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = [];\n\n    for (const node of nodes) {\n      if (node.directives) {\n        directives.push(...node.directives);\n      }\n    }\n  }\n\n  return directives;\n}\n\nfunction getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  let directiveNodesBesidesDeprecated = [];\n  let deprecatedDirectiveNode = null;\n  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  let directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n  }\n\n  if (directives != null) {\n    directiveNodesBesidesDeprecated = directives.filter(directive => directive.name.value !== 'deprecated');\n\n    if (entity.deprecationReason != null) {\n      deprecatedDirectiveNode = (_b = directives.filter(directive => directive.name.value === 'deprecated')) === null || _b === void 0 ? void 0 : _b[0];\n    }\n  }\n\n  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {\n    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n  }\n\n  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\n\nfunction astFromArg(arg, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {\n      kind: graphql.Kind.STRING,\n      value: arg.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: arg.name\n    },\n    type: astFromType(arg.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    defaultValue: arg.defaultValue !== undefined ? (_c = graphql.astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,\n    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n    interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  const node = {\n    kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n\n  if ('getInterfaces' in type) {\n    node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n  }\n\n  return node;\n}\n\nfunction astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.UNION_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    types: type.getTypes().map(type => astFromType(type))\n  };\n}\n\nfunction astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.ENUM_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n  const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];\n  const specifiedByValue = type['specifiedByUrl'] || type['specifiedByURL'];\n\n  if (specifiedByValue && !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n    const specifiedByArgs = {\n      url: specifiedByValue\n    };\n    directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n  }\n\n  return {\n    kind: graphql.Kind.SCALAR_TYPE_DEFINITION,\n    description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  };\n}\n\nfunction astFromField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.FIELD_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: graphql.Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: field.name\n    },\n    arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInputField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: graphql.Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: field.name\n    },\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    defaultValue: (_c = graphql.astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined\n  };\n}\n\nfunction astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.ENUM_VALUE_DEFINITION,\n    description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {\n      kind: graphql.Kind.STRING,\n      value: value.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: value.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction makeDeprecatedDirective(deprecationReason) {\n  return makeDirectiveNode('deprecated', {\n    reason: deprecationReason\n  }, graphql.GraphQLDeprecatedDirective);\n}\n\nfunction makeDirectiveNode(name, args, directive) {\n  const directiveArguments = [];\n\n  if (directive != null) {\n    for (const arg of directive.args) {\n      const argName = arg.name;\n      const argValue = args[argName];\n\n      if (argValue !== undefined) {\n        const value = graphql.astFromValue(argValue, arg.type);\n\n        if (value) {\n          directiveArguments.push({\n            kind: graphql.Kind.ARGUMENT,\n            name: {\n              kind: graphql.Kind.NAME,\n              value: argName\n            },\n            value\n          });\n        }\n      }\n    }\n  } else {\n    for (const argName in args) {\n      const argValue = args[argName];\n      const value = astFromValueUntyped(argValue);\n\n      if (value) {\n        directiveArguments.push({\n          kind: graphql.Kind.ARGUMENT,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: argName\n          },\n          value\n        });\n      }\n    }\n  }\n\n  return {\n    kind: graphql.Kind.DIRECTIVE,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: name\n    },\n    arguments: directiveArguments\n  };\n}\n\nfunction makeDirectiveNodes(schema, directiveValues) {\n  const directiveNodes = [];\n\n  for (const directiveName in directiveValues) {\n    const arrayOrSingleValue = directiveValues[directiveName];\n    const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n\n    if (Array.isArray(arrayOrSingleValue)) {\n      for (const value of arrayOrSingleValue) {\n        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n      }\n    } else {\n      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n    }\n  }\n\n  return directiveNodes;\n}\n\nasync function validateGraphQlDocuments(schema, documentFiles) {\n  let effectiveRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createDefaultRules();\n  const allFragmentMap = new Map();\n  const documentFileObjectsToValidate = [];\n\n  for (const documentFile of documentFiles) {\n    if (documentFile.document) {\n      const definitionsToValidate = [];\n\n      for (const definitionNode of documentFile.document.definitions) {\n        if (definitionNode.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n          allFragmentMap.set(definitionNode.name.value, definitionNode);\n        } else {\n          definitionsToValidate.push(definitionNode);\n        }\n      }\n\n      documentFileObjectsToValidate.push({\n        location: documentFile.location,\n        document: {\n          kind: graphql.Kind.DOCUMENT,\n          definitions: definitionsToValidate\n        }\n      });\n    }\n  }\n\n  const allErrors = [];\n  const allFragmentsDocument = {\n    kind: graphql.Kind.DOCUMENT,\n    definitions: [...allFragmentMap.values()]\n  };\n  await Promise.all(documentFileObjectsToValidate.map(async documentFile => {\n    const documentToValidate = graphql.concatAST([allFragmentsDocument, documentFile.document]);\n    const errors = graphql.validate(schema, documentToValidate, effectiveRules);\n\n    if (errors.length > 0) {\n      allErrors.push({\n        filePath: documentFile.location,\n        errors\n      });\n    }\n  }));\n  return allErrors;\n}\n\nfunction checkValidationErrors(loadDocumentErrors) {\n  if (loadDocumentErrors.length > 0) {\n    const errors = [];\n\n    for (const loadDocumentError of loadDocumentErrors) {\n      for (const graphQLError of loadDocumentError.errors) {\n        const error = new Error();\n        error.name = 'GraphQLDocumentError';\n        error.message = `${error.name}: ${graphQLError.message}`;\n        error.stack = error.message;\n\n        if (graphQLError.locations) {\n          for (const location of graphQLError.locations) {\n            error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;\n          }\n        }\n\n        errors.push(error);\n      }\n    }\n\n    throw new exports.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;\n  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join('\\n\\n')}`);\n  }\n}\n\nfunction createDefaultRules() {\n  let ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n\n  if (graphql.versionInfo.major < 15) {\n    ignored = ignored.map(rule => rule.replace(/Rule$/, ''));\n  }\n\n  return graphql.specifiedRules.filter(f => !ignored.includes(f.name));\n}\n\nfunction stripBOM(content) {\n  content = content.toString(); // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n\n  if (content.charCodeAt(0) === 0xfeff) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n\nfunction parseBOM(content) {\n  return JSON.parse(stripBOM(content));\n}\n\nfunction parseGraphQLJSON(location, jsonContent, options) {\n  let parsedJson = parseBOM(jsonContent);\n\n  if (parsedJson.data) {\n    parsedJson = parsedJson.data;\n  }\n\n  if (parsedJson.kind === 'Document') {\n    return {\n      location,\n      document: parsedJson\n    };\n  } else if (parsedJson.__schema) {\n    const schema = graphql.buildClientSchema(parsedJson, options);\n    return {\n      location,\n      schema\n    };\n  } else if (typeof parsedJson === 'string') {\n    return {\n      location,\n      rawSDL: parsedJson\n    };\n  }\n\n  throw new Error(`Not valid JSON content`);\n}\n\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\n\nfunction resetComments() {\n  commentsRegistry = {};\n}\n\nfunction collectComment(node) {\n  var _a;\n\n  const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n\n  if (entityName == null) {\n    return;\n  }\n\n  pushComment(node, entityName);\n\n  switch (node.kind) {\n    case 'EnumTypeDefinition':\n      if (node.values) {\n        for (const value of node.values) {\n          pushComment(value, entityName, value.name.value);\n        }\n      }\n\n      break;\n\n    case 'ObjectTypeDefinition':\n    case 'InputObjectTypeDefinition':\n    case 'InterfaceTypeDefinition':\n      if (node.fields) {\n        for (const field of node.fields) {\n          pushComment(field, entityName, field.name.value);\n\n          if (isFieldDefinitionNode(field) && field.arguments) {\n            for (const arg of field.arguments) {\n              pushComment(arg, entityName, field.name.value, arg.name.value);\n            }\n          }\n        }\n      }\n\n      break;\n  }\n}\n\nfunction pushComment(node, entity, field, argument) {\n  const comment = getComment(node);\n\n  if (typeof comment !== 'string' || comment.length === 0) {\n    return;\n  }\n\n  const keys = [entity];\n\n  if (field) {\n    keys.push(field);\n\n    if (argument) {\n      keys.push(argument);\n    }\n  }\n\n  const path = keys.join('.');\n\n  if (!commentsRegistry[path]) {\n    commentsRegistry[path] = [];\n  }\n\n  commentsRegistry[path].push(comment);\n}\n\nfunction printComment(comment) {\n  return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _a;\n\n  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\n\nfunction addDescription(cb) {\n  return (node, _key, _parent, path, ancestors) => {\n    var _a;\n\n    const keys = [];\n    const parent = path.reduce((prev, key) => {\n      if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n        keys.push(prev.name.value);\n      }\n\n      return prev[key];\n    }, ancestors[0]);\n    const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n    const items = [];\n\n    if (node.kind.includes('Definition') && commentsRegistry[key]) {\n      items.push(...commentsRegistry[key]);\n    }\n\n    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n  };\n}\n\nfunction indent(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value) {\n  let isDescription = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\n\nconst printDocASTReducer = {\n  Name: {\n    leave: node => node.value\n  },\n  Variable: {\n    leave: node => '$' + node.name\n  },\n  // Document\n  Document: {\n    leave: node => join(node.definitions, '\\n\\n')\n  },\n  OperationDefinition: {\n    leave: node => {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' '); // the query short form.\n\n      return prefix + ' ' + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: _ref3 => {\n      let {\n        variable,\n        type,\n        defaultValue,\n        directives\n      } = _ref3;\n      return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n    }\n  },\n  SelectionSet: {\n    leave: _ref4 => {\n      let {\n        selections\n      } = _ref4;\n      return block(selections);\n    }\n  },\n  Field: {\n    leave(_ref5) {\n      let {\n        alias,\n        name,\n        arguments: args,\n        directives,\n        selectionSet\n      } = _ref5;\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n\n  },\n  Argument: {\n    leave: _ref6 => {\n      let {\n        name,\n        value\n      } = _ref6;\n      return name + ': ' + value;\n    }\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: _ref7 => {\n      let {\n        name,\n        directives\n      } = _ref7;\n      return '...' + name + wrap(' ', join(directives, ' '));\n    }\n  },\n  InlineFragment: {\n    leave: _ref8 => {\n      let {\n        typeCondition,\n        directives,\n        selectionSet\n      } = _ref8;\n      return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  FragmentDefinition: {\n    leave: _ref9 => {\n      let {\n        name,\n        typeCondition,\n        variableDefinitions,\n        directives,\n        selectionSet\n      } = _ref9;\n      return (// Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` + selectionSet\n      );\n    }\n  },\n  // Value\n  IntValue: {\n    leave: _ref10 => {\n      let {\n        value\n      } = _ref10;\n      return value;\n    }\n  },\n  FloatValue: {\n    leave: _ref11 => {\n      let {\n        value\n      } = _ref11;\n      return value;\n    }\n  },\n  StringValue: {\n    leave: _ref12 => {\n      let {\n        value,\n        block: isBlockString\n      } = _ref12;\n\n      if (isBlockString) {\n        return printBlockString(value);\n      }\n\n      return JSON.stringify(value);\n    }\n  },\n  BooleanValue: {\n    leave: _ref13 => {\n      let {\n        value\n      } = _ref13;\n      return value ? 'true' : 'false';\n    }\n  },\n  NullValue: {\n    leave: () => 'null'\n  },\n  EnumValue: {\n    leave: _ref14 => {\n      let {\n        value\n      } = _ref14;\n      return value;\n    }\n  },\n  ListValue: {\n    leave: _ref15 => {\n      let {\n        values\n      } = _ref15;\n      return '[' + join(values, ', ') + ']';\n    }\n  },\n  ObjectValue: {\n    leave: _ref16 => {\n      let {\n        fields\n      } = _ref16;\n      return '{' + join(fields, ', ') + '}';\n    }\n  },\n  ObjectField: {\n    leave: _ref17 => {\n      let {\n        name,\n        value\n      } = _ref17;\n      return name + ': ' + value;\n    }\n  },\n  // Directive\n  Directive: {\n    leave: _ref18 => {\n      let {\n        name,\n        arguments: args\n      } = _ref18;\n      return '@' + name + wrap('(', join(args, ', '), ')');\n    }\n  },\n  // Type\n  NamedType: {\n    leave: _ref19 => {\n      let {\n        name\n      } = _ref19;\n      return name;\n    }\n  },\n  ListType: {\n    leave: _ref20 => {\n      let {\n        type\n      } = _ref20;\n      return '[' + type + ']';\n    }\n  },\n  NonNullType: {\n    leave: _ref21 => {\n      let {\n        type\n      } = _ref21;\n      return type + '!';\n    }\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: _ref22 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref22;\n      return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  OperationTypeDefinition: {\n    leave: _ref23 => {\n      let {\n        operation,\n        type\n      } = _ref23;\n      return operation + ': ' + type;\n    }\n  },\n  ScalarTypeDefinition: {\n    leave: _ref24 => {\n      let {\n        name,\n        directives\n      } = _ref24;\n      return join(['scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeDefinition: {\n    leave: _ref25 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref25;\n      return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  FieldDefinition: {\n    leave: _ref26 => {\n      let {\n        name,\n        arguments: args,\n        type,\n        directives\n      } = _ref26;\n      return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n    }\n  },\n  InputValueDefinition: {\n    leave: _ref27 => {\n      let {\n        name,\n        type,\n        defaultValue,\n        directives\n      } = _ref27;\n      return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n    }\n  },\n  InterfaceTypeDefinition: {\n    leave: _ref28 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref28;\n      return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeDefinition: {\n    leave: _ref29 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref29;\n      return join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeDefinition: {\n    leave: _ref30 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref30;\n      return join(['enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  EnumValueDefinition: {\n    leave: _ref31 => {\n      let {\n        name,\n        directives\n      } = _ref31;\n      return join([name, join(directives, ' ')], ' ');\n    }\n  },\n  InputObjectTypeDefinition: {\n    leave: _ref32 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref32;\n      return join(['input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  DirectiveDefinition: {\n    leave: _ref33 => {\n      let {\n        name,\n        arguments: args,\n        repeatable,\n        locations\n      } = _ref33;\n      return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n    }\n  },\n  SchemaExtension: {\n    leave: _ref34 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref34;\n      return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  ScalarTypeExtension: {\n    leave: _ref35 => {\n      let {\n        name,\n        directives\n      } = _ref35;\n      return join(['extend scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeExtension: {\n    leave: _ref36 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref36;\n      return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  InterfaceTypeExtension: {\n    leave: _ref37 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref37;\n      return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeExtension: {\n    leave: _ref38 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref38;\n      return join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeExtension: {\n    leave: _ref39 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref39;\n      return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  InputObjectTypeExtension: {\n    leave: _ref40 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref40;\n      return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  }\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({ ...prev,\n  [key]: {\n    leave: addDescription(printDocASTReducer[key].leave)\n  }\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nfunction printWithComments(ast) {\n  return graphql.visit(ast, printDocASTReducerWithComments);\n}\n\nfunction isFieldDefinitionNode(node) {\n  return node.kind === 'FieldDefinition';\n} // graphql < v13 and > v15 does not export getDescription\n\n\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n    return getComment(node);\n  }\n}\n\nfunction getComment(node) {\n  const rawValue = getLeadingCommentBlock(node);\n\n  if (rawValue !== undefined) {\n    return dedentBlockStringValue(`\\n${rawValue}`);\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  const comments = [];\n  let token = loc.startToken.prev;\n\n  while (token != null && token.kind === graphql.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  let commonIndent = null;\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  let i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let document;\n\n  try {\n    if (options.commentDescriptions && rawSDL.includes('#')) {\n      document = transformCommentsToDescriptions(rawSDL, options); // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n      // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n      // into descriptions.\n\n      if (options.noLocation) {\n        document = graphql.parse(graphql.print(document), options);\n      }\n    } else {\n      document = graphql.parse(new graphql.Source(rawSDL, location), options);\n    }\n  } catch (e) {\n    if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n      document = {\n        kind: graphql.Kind.DOCUMENT,\n        definitions: []\n      };\n    } else {\n      throw e;\n    }\n  }\n\n  return {\n    location,\n    document\n  };\n}\n\nfunction transformCommentsToDescriptions(sourceSdl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parsedDoc = graphql.parse(sourceSdl, { ...options,\n    noLocation: false\n  });\n  const modifiedDoc = graphql.visit(parsedDoc, {\n    leave: node => {\n      if (isDescribable(node)) {\n        const rawValue = getLeadingCommentBlock(node);\n\n        if (rawValue !== undefined) {\n          const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n          const isBlock = commentsBlock.includes('\\n');\n\n          if (!node.description) {\n            return { ...node,\n              description: {\n                kind: graphql.Kind.STRING,\n                value: commentsBlock,\n                block: isBlock\n              }\n            };\n          } else {\n            return { ...node,\n              description: { ...node.description,\n                value: node.description.value + '\\n' + commentsBlock,\n                block: true\n              }\n            };\n          }\n        }\n      }\n    }\n  });\n  return modifiedDoc;\n}\n\nfunction isDescribable(node) {\n  return graphql.isTypeSystemDefinitionNode(node) || node.kind === graphql.Kind.FIELD_DEFINITION || node.kind === graphql.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql.Kind.ENUM_VALUE_DEFINITION;\n}\n\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\n\nfunction addOperationVariable(variable) {\n  operationVariables.push(variable);\n}\n\nfunction resetOperationVariables() {\n  operationVariables = [];\n}\n\nfunction resetFieldMap() {\n  fieldTypeMap = new Map();\n}\n\nfunction buildOperationNodeForField(_ref41) {\n  let {\n    schema,\n    kind,\n    field,\n    models,\n    ignore = [],\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields = true\n  } = _ref41;\n  resetOperationVariables();\n  resetFieldMap();\n  const rootTypeNames = getRootTypeNames(schema);\n  const operationNode = buildOperationAndCollectVariables({\n    schema,\n    fieldName: field,\n    kind,\n    models: models || [],\n    ignore,\n    depthLimit: depthLimit || Infinity,\n    circularReferenceDepth: circularReferenceDepth || 1,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  }); // attach variables\n\n  operationNode.variableDefinitions = [...operationVariables];\n  resetOperationVariables();\n  resetFieldMap();\n  return operationNode;\n}\n\nfunction buildOperationAndCollectVariables(_ref42) {\n  let {\n    schema,\n    fieldName,\n    kind,\n    models,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref42;\n  const type = getDefinedRootType(schema, kind);\n  const field = type.getFields()[fieldName];\n  const operationName = `${fieldName}_${kind}`;\n\n  if (field.args) {\n    for (const arg of field.args) {\n      const argName = arg.name;\n\n      if (!argNames || argNames.includes(argName)) {\n        addOperationVariable(resolveVariable(arg, argName));\n      }\n    }\n  }\n\n  return {\n    kind: graphql.Kind.OPERATION_DEFINITION,\n    operation: kind,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: operationName\n    },\n    variableDefinitions: [],\n    selectionSet: {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: [resolveField({\n        type,\n        field,\n        models,\n        firstCall: true,\n        path: [],\n        ancestors: [],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: 0,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      })]\n    }\n  };\n}\n\nfunction resolveSelectionSet(_ref43) {\n  let {\n    parent,\n    type,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref43;\n\n  if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n    return;\n  }\n\n  if (graphql.isUnionType(type)) {\n    const types = type.getTypes();\n    return {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (graphql.isInterfaceType(type)) {\n    const types = Object.values(schema.getTypeMap()).filter(t => graphql.isObjectType(t) && t.getInterfaces().includes(type));\n    return {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (graphql.isObjectType(type) && !rootTypeNames.has(type.name)) {\n    const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n    const isModel = models.includes(type.name);\n\n    if (!firstCall && isModel && !isIgnored) {\n      return {\n        kind: graphql.Kind.SELECTION_SET,\n        selections: [{\n          kind: graphql.Kind.FIELD,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: 'id'\n          }\n        }]\n      };\n    }\n\n    const fields = type.getFields();\n    return {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: Object.keys(fields).filter(fieldName => {\n        return !hasCircularRef([...ancestors, graphql.getNamedType(fields[fieldName].type)], {\n          depth: circularReferenceDepth\n        });\n      }).map(fieldName => {\n        const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n\n        if (selectedSubFields) {\n          return resolveField({\n            type: type,\n            field: fields[fieldName],\n            models,\n            path: [...path, fieldName],\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields: selectedSubFields,\n            rootTypeNames\n          });\n        }\n\n        return null;\n      }).filter(f => {\n        var _a, _b;\n\n        if (f == null) {\n          return false;\n        } else if ('selectionSet' in f) {\n          return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n        }\n\n        return true;\n      })\n    };\n  }\n}\n\nfunction resolveVariable(arg, name) {\n  function resolveVariableType(type) {\n    if (graphql.isListType(type)) {\n      return {\n        kind: graphql.Kind.LIST_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    if (graphql.isNonNullType(type)) {\n      return {\n        kind: graphql.Kind.NON_NULL_TYPE,\n        // for v16 compatibility\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    return {\n      kind: graphql.Kind.NAMED_TYPE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: type.name\n      }\n    };\n  }\n\n  return {\n    kind: graphql.Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: graphql.Kind.VARIABLE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: name || arg.name\n      }\n    },\n    type: resolveVariableType(arg.type)\n  };\n}\n\nfunction getArgumentName(name, path) {\n  return [...path, name].join('_');\n}\n\nfunction resolveField(_ref44) {\n  let {\n    type,\n    field,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref44;\n  const namedType = graphql.getNamedType(field.type);\n  let args = [];\n  let removeField = false;\n\n  if (field.args && field.args.length) {\n    args = field.args.map(arg => {\n      const argumentName = getArgumentName(arg.name, path);\n\n      if (argNames && !argNames.includes(argumentName)) {\n        if (graphql.isNonNullType(arg.type)) {\n          removeField = true;\n        }\n\n        return null;\n      }\n\n      if (!firstCall) {\n        addOperationVariable(resolveVariable(arg, argumentName));\n      }\n\n      return {\n        kind: graphql.Kind.ARGUMENT,\n        name: {\n          kind: graphql.Kind.NAME,\n          value: arg.name\n        },\n        value: {\n          kind: graphql.Kind.VARIABLE,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: getArgumentName(arg.name, path)\n          }\n        }\n      };\n    }).filter(Boolean);\n  }\n\n  if (removeField) {\n    return null;\n  }\n\n  const fieldPath = [...path, field.name];\n  const fieldPathStr = fieldPath.join('.');\n  let fieldName = field.name;\n\n  if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n    fieldName += field.type.toString().replace('!', 'NonNull');\n  }\n\n  fieldTypeMap.set(fieldPathStr, field.type.toString());\n\n  if (!graphql.isScalarType(namedType) && !graphql.isEnumType(namedType)) {\n    return {\n      kind: graphql.Kind.FIELD,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: field.name\n      },\n      ...(fieldName !== field.name && {\n        alias: {\n          kind: graphql.Kind.NAME,\n          value: fieldName\n        }\n      }),\n      selectionSet: resolveSelectionSet({\n        parent: type,\n        type: namedType,\n        models,\n        firstCall,\n        path: fieldPath,\n        ancestors: [...ancestors, type],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: depth + 1,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      }) || undefined,\n      arguments: args\n    };\n  }\n\n  return {\n    kind: graphql.Kind.FIELD,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: field.name\n    },\n    ...(fieldName !== field.name && {\n      alias: {\n        kind: graphql.Kind.NAME,\n        value: fieldName\n      }\n    }),\n    arguments: args\n  };\n}\n\nfunction hasCircularRef(types) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    depth: 1\n  };\n  const type = types[types.length - 1];\n\n  if (graphql.isScalarType(type)) {\n    return false;\n  }\n\n  const size = types.filter(t => t.name === type.name).length;\n  return size > config.depth;\n}\n\n(function (MapperKind) {\n  MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n  MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n  MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n  MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n  MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n  MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n  MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n  MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n  MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n  MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n  MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n  MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n  MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n  MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n  MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n  MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n  MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n  MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n  MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n  MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n  MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n  MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n  MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n  MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n  MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(exports.MapperKind || (exports.MapperKind = {}));\n\nfunction getObjectTypeFromTypeMap(typeMap, type) {\n  if (type) {\n    const maybeObjectType = typeMap[type.name];\n\n    if (graphql.isObjectType(maybeObjectType)) {\n      return maybeObjectType;\n    }\n  }\n}\n\nfunction createNamedStub(name, type) {\n  let constructor;\n\n  if (type === 'object') {\n    constructor = graphql.GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = graphql.GraphQLInterfaceType;\n  } else {\n    constructor = graphql.GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name,\n    fields: {\n      _fake: {\n        type: graphql.GraphQLString\n      }\n    }\n  });\n}\n\nfunction createStub(node, type) {\n  switch (node.kind) {\n    case graphql.Kind.LIST_TYPE:\n      return new graphql.GraphQLList(createStub(node.type, type));\n\n    case graphql.Kind.NON_NULL_TYPE:\n      return new graphql.GraphQLNonNull(createStub(node.type, type));\n\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nfunction isNamedStub(type) {\n  if ('getFields' in type) {\n    const fields = type.getFields(); // eslint-disable-next-line no-unreachable-loop\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      return field.name === '_fake';\n    }\n  }\n\n  return false;\n}\n\nfunction getBuiltInForStub(type) {\n  switch (type.name) {\n    case graphql.GraphQLInt.name:\n      return graphql.GraphQLInt;\n\n    case graphql.GraphQLFloat.name:\n      return graphql.GraphQLFloat;\n\n    case graphql.GraphQLString.name:\n      return graphql.GraphQLString;\n\n    case graphql.GraphQLBoolean.name:\n      return graphql.GraphQLBoolean;\n\n    case graphql.GraphQLID.name:\n      return graphql.GraphQLID;\n\n    default:\n      return type;\n  }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n  const referenceTypeMap = Object.create(null);\n\n  for (const typeName in originalTypeMap) {\n    referenceTypeMap[typeName] = originalTypeMap[typeName];\n  }\n\n  const newTypeMap = Object.create(null);\n\n  for (const typeName in referenceTypeMap) {\n    const namedType = referenceTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n\n    const newName = namedType.name;\n\n    if (newName.startsWith('__')) {\n      continue;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n\n    newTypeMap[newName] = namedType;\n  }\n\n  for (const typeName in newTypeMap) {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  }\n\n  const newDirectives = directives.map(directive => rewireDirective(directive));\n  return {\n    typeMap: newTypeMap,\n    directives: newDirectives\n  };\n\n  function rewireDirective(directive) {\n    if (graphql.isSpecifiedDirective(directive)) {\n      return directive;\n    }\n\n    const directiveConfig = directive.toConfig();\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new graphql.GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(args) {\n    const rewiredArgs = {};\n\n    for (const argName in args) {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    }\n\n    return rewiredArgs;\n  }\n\n  function rewireNamedType(type) {\n    if (graphql.isObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields),\n        interfaces: () => rewireNamedTypes(config.interfaces)\n      };\n      return new graphql.GraphQLObjectType(newConfig);\n    } else if (graphql.isInterfaceType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields)\n      };\n\n      if ('interfaces' in newConfig) {\n        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n      }\n\n      return new graphql.GraphQLInterfaceType(newConfig);\n    } else if (graphql.isUnionType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        types: () => rewireNamedTypes(config.types)\n      };\n      return new graphql.GraphQLUnionType(newConfig);\n    } else if (graphql.isInputObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireInputFields(config.fields)\n      };\n      return new graphql.GraphQLInputObjectType(newConfig);\n    } else if (graphql.isEnumType(type)) {\n      const enumConfig = type.toConfig();\n      return new graphql.GraphQLEnumType(enumConfig);\n    } else if (graphql.isScalarType(type)) {\n      if (graphql.isSpecifiedScalarType(type)) {\n        return type;\n      }\n\n      const scalarConfig = type.toConfig();\n      return new graphql.GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function rewireFields(fields) {\n    const rewiredFields = {};\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null && field.args) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireInputFields(fields) {\n    const rewiredFields = {};\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes(namedTypes) {\n    const rewiredTypes = [];\n\n    for (const namedType of namedTypes) {\n      const rewiredType = rewireType(namedType);\n\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    }\n\n    return rewiredTypes;\n  }\n\n  function rewireType(type) {\n    if (graphql.isListType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new graphql.GraphQLList(rewiredType) : null;\n    } else if (graphql.isNonNullType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new graphql.GraphQLNonNull(rewiredType) : null;\n    } else if (graphql.isNamedType(type)) {\n      let rewiredType = referenceTypeMap[type.name];\n\n      if (rewiredType === undefined) {\n        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n      }\n\n      return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n    }\n\n    return null;\n  }\n}\n\nfunction transformInputValue(type, value) {\n  let inputLeafValueTransformer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let inputObjectValueTransformer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = graphql.getNullableType(type);\n\n  if (graphql.isLeafType(nullableType)) {\n    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n  } else if (graphql.isListType(nullableType)) {\n    return value.map(listMember => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n  } else if (graphql.isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    const newValue = {};\n\n    for (const key in value) {\n      const field = fields[key];\n\n      if (field != null) {\n        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n      }\n    }\n\n    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n  } // unreachable, no other possible return value\n\n}\n\nfunction serializeInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\n\nfunction parseInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\n\nfunction parseInputValueLiteral(type, value) {\n  return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n\nfunction mapSchema(schema) {\n  let schemaMapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => graphql.isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !graphql.isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n  const originalDirectives = schema.getDirectives();\n  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(newTypeMap, newDirectives);\n  return new graphql.GraphQLSchema({ ...schema.toConfig(),\n    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n    types: Object.values(typeMap),\n    directives\n  });\n}\n\nfunction mapTypes(originalTypeMap, schema, schemaMapper) {\n  let testFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const maybeNewType = typeMapper(originalType, schema);\n\n      if (maybeNewType === undefined) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      newTypeMap[typeName] = maybeNewType;\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  const enumValueMapper = getEnumValueMapper(schemaMapper);\n\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n\n  return mapTypes(originalTypeMap, schema, {\n    [exports.MapperKind.ENUM_TYPE]: type => {\n      const config = type.toConfig();\n      const originalEnumValueConfigMap = config.values;\n      const newEnumValueConfigMap = {};\n\n      for (const externalValue in originalEnumValueConfigMap) {\n        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n\n        if (mappedEnumValue === undefined) {\n          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n        } else if (Array.isArray(mappedEnumValue)) {\n          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n        } else if (mappedEnumValue !== null) {\n          newEnumValueConfigMap[externalValue] = mappedEnumValue;\n        }\n      }\n\n      return correctASTNodes(new graphql.GraphQLEnumType({ ...config,\n        values: newEnumValueConfigMap\n      }));\n    }\n  }, type => graphql.isEnumType(type));\n}\n\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  const newTypeMap = mapArguments(originalTypeMap, schema, {\n    [exports.MapperKind.ARGUMENT]: argumentConfig => {\n      if (argumentConfig.defaultValue === undefined) {\n        return argumentConfig;\n      }\n\n      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...argumentConfig,\n          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n        };\n      }\n    }\n  });\n  return mapFields(newTypeMap, schema, {\n    [exports.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n      if (inputFieldConfig.defaultValue === undefined) {\n        return inputFieldConfig;\n      }\n\n      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...inputFieldConfig,\n          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n        };\n      }\n    }\n  });\n}\n\nfunction getNewType(newTypeMap, type) {\n  if (graphql.isListType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql.GraphQLList(newType) : null;\n  } else if (graphql.isNonNullType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql.GraphQLNonNull(newType) : null;\n  } else if (graphql.isNamedType(type)) {\n    const newType = newTypeMap[type.name];\n    return newType != null ? newType : null;\n  }\n\n  return null;\n}\n\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType) && !graphql.isInputObjectType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n\n        if (mappedField === undefined) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          const [newFieldName, newFieldConfig] = mappedField;\n\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = { ...newFieldConfig.astNode,\n              name: { ...newFieldConfig.astNode.name,\n                value: newFieldName\n              }\n            };\n          }\n\n          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      }\n\n      if (graphql.isObjectType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else if (graphql.isInterfaceType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const argumentMapper = getArgumentMapper(schemaMapper);\n\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const originalArgumentConfigMap = originalFieldConfig.args;\n\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        const argumentNames = Object.keys(originalArgumentConfigMap);\n\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        const newArgumentConfigMap = {};\n\n        for (const argumentName of argumentNames) {\n          const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n\n          if (mappedArgument === undefined) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            const [newArgumentName, newArgumentConfig] = mappedArgument;\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        }\n\n        newFieldConfigMap[fieldName] = { ...originalFieldConfig,\n          args: newArgumentConfigMap\n        };\n      }\n\n      if (graphql.isObjectType(originalType)) {\n        newTypeMap[typeName] = new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else if (graphql.isInterfaceType(originalType)) {\n        newTypeMap[typeName] = new graphql.GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else {\n        newTypeMap[typeName] = new graphql.GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  const directiveMapper = getDirectiveMapper(schemaMapper);\n\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n\n  const newDirectives = [];\n\n  for (const directive of originalDirectives) {\n    const mappedDirective = directiveMapper(directive, schema);\n\n    if (mappedDirective === undefined) {\n      newDirectives.push(directive);\n    } else if (mappedDirective !== null) {\n      newDirectives.push(mappedDirective);\n    }\n  }\n\n  return newDirectives;\n}\n\nfunction getTypeSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  const type = schema.getType(typeName);\n  const specifiers = [exports.MapperKind.TYPE];\n\n  if (graphql.isObjectType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.OBJECT_TYPE);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.QUERY);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.MUTATION);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.SUBSCRIPTION);\n    }\n  } else if (graphql.isInputObjectType(type)) {\n    specifiers.push(exports.MapperKind.INPUT_OBJECT_TYPE);\n  } else if (graphql.isInterfaceType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.INTERFACE_TYPE);\n  } else if (graphql.isUnionType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.UNION_TYPE);\n  } else if (graphql.isEnumType(type)) {\n    specifiers.push(exports.MapperKind.ENUM_TYPE);\n  } else if (graphql.isScalarType(type)) {\n    specifiers.push(exports.MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  const specifiers = getTypeSpecifiers(schema, typeName);\n  let typeMapper;\n  const stack = [...specifiers];\n\n  while (!typeMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n\n  return typeMapper != null ? typeMapper : null;\n}\n\nfunction getFieldSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  const type = schema.getType(typeName);\n  const specifiers = [exports.MapperKind.FIELD];\n\n  if (graphql.isObjectType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.OBJECT_FIELD);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.QUERY_ROOT_FIELD);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.MUTATION_ROOT_FIELD);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if (graphql.isInterfaceType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.INTERFACE_FIELD);\n  } else if (graphql.isInputObjectType(type)) {\n    specifiers.push(exports.MapperKind.INPUT_OBJECT_FIELD);\n  }\n\n  return specifiers;\n}\n\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  const specifiers = getFieldSpecifiers(schema, typeName);\n  let fieldMapper;\n  const stack = [...specifiers];\n\n  while (!fieldMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop(); // TODO: fix this as unknown cast\n\n    fieldMapper = schemaMapper[next];\n  }\n\n  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\n\nfunction getArgumentMapper(schemaMapper) {\n  const argumentMapper = schemaMapper[exports.MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\n\nfunction getDirectiveMapper(schemaMapper) {\n  const directiveMapper = schemaMapper[exports.MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\n\nfunction getEnumValueMapper(schemaMapper) {\n  const enumValueMapper = schemaMapper[exports.MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\n\nfunction correctASTNodes(type) {\n  if (graphql.isObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: graphql.Kind.OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new graphql.GraphQLObjectType(config);\n  } else if (graphql.isInterfaceType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: graphql.Kind.INTERFACE_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new graphql.GraphQLInterfaceType(config);\n  } else if (graphql.isInputObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new graphql.GraphQLInputObjectType(config);\n  } else if (graphql.isEnumType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const values = [];\n\n      for (const enumKey in config.values) {\n        const enumValueConfig = config.values[enumKey];\n\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        values\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        values: undefined\n      }));\n    }\n\n    return new graphql.GraphQLEnumType(config);\n  } else {\n    return type;\n  }\n}\n\nfunction filterSchema(_ref45) {\n  let {\n    schema,\n    typeFilter = () => true,\n    fieldFilter = undefined,\n    rootFieldFilter = undefined,\n    objectFieldFilter = undefined,\n    interfaceFieldFilter = undefined,\n    inputObjectFieldFilter = undefined,\n    argumentFilter = undefined\n  } = _ref45;\n  const filteredSchema = mapSchema(schema, {\n    [exports.MapperKind.QUERY]: type => filterRootFields(type, 'Query', rootFieldFilter, argumentFilter),\n    [exports.MapperKind.MUTATION]: type => filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter),\n    [exports.MapperKind.SUBSCRIPTION]: type => filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter),\n    [exports.MapperKind.OBJECT_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,\n    [exports.MapperKind.INTERFACE_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,\n    [exports.MapperKind.INPUT_OBJECT_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,\n    [exports.MapperKind.UNION_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [exports.MapperKind.ENUM_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [exports.MapperKind.SCALAR_TYPE]: type => typeFilter(type.name, type) ? undefined : null\n  });\n  return filteredSchema;\n}\n\nfunction filterRootFields(type, operation, rootFieldFilter, argumentFilter) {\n  if (rootFieldFilter || argumentFilter) {\n    const config = type.toConfig();\n\n    for (const fieldName in config.fields) {\n      const field = config.fields[fieldName];\n\n      if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && field.args) {\n        for (const argName in field.args) {\n          if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new graphql.GraphQLObjectType(config);\n  }\n\n  return type;\n}\n\nfunction filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {\n  if (fieldFilter || argumentFilter) {\n    const config = type.toConfig();\n\n    for (const fieldName in config.fields) {\n      const field = config.fields[fieldName];\n\n      if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && 'args' in field) {\n        for (const argName in field.args) {\n          if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new ElementConstructor(config);\n  }\n} // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\n\n\nfunction healSchema(schema) {\n  healTypes(schema.getTypeMap(), schema.getDirectives());\n  return schema;\n}\n\nfunction healTypes(originalTypeMap, directives) {\n  const actualNamedTypeMap = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n\n    const actualName = namedType.name;\n\n    if (actualName.startsWith('__')) {\n      continue;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(`Duplicate schema type name ${actualName}`);\n    }\n\n    actualNamedTypeMap[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  } // Now add back every named type by its actual name.\n\n\n  for (const typeName in actualNamedTypeMap) {\n    const namedType = actualNamedTypeMap[typeName];\n    originalTypeMap[typeName] = namedType;\n  } // Directive declaration argument types can refer to named types.\n\n\n  for (const decl of directives) {\n    decl.args = decl.args.filter(arg => {\n      arg.type = healType(arg.type);\n      return arg.type !== null;\n    });\n  }\n\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName]; // Heal all named types, except for dangling references, kept only to redirect.\n\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  }\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      delete originalTypeMap[typeName];\n    }\n  }\n\n  function healNamedType(type) {\n    if (graphql.isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (graphql.isInterfaceType(type)) {\n      healFields(type);\n\n      if ('getInterfaces' in type) {\n        healInterfaces(type);\n      }\n\n      return;\n    } else if (graphql.isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (graphql.isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (graphql.isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function healFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.args.map(arg => {\n        arg.type = healType(arg.type);\n        return arg.type === null ? null : arg;\n      }).filter(Boolean);\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healInterfaces(type) {\n    if ('getInterfaces' in type) {\n      const interfaces = type.getInterfaces();\n      interfaces.push(...interfaces.splice(0).map(iface => healType(iface)).filter(Boolean));\n    }\n  }\n\n  function healInputFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healUnderlyingTypes(type) {\n    const types = type.getTypes();\n    types.push(...types.splice(0).map(t => healType(t)).filter(Boolean));\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (graphql.isListType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new graphql.GraphQLList(healedType) : null;\n    } else if (graphql.isNonNullType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new graphql.GraphQLNonNull(healedType) : null;\n    } else if (graphql.isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      const officialType = originalTypeMap[type.name];\n\n      if (officialType && type !== officialType) {\n        return officialType;\n      }\n    }\n\n    return type;\n  }\n}\n\nfunction getResolversFromSchema(schema) {\n  var _a, _b;\n\n  const resolvers = Object.create(null);\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    if (!typeName.startsWith('__')) {\n      const type = typeMap[typeName];\n\n      if (graphql.isScalarType(type)) {\n        if (!graphql.isSpecifiedScalarType(type)) {\n          const config = type.toConfig();\n          delete config.astNode; // avoid AST duplication elsewhere\n\n          resolvers[typeName] = new graphql.GraphQLScalarType(config);\n        }\n      } else if (graphql.isEnumType(type)) {\n        resolvers[typeName] = {};\n        const values = type.getValues();\n\n        for (const value of values) {\n          resolvers[typeName][value.name] = value.value;\n        }\n      } else if (graphql.isInterfaceType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (graphql.isUnionType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (graphql.isObjectType(type)) {\n        resolvers[typeName] = {};\n\n        if (type.isTypeOf != null) {\n          resolvers[typeName].__isTypeOf = type.isTypeOf;\n        }\n\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n\n          if (field.subscribe != null) {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].subscribe = field.subscribe;\n          }\n\n          if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== 'defaultFieldResolver' && ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== 'defaultMergedResolver') {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].resolve = field.resolve;\n          }\n        }\n      }\n    }\n  }\n\n  return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName]; // TODO: maybe have an option to include these?\n\n    if (!graphql.getNamedType(type).name.startsWith('__') && graphql.isObjectType(type)) {\n      const fields = type.getFields();\n\n      for (const fieldName in fields) {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      }\n    }\n  }\n}\n\nfunction forEachDefaultValue(schema, fn) {\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName];\n\n    if (!graphql.getNamedType(type).name.startsWith('__')) {\n      if (graphql.isObjectType(type)) {\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n\n          for (const arg of field.args) {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          }\n        }\n      } else if (graphql.isInputObjectType(type)) {\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        }\n      }\n    }\n  }\n} // addTypes uses toConfig to create a new schema with a new or replaced\n\n\nfunction addTypes(schema, newTypesOrDirectives) {\n  const config = schema.toConfig();\n  const originalTypeMap = {};\n\n  for (const type of config.types) {\n    originalTypeMap[type.name] = type;\n  }\n\n  const originalDirectiveMap = {};\n\n  for (const directive of config.directives) {\n    originalDirectiveMap[directive.name] = directive;\n  }\n\n  for (const newTypeOrDirective of newTypesOrDirectives) {\n    if (graphql.isNamedType(newTypeOrDirective)) {\n      originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n    } else if (graphql.isDirective(newTypeOrDirective)) {\n      originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n    }\n  }\n\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));\n  return new graphql.GraphQLSchema({ ...config,\n    query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),\n    mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),\n    subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),\n    types: Object.values(typeMap),\n    directives\n  });\n}\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\n\n\nfunction pruneSchema(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pruningContext = {\n    schema,\n    unusedTypes: Object.create(null),\n    implementations: Object.create(null)\n  };\n\n  for (const typeName in schema.getTypeMap()) {\n    const type = schema.getType(typeName);\n\n    if (type && 'getInterfaces' in type) {\n      for (const iface of type.getInterfaces()) {\n        const implementations = getImplementations(pruningContext, iface);\n\n        if (implementations == null) {\n          pruningContext.implementations[iface.name] = Object.create(null);\n        }\n\n        pruningContext.implementations[iface.name][type.name] = true;\n      }\n    }\n  }\n\n  visitTypes(pruningContext, schema);\n  return mapSchema(schema, {\n    [exports.MapperKind.TYPE]: type => {\n      // If we should NOT prune the type, return it immediately as unmodified\n      if (options.skipPruning && options.skipPruning(type)) {\n        return type;\n      }\n\n      if (graphql.isObjectType(type) || graphql.isInputObjectType(type)) {\n        if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else if (graphql.isUnionType(type)) {\n        if (!type.getTypes().length && !options.skipEmptyUnionPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else if (graphql.isInterfaceType(type)) {\n        const implementations = getImplementations(pruningContext, type);\n\n        if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || implementations && !Object.keys(implementations).length && !options.skipUnimplementedInterfacesPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else {\n        if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      }\n    }\n  });\n}\n\nfunction visitOutputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  visitedTypes[type.name] = true;\n  pruningContext.unusedTypes[type.name] = false;\n\n  if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n    const fields = type.getFields();\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const namedType = graphql.getNamedType(field.type);\n      visitOutputType(visitedTypes, pruningContext, namedType);\n\n      for (const arg of field.args) {\n        const type = graphql.getNamedType(arg.type);\n        visitInputType(visitedTypes, pruningContext, type);\n      }\n    }\n\n    if (graphql.isInterfaceType(type)) {\n      const implementations = getImplementations(pruningContext, type);\n\n      if (implementations) {\n        for (const typeName in implementations) {\n          visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));\n        }\n      }\n    }\n\n    if ('getInterfaces' in type) {\n      for (const iFace of type.getInterfaces()) {\n        visitOutputType(visitedTypes, pruningContext, iFace);\n      }\n    }\n  } else if (graphql.isUnionType(type)) {\n    const types = type.getTypes();\n\n    for (const type of types) {\n      visitOutputType(visitedTypes, pruningContext, type);\n    }\n  }\n}\n/**\n * Get the implementations of an interface. May return undefined.\n */\n\n\nfunction getImplementations(pruningContext, type) {\n  return pruningContext.implementations[type.name];\n}\n\nfunction visitInputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  pruningContext.unusedTypes[type.name] = false;\n  visitedTypes[type.name] = true;\n\n  if (graphql.isInputObjectType(type)) {\n    const fields = type.getFields();\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const namedType = graphql.getNamedType(field.type);\n      visitInputType(visitedTypes, pruningContext, namedType);\n    }\n  }\n}\n\nfunction visitTypes(pruningContext, schema) {\n  for (const typeName in schema.getTypeMap()) {\n    if (!typeName.startsWith('__')) {\n      pruningContext.unusedTypes[typeName] = true;\n    }\n  }\n\n  const visitedTypes = Object.create(null);\n  const rootTypes = getRootTypes(schema);\n\n  for (const rootType of rootTypes) {\n    visitOutputType(visitedTypes, pruningContext, rootType);\n  }\n\n  for (const directive of schema.getDirectives()) {\n    for (const arg of directive.args) {\n      const type = graphql.getNamedType(arg.type);\n      visitInputType(visitedTypes, pruningContext, type);\n    }\n  }\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nfunction mergeDeep(sources) {\n  let respectPrototype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const target = sources[0] || {};\n  const output = {};\n\n  if (respectPrototype) {\n    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));\n  }\n\n  for (const source of sources) {\n    if (isObject(target) && isObject(source)) {\n      if (respectPrototype) {\n        const outputPrototype = Object.getPrototypeOf(output);\n        const sourcePrototype = Object.getPrototypeOf(source);\n\n        if (sourcePrototype) {\n          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n\n            if (isSome(descriptor)) {\n              Object.defineProperty(outputPrototype, key, descriptor);\n            }\n          }\n        }\n      }\n\n      for (const key in source) {\n        if (isObject(source[key])) {\n          if (!(key in output)) {\n            Object.assign(output, {\n              [key]: source[key]\n            });\n          } else {\n            output[key] = mergeDeep([output[key], source[key]], respectPrototype);\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction parseSelectionSet(selectionSet, options) {\n  const query = graphql.parse(selectionSet, options).definitions[0];\n  return query.selectionSet;\n}\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\n\n\nfunction getResponseKeyFromInfo(info) {\n  return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n  if (schema.getType(typeName) == null) {\n    return addTypes(schema, [new graphql.GraphQLObjectType({\n      name: typeName,\n      fields: additionalFields\n    })]);\n  }\n\n  return mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n        }\n\n        for (const fieldName in additionalFields) {\n          newFieldConfigMap[fieldName] = additionalFields[fieldName];\n        }\n\n        return correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n}\n\nfunction removeObjectFields(schema, typeName, testFn) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        }\n\n        return correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction selectObjectFields(schema, typeName, testFn) {\n  const selectedFields = {};\n  mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            selectedFields[fieldName] = originalFieldConfig;\n          }\n        }\n      }\n\n      return undefined;\n    }\n  });\n  return selectedFields;\n}\n\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        }\n\n        for (const fieldName in newFields) {\n          const fieldConfig = newFields[fieldName];\n          newFieldConfigMap[fieldName] = fieldConfig;\n        }\n\n        return correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n  if (graphql.isObjectType(type)) {\n    return new graphql.GraphQLObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isInterfaceType(type)) {\n    return new graphql.GraphQLInterfaceType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isUnionType(type)) {\n    return new graphql.GraphQLUnionType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isInputObjectType(type)) {\n    return new graphql.GraphQLInputObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isEnumType(type)) {\n    return new graphql.GraphQLEnumType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isScalarType(type)) {\n    return new graphql.GraphQLScalarType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  }\n\n  throw new Error(`Unknown type ${type}.`);\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\n\n\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  let $return;\n  let abruptClose;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = error => {\n      const rethrow = () => Promise.reject(error);\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  let mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    const reject = rejectCallback;\n\n    mapReject = error => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n  }\n\n  return {\n    next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n\n    return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(resolve => resolve(callback(value)));\n}\n\nfunction iteratorResult(value) {\n  return {\n    value,\n    done: false\n  };\n}\n\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {\n  argumentNodes[argName] = {\n    kind: graphql.Kind.ARGUMENT,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: argName\n    },\n    value: {\n      kind: graphql.Kind.VARIABLE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: varName\n      }\n    }\n  };\n  variableDefinitionsMap[varName] = {\n    kind: graphql.Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: graphql.Kind.VARIABLE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: varName\n      }\n    },\n    type: astFromType(type)\n  };\n\n  if (value !== undefined) {\n    variableValues[varName] = value;\n    return;\n  } // including the variable in the map with value of `undefined`\n  // will actually be translated by graphql-js into `null`\n  // see https://github.com/graphql/graphql-js/issues/2533\n\n\n  if (varName in variableValues) {\n    delete variableValues[varName];\n  }\n}\n\nfunction createVariableNameGenerator(variableDefinitionMap) {\n  let varCounter = 0;\n  return argName => {\n    let varName;\n\n    do {\n      varName = `_v${(varCounter++).toString()}_${argName}`;\n    } while (varName in variableDefinitionMap);\n\n    return varName;\n  };\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n  if (typeB == null || typeA == null) {\n    return false;\n  } else if (typeA === typeB) {\n    return true;\n  } else if (graphql.isCompositeType(typeA) && graphql.isCompositeType(typeB)) {\n    return graphql.doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n\nfunction relocatedError(originalError, path) {\n  return new graphql.GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction observableToAsyncIterable(observable) {\n  const pullQueue = [];\n  const pushQueue = [];\n  let listening = true;\n\n  const pushValue = value => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value,\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value,\n        done: false\n      });\n    }\n  };\n\n  const pushError = error => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    }\n  };\n\n  const pushDone = () => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        done: true\n      });\n    } else {\n      pushQueue.push({\n        done: true\n      });\n    }\n  };\n\n  const pullValue = () => new Promise(resolve => {\n    if (pushQueue.length !== 0) {\n      const element = pushQueue.shift(); // either {value: {errors: [...]}} or {value: ...}\n\n      resolve(element);\n    } else {\n      pullQueue.push(resolve);\n    }\n  });\n\n  const subscription = observable.subscribe({\n    next(value) {\n      pushValue(value);\n    },\n\n    error(err) {\n      pushError(err);\n    },\n\n    complete() {\n      pushDone();\n    }\n\n  });\n\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n\n      for (const resolve of pullQueue) {\n        resolve({\n          value: undefined,\n          done: true\n        });\n      }\n\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return {\n    next() {\n      // return is a defined method, so it is safe to call it.\n      return listening ? pullValue() : this.return();\n    },\n\n    return() {\n      emptyQueue();\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction getOperationASTFromDocument(documentNode, operationName) {\n  const doc = graphql.getOperationAST(documentNode, operationName);\n\n  if (!doc) {\n    throw new Error(`Cannot infer operation ${operationName || ''}`);\n  }\n\n  return doc;\n}\n\nconst getOperationASTFromRequest = memoize1(function getOperationASTFromRequest(request) {\n  return getOperationASTFromDocument(request.document, request.operationName);\n}); // Taken from GraphQL-JS v16 for backwards compat\n\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case graphql.Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          const name = getFieldEntryKey(selection);\n          const fieldList = fields.get(name);\n\n          if (fieldList !== undefined) {\n            fieldList.push(selection);\n          } else {\n            fields.set(name, [selection]);\n          }\n\n          break;\n        }\n\n      case graphql.Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case graphql.Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n\n          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames.add(fragName);\n          const fragment = fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = graphql.getDirectiveValues(graphql.GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n    return false;\n  }\n\n  const include = graphql.getDirectiveValues(graphql.GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = graphql.typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (graphql.isAbstractType(conditionalType)) {\n    const possibleTypes = schema.getPossibleTypes(conditionalType);\n    return possibleTypes.includes(type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n\nconst collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const fieldNode of fieldNodes) {\n    if (fieldNode.selectionSet) {\n      collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n});\n\nfunction visitData(data, enter, leave) {\n  if (Array.isArray(data)) {\n    return data.map(value => visitData(value, enter, leave));\n  } else if (typeof data === 'object') {\n    const newData = enter != null ? enter(data) : data;\n\n    if (newData != null) {\n      for (const key in newData) {\n        const value = newData[key];\n        Object.defineProperty(newData, key, {\n          value: visitData(value, enter, leave)\n        });\n      }\n    }\n\n    return leave != null ? leave(newData) : newData;\n  }\n\n  return data;\n}\n\nfunction visitErrors(errors, visitor) {\n  return errors.map(error => visitor(error));\n}\n\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n  const fragments = request.document.definitions.reduce((acc, def) => {\n    if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n      acc[def.name.value] = def;\n    }\n\n    return acc;\n  }, {});\n  const variableValues = request.variables || {};\n  const errorInfo = {\n    segmentInfoMap: new Map(),\n    unpathedErrors: new Set()\n  };\n  const data = result.data;\n  const errors = result.errors;\n  const visitingErrors = errors != null && errorVisitorMap != null;\n  const operationDocumentNode = getOperationASTFromRequest(request);\n\n  if (data != null && operationDocumentNode != null) {\n    result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n  }\n\n  if (errors != null && errorVisitorMap) {\n    result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n  }\n\n  return result;\n}\n\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n  const segmentInfoMap = errorInfo.segmentInfoMap;\n  const unpathedErrors = errorInfo.unpathedErrors;\n  const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n  return errors.map(originalError => {\n    const pathSegmentsInfo = segmentInfoMap.get(originalError);\n    const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n      const typeName = segmentInfo.type.name;\n      const typeVisitorMap = errorVisitorMap[typeName];\n\n      if (typeVisitorMap == null) {\n        return acc;\n      }\n\n      const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n      return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n    }, originalError);\n\n    if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n      return unpathedErrorVisitor(newError);\n    }\n\n    return newError;\n  });\n}\n\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n  const operationRootType = graphql.getOperationRootType(schema, operation);\n  const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n  return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\n\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  const fieldMap = type.getFields();\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n  const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n  const newObject = enterObject != null ? enterObject(object) : object;\n  let sortedErrors;\n  let errorMap = null;\n\n  if (errors != null) {\n    sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n    errorMap = sortedErrors.errorMap;\n\n    for (const error of sortedErrors.unpathedErrors) {\n      errorInfo.unpathedErrors.add(error);\n    }\n  }\n\n  for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n    const fieldName = subFieldNodes[0].name.value;\n    const fieldType = fieldName === '__typename' ? graphql.TypeNameMetaFieldDef.type : fieldMap[fieldName].type;\n    const newPathIndex = pathIndex + 1;\n    let fieldErrors;\n\n    if (errorMap) {\n      fieldErrors = errorMap[responseKey];\n\n      if (fieldErrors != null) {\n        delete errorMap[responseKey];\n      }\n\n      addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n    }\n\n    const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n    updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n  }\n\n  const oldTypename = newObject.__typename;\n\n  if (oldTypename != null) {\n    updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n  }\n\n  if (errorMap) {\n    for (const errorsKey in errorMap) {\n      const errors = errorMap[errorsKey];\n\n      for (const error of errors) {\n        errorInfo.unpathedErrors.add(error);\n      }\n    }\n  }\n\n  const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n  return leaveObject != null ? leaveObject(newObject) : newObject;\n}\n\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n  if (typeVisitorMap == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const fieldVisitor = typeVisitorMap[fieldName];\n\n  if (fieldVisitor == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const visitedValue = fieldVisitor(newValue);\n\n  if (visitedValue === undefined) {\n    delete object[responseKey];\n    return;\n  }\n\n  object[responseKey] = visitedValue;\n}\n\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\n\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex) {\n  let errors = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  let errorInfo = arguments.length > 9 ? arguments[9] : undefined;\n\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = graphql.getNullableType(returnType);\n\n  if (graphql.isListType(nullableType)) {\n    return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (graphql.isAbstractType(nullableType)) {\n    const finalType = schema.getType(value.__typename);\n    const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);\n    return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (graphql.isObjectType(nullableType)) {\n    const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);\n    return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  }\n\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n\n  if (typeVisitorMap == null) {\n    return value;\n  }\n\n  const visitedValue = typeVisitorMap(value);\n  return visitedValue === undefined ? value : visitedValue;\n}\n\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n  var _a;\n\n  const errorMap = Object.create(null);\n  const unpathedErrors = new Set();\n\n  for (const error of errors) {\n    const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n\n    if (pathSegment == null) {\n      unpathedErrors.add(error);\n      continue;\n    }\n\n    if (pathSegment in errorMap) {\n      errorMap[pathSegment].push(error);\n    } else {\n      errorMap[pathSegment] = [error];\n    }\n  }\n\n  return {\n    errorMap,\n    unpathedErrors\n  };\n}\n\nfunction addPathSegmentInfo(type, fieldName, pathIndex) {\n  let errors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let errorInfo = arguments.length > 4 ? arguments[4] : undefined;\n\n  for (const error of errors) {\n    const segmentInfo = {\n      type,\n      fieldName,\n      pathIndex\n    };\n    const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n\n    if (pathSegmentsInfo == null) {\n      errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n    } else {\n      pathSegmentsInfo.push(segmentInfo);\n    }\n  }\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n  if (value == null) {\n    return value === criteria;\n  } else if (Array.isArray(value)) {\n    return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n  } else if (typeof value === 'object') {\n    return typeof criteria === 'object' && criteria && Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName]));\n  } else if (criteria instanceof RegExp) {\n    return criteria.test(value);\n  }\n\n  return value === criteria;\n}\n\nfunction isAsyncIterable(value) {\n  return typeof value === 'object' && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === 'function';\n}\n\nfunction isDocumentNode(object) {\n  return object && typeof object === 'object' && 'kind' in object && object.kind === graphql.Kind.DOCUMENT;\n}\n\nfunction withCancel(asyncIteratorLike, onCancel) {\n  const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();\n\n  if (!asyncIterator.return) {\n    asyncIterator.return = () => Promise.resolve({\n      value: undefined,\n      done: true\n    });\n  }\n\n  const savedReturn = asyncIterator.return.bind(asyncIterator);\n\n  asyncIterator.return = () => {\n    onCancel();\n    return savedReturn();\n  };\n\n  return asyncIterator;\n}\n\nfunction buildFixedSchema(schema, options) {\n  const document = getDocumentNodeFromSchema(schema);\n  return graphql.buildASTSchema(document, { ...(options || {})\n  });\n}\n\nfunction fixSchemaAst(schema, options) {\n  // eslint-disable-next-line no-undef-init\n  let schemaWithValidAst = undefined;\n\n  if (!schema.astNode || !schema.extensionASTNodes) {\n    schemaWithValidAst = buildFixedSchema(schema, options);\n  }\n\n  if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.astNode = schemaWithValidAst.astNode;\n  }\n\n  if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n  }\n\n  return schema;\n}\n\nexports.addTypes = addTypes;\nexports.appendObjectFields = appendObjectFields;\nexports.asArray = asArray;\nexports.assertSome = assertSome;\nexports.astFromArg = astFromArg;\nexports.astFromDirective = astFromDirective;\nexports.astFromEnumType = astFromEnumType;\nexports.astFromEnumValue = astFromEnumValue;\nexports.astFromField = astFromField;\nexports.astFromInputField = astFromInputField;\nexports.astFromInputObjectType = astFromInputObjectType;\nexports.astFromInterfaceType = astFromInterfaceType;\nexports.astFromObjectType = astFromObjectType;\nexports.astFromScalarType = astFromScalarType;\nexports.astFromSchema = astFromSchema;\nexports.astFromUnionType = astFromUnionType;\nexports.astFromValueUntyped = astFromValueUntyped;\nexports.buildOperationNodeForField = buildOperationNodeForField;\nexports.checkValidationErrors = checkValidationErrors;\nexports.collectComment = collectComment;\nexports.collectFields = collectFields;\nexports.collectSubFields = collectSubFields;\nexports.compareNodes = compareNodes;\nexports.compareStrings = compareStrings;\nexports.correctASTNodes = correctASTNodes;\nexports.createDefaultRules = createDefaultRules;\nexports.createNamedStub = createNamedStub;\nexports.createStub = createStub;\nexports.createVariableNameGenerator = createVariableNameGenerator;\nexports.dedentBlockStringValue = dedentBlockStringValue;\nexports.filterSchema = filterSchema;\nexports.fixSchemaAst = fixSchemaAst;\nexports.forEachDefaultValue = forEachDefaultValue;\nexports.forEachField = forEachField;\nexports.getArgumentValues = getArgumentValues;\nexports.getBlockStringIndentation = getBlockStringIndentation;\nexports.getBuiltInForStub = getBuiltInForStub;\nexports.getComment = getComment;\nexports.getDefinedRootType = getDefinedRootType;\nexports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;\nexports.getDescription = getDescription;\nexports.getDirective = getDirective;\nexports.getDirectiveInExtensions = getDirectiveInExtensions;\nexports.getDirectiveNodes = getDirectiveNodes;\nexports.getDirectives = getDirectives;\nexports.getDirectivesInExtensions = getDirectivesInExtensions;\nexports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;\nexports.getFieldsWithDirectives = getFieldsWithDirectives;\nexports.getImplementingTypes = getImplementingTypes;\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nexports.getOperationASTFromDocument = getOperationASTFromDocument;\nexports.getOperationASTFromRequest = getOperationASTFromRequest;\nexports.getResolversFromSchema = getResolversFromSchema;\nexports.getResponseKeyFromInfo = getResponseKeyFromInfo;\nexports.getRootTypeMap = getRootTypeMap;\nexports.getRootTypeNames = getRootTypeNames;\nexports.getRootTypes = getRootTypes;\nexports.healSchema = healSchema;\nexports.healTypes = healTypes;\nexports.implementsAbstractType = implementsAbstractType;\nexports.inspect = inspect;\nexports.isAggregateError = isAggregateError;\nexports.isAsyncIterable = isAsyncIterable;\nexports.isDescribable = isDescribable;\nexports.isDocumentNode = isDocumentNode;\nexports.isDocumentString = isDocumentString;\nexports.isNamedStub = isNamedStub;\nexports.isSome = isSome;\nexports.isValidPath = isValidPath;\nexports.makeDeprecatedDirective = makeDeprecatedDirective;\nexports.makeDirectiveNode = makeDirectiveNode;\nexports.makeDirectiveNodes = makeDirectiveNodes;\nexports.mapAsyncIterator = mapAsyncIterator;\nexports.mapSchema = mapSchema;\nexports.memoize1 = memoize1;\nexports.memoize2 = memoize2;\nexports.memoize2of4 = memoize2of4;\nexports.memoize3 = memoize3;\nexports.memoize4 = memoize4;\nexports.memoize5 = memoize5;\nexports.mergeDeep = mergeDeep;\nexports.modifyObjectFields = modifyObjectFields;\nexports.nodeToString = nodeToString;\nexports.observableToAsyncIterable = observableToAsyncIterable;\nexports.parseGraphQLJSON = parseGraphQLJSON;\nexports.parseGraphQLSDL = parseGraphQLSDL;\nexports.parseInputValue = parseInputValue;\nexports.parseInputValueLiteral = parseInputValueLiteral;\nexports.parseSelectionSet = parseSelectionSet;\nexports.printComment = printComment;\nexports.printSchemaWithDirectives = printSchemaWithDirectives;\nexports.printWithComments = printWithComments;\nexports.pruneSchema = pruneSchema;\nexports.pushComment = pushComment;\nexports.relocatedError = relocatedError;\nexports.removeObjectFields = removeObjectFields;\nexports.renameType = renameType;\nexports.resetComments = resetComments;\nexports.rewireTypes = rewireTypes;\nexports.selectObjectFields = selectObjectFields;\nexports.serializeInputValue = serializeInputValue;\nexports.transformCommentsToDescriptions = transformCommentsToDescriptions;\nexports.transformInputValue = transformInputValue;\nexports.updateArgument = updateArgument;\nexports.validateGraphQlDocuments = validateGraphQlDocuments;\nexports.valueMatchesCriteria = valueMatchesCriteria;\nexports.visitData = visitData;\nexports.visitErrors = visitErrors;\nexports.visitResult = visitResult;\nexports.withCancel = withCancel;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/@graphql-tools/utils/index.js"],"names":["Object","defineProperty","exports","value","graphql","require","asArray","fns","Array","isArray","invalidDocRegex","isDocumentString","str","test","parse","e","invalidPathRegex","isValidPath","compareStrings","a","b","String","nodeToString","_a","_b","name","alias","kind","compareNodes","customFn","aStr","bStr","isSome","input","assertSome","message","Error","AggregateError","globalThis","AggregateErrorClass","constructor","errors","captureStackTrace","isAggregateError","error","MAX_ARRAY_LENGTH","MAX_RECURSIVE_DEPTH","inspect","formatValue","seenValues","JSON","stringify","formatObjectValue","formatError","GraphQLError","toString","stack","previouslySeenValues","formatArray","includes","isJSONable","jsonValue","toJSON","formatObject","object","entries","length","getObjectTag","properties","map","key","join","array","len","Math","min","remaining","items","i","push","tag","prototype","call","replace","getArgumentValues","def","node","variableValues","variableMap","reduce","prev","coercedValues","argumentNodes","arguments","argNodeMap","arg","type","argType","defaultValue","args","argumentNode","undefined","isNonNullType","valueNode","isNull","Kind","NULL","VARIABLE","variableName","coercedValue","valueFromAST","print","getDirectivesInExtensions","pathToDirectivesInExtensions","acc","pathSegment","extensions","_getDirectiveInExtensions","directivesInExtensions","directiveName","directiveInExtensions","filter","directiveAnnotation","directive","getDirectiveInExtensions","reformattedDirectivesInExtensions","argsOrArrayOfArgs","getDirectives","schema","schemaDirectives","schemaDirectiveMap","schemaDirective","astNodes","astNode","extensionASTNodes","result","directives","directiveNode","getDirective","parseDirectiveValue","INT","parseInt","FLOAT","parseFloat","BOOLEAN","Boolean","STRING","ENUM","LIST","values","v","OBJECT","fields","getFieldsWithDirectives","documentNode","options","selected","includeInputTypes","allTypes","definitions","obj","typeName","field","fieldName","d","getImplementingTypes","interfaceName","allTypesMap","getTypeMap","graphqlTypeName","graphqlType","isObjectType","allInterfaces","getInterfaces","find","int","astFromType","innerType","ofType","NON_NULL_TYPE","isListType","LIST_TYPE","NAMED_TYPE","NAME","astFromValueUntyped","valuesNodes","item","itemNode","fieldNodes","fieldValue","ast","OBJECT_FIELD","isFinite","stringNum","integerStringRegExp","TypeError","memoize1","fn","memoize1cache","WeakMap","memoized","a1","cachedValue","get","newValue","set","memoize2","memoize2cache","a2","cache2","memoize3","memoize3Cache","a3","cache3","memoize4","memoize4Cache","a4","cache4","memoize5","memoize5Cache","a5","cache5","memoize2of4cache","memoize2of4","getDefinedRootType","operation","rootTypeMap","getRootTypeMap","rootType","getRootTypeNames","rootTypes","getRootTypes","Set","Map","queryType","getQueryType","mutationType","getMutationType","subscriptionType","getSubscriptionType","getDocumentNodeFromSchema","typesMap","schemaNode","astFromSchema","isSpecifiedDirective","astFromDirective","isPredefinedScalar","isSpecifiedScalarType","isIntrospection","isIntrospectionType","astFromObjectType","isInterfaceType","astFromInterfaceType","isUnionType","astFromUnionType","isInputObjectType","astFromInputObjectType","isEnumType","astFromEnumType","isScalarType","astFromScalarType","DOCUMENT","printSchemaWithDirectives","operationTypeMap","nodes","extensionASTNode","operationTypes","operationTypeDefinitionNode","operationTypeNode","rootTypeAST","OPERATION_TYPE_DEFINITION","getDirectiveNodes","SCHEMA_DEFINITION","SCHEMA_EXTENSION","description","block","_c","_d","DIRECTIVE_DEFINITION","astFromArg","repeatable","isRepeatable","locations","location","entity","concat","makeDirectiveNodes","getDeprecatableDirectiveNodes","directiveNodesBesidesDeprecated","deprecatedDirectiveNode","deprecationReason","makeDeprecatedDirective","INPUT_VALUE_DEFINITION","astFromValue","OBJECT_TYPE_DEFINITION","getFields","astFromField","interfaces","iFace","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","types","getTypes","INPUT_OBJECT_TYPE_DEFINITION","astFromInputField","ENUM_TYPE_DEFINITION","getValues","astFromEnumValue","specifiedByValue","some","specifiedByArgs","url","makeDirectiveNode","SCALAR_TYPE_DEFINITION","FIELD_DEFINITION","ENUM_VALUE_DEFINITION","reason","GraphQLDeprecatedDirective","directiveArguments","argName","argValue","ARGUMENT","DIRECTIVE","directiveValues","directiveNodes","arrayOrSingleValue","validateGraphQlDocuments","documentFiles","effectiveRules","createDefaultRules","allFragmentMap","documentFileObjectsToValidate","documentFile","document","definitionsToValidate","definitionNode","FRAGMENT_DEFINITION","allErrors","allFragmentsDocument","Promise","all","documentToValidate","concatAST","validate","filePath","checkValidationErrors","loadDocumentErrors","loadDocumentError","graphQLError","line","column","index","ignored","versionInfo","major","rule","specifiedRules","f","stripBOM","content","charCodeAt","slice","parseBOM","parseGraphQLJSON","jsonContent","parsedJson","data","__schema","buildClientSchema","rawSDL","MAX_LINE_LENGTH","commentsRegistry","resetComments","collectComment","entityName","pushComment","isFieldDefinitionNode","argument","comment","getComment","keys","path","printComment","maybeArray","separator","x","hasMultilineItems","addDescription","cb","_key","_parent","ancestors","parent","indent","maybeString","wrap","start","end","printBlockString","isDescription","escaped","indexOf","printDocASTReducer","Name","leave","Variable","Document","OperationDefinition","varDefs","variableDefinitions","prefix","selectionSet","VariableDefinition","variable","SelectionSet","selections","Field","argsLine","Argument","FragmentSpread","InlineFragment","typeCondition","FragmentDefinition","IntValue","FloatValue","StringValue","isBlockString","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","printDocASTReducerWithComments","printWithComments","visit","getDescription","commentDescriptions","rawValue","getLeadingCommentBlock","dedentBlockStringValue","loc","comments","token","startToken","TokenKind","COMMENT","next","reverse","rawString","lines","split","commonIndent","getBlockStringIndentation","isBlank","shift","pop","leadingWhitespace","parseGraphQLSDL","transformCommentsToDescriptions","noLocation","Source","trim","sourceSdl","parsedDoc","modifiedDoc","isDescribable","commentsBlock","isBlock","isTypeSystemDefinitionNode","operationVariables","fieldTypeMap","addOperationVariable","resetOperationVariables","resetFieldMap","buildOperationNodeForField","models","ignore","depthLimit","circularReferenceDepth","argNames","selectedFields","rootTypeNames","operationNode","buildOperationAndCollectVariables","Infinity","operationName","resolveVariable","OPERATION_DEFINITION","SELECTION_SET","resolveField","firstCall","depth","resolveSelectionSet","t","hasCircularRef","INLINE_FRAGMENT","fragmentNode","has","isIgnored","isModel","FIELD","getNamedType","selectedSubFields","resolveVariableType","VARIABLE_DEFINITION","getArgumentName","namedType","removeField","argumentName","fieldPath","fieldPathStr","config","size","MapperKind","getObjectTypeFromTypeMap","typeMap","maybeObjectType","createNamedStub","GraphQLObjectType","GraphQLInterfaceType","GraphQLInputObjectType","_fake","GraphQLString","createStub","GraphQLList","GraphQLNonNull","isNamedStub","getBuiltInForStub","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLID","rewireTypes","originalTypeMap","referenceTypeMap","create","newTypeMap","startsWith","newName","rewireNamedType","newDirectives","rewireDirective","directiveConfig","toConfig","rewireArgs","GraphQLDirective","rewiredArgs","rewiredArgType","rewireType","newConfig","rewireFields","rewireNamedTypes","GraphQLUnionType","rewireInputFields","enumConfig","GraphQLEnumType","scalarConfig","GraphQLScalarType","rewiredFields","rewiredFieldType","namedTypes","rewiredTypes","rewiredType","isNamedType","transformInputValue","inputLeafValueTransformer","inputObjectValueTransformer","nullableType","getNullableType","isLeafType","listMember","serializeInputValue","serialize","parseInputValue","parseValue","parseInputValueLiteral","parseLiteral","mapSchema","schemaMapper","mapArguments","mapFields","mapTypes","mapDefaultValues","mapEnumValues","originalDirectives","mapDirectives","GraphQLSchema","query","mutation","subscription","testFn","originalType","typeMapper","getTypeMapper","maybeNewType","enumValueMapper","getEnumValueMapper","ENUM_TYPE","originalEnumValueConfigMap","newEnumValueConfigMap","externalValue","originalEnumValueConfig","mappedEnumValue","newExternalValue","newEnumValueConfig","correctASTNodes","argumentConfig","getNewType","INPUT_OBJECT_FIELD","inputFieldConfig","newType","fieldMapper","getFieldMapper","originalFieldConfigMap","newFieldConfigMap","originalFieldConfig","mappedField","newFieldName","newFieldConfig","argumentMapper","getArgumentMapper","originalArgumentConfigMap","argumentNames","newArgumentConfigMap","originalArgumentConfig","mappedArgument","newArgumentName","newArgumentConfig","directiveMapper","getDirectiveMapper","mappedDirective","getTypeSpecifiers","getType","specifiers","TYPE","COMPOSITE_TYPE","OBJECT_TYPE","ROOT_OBJECT","QUERY","MUTATION","SUBSCRIPTION","INPUT_OBJECT_TYPE","ABSTRACT_TYPE","INTERFACE_TYPE","UNION_TYPE","SCALAR_TYPE","getFieldSpecifiers","COMPOSITE_FIELD","ROOT_FIELD","QUERY_ROOT_FIELD","MUTATION_ROOT_FIELD","SUBSCRIPTION_ROOT_FIELD","INTERFACE_FIELD","ENUM_VALUE","fieldConfig","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","enumKey","enumValueConfig","filterSchema","typeFilter","fieldFilter","rootFieldFilter","objectFieldFilter","interfaceFieldFilter","inputObjectFieldFilter","argumentFilter","filteredSchema","filterRootFields","filterElementFields","ElementConstructor","healSchema","healTypes","actualNamedTypeMap","actualName","decl","healType","healNamedType","healFields","healInterfaces","healUnderlyingTypes","healInputFields","fieldMap","splice","iface","healedType","officialType","getResolversFromSchema","resolvers","resolveType","__resolveType","isTypeOf","__isTypeOf","subscribe","resolve","forEachField","forEachDefaultValue","addTypes","newTypesOrDirectives","originalDirectiveMap","newTypeOrDirective","isDirective","pruneSchema","pruningContext","unusedTypes","implementations","getImplementations","visitTypes","skipPruning","skipEmptyCompositeTypePruning","skipUnusedTypesPruning","skipEmptyUnionPruning","skipUnimplementedInterfacesPruning","visitOutputType","visitedTypes","visitInputType","mergeDeep","sources","respectPrototype","target","output","setPrototypeOf","getPrototypeOf","source","isObject","outputPrototype","sourcePrototype","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","assign","parseSelectionSet","getResponseKeyFromInfo","info","appendObjectFields","additionalFields","removeObjectFields","removedFields","newSchema","selectObjectFields","modifyObjectFields","newFields","renameType","newTypeName","mapAsyncIterator","iterator","callback","rejectCallback","$return","abruptClose","return","rethrow","reject","then","mapResult","done","asyncMapValue","iteratorResult","mapReject","throw","catch","Symbol","asyncIterator","updateArgument","variableDefinitionsMap","varName","createVariableNameGenerator","variableDefinitionMap","varCounter","implementsAbstractType","typeA","typeB","isCompositeType","doTypesOverlap","relocatedError","originalError","positions","observableToAsyncIterable","observable","pullQueue","pushQueue","listening","pushValue","pushError","pushDone","pullValue","element","err","complete","emptyQueue","unsubscribe","getOperationASTFromDocument","doc","getOperationAST","getOperationASTFromRequest","request","collectFields","fragments","runtimeType","visitedFragmentNames","selection","shouldIncludeNode","getFieldEntryKey","fieldList","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","add","fragment","skip","getDirectiveValues","GraphQLSkipDirective","include","GraphQLIncludeDirective","typeConditionNode","conditionalType","typeFromAST","isAbstractType","possibleTypes","getPossibleTypes","collectSubFields","subFieldNodes","fieldNode","visitData","enter","newData","visitErrors","visitor","visitResult","resultVisitorMap","errorVisitorMap","variables","errorInfo","segmentInfoMap","unpathedErrors","visitingErrors","operationDocumentNode","visitRoot","visitErrorsByType","unpathedErrorVisitor","pathSegmentsInfo","newError","reduceRight","segmentInfo","typeVisitorMap","errorVisitor","pathIndex","root","operationRootType","getOperationRootType","collectedFields","visitObjectValue","fieldNodeMap","enterObject","__enter","newObject","sortedErrors","errorMap","sortErrorsByPathSegment","responseKey","fieldType","TypeNameMetaFieldDef","newPathIndex","fieldErrors","addPathSegmentInfo","visitFieldValue","updateObject","oldTypename","__typename","errorsKey","leaveObject","__leave","fieldVisitor","visitedValue","visitListValue","list","returnType","finalType","valueMatchesCriteria","criteria","every","val","propertyName","RegExp","isAsyncIterable","isDocumentNode","withCancel","asyncIteratorLike","onCancel","savedReturn","bind","buildFixedSchema","buildASTSchema","fixSchemaAst","schemaWithValidAst"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst graphql = require('graphql');\n\nconst asArray = (fns) => (Array.isArray(fns) ? fns : fns ? [fns] : []);\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\nfunction isDocumentString(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (invalidDocRegex.test(str)) {\n        return false;\n    }\n    try {\n        graphql.parse(str);\n        return true;\n    }\n    catch (e) { }\n    return false;\n}\nconst invalidPathRegex = /[‘“!%&^<=>`]/;\nfunction isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nfunction compareStrings(a, b) {\n    if (String(a) < String(b)) {\n        return -1;\n    }\n    if (String(a) > String(b)) {\n        return 1;\n    }\n    return 0;\n}\nfunction nodeToString(a) {\n    var _a, _b;\n    let name;\n    if ('alias' in a) {\n        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    if (name == null && 'name' in a) {\n        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n    }\n    if (name == null) {\n        name = a.kind;\n    }\n    return name;\n}\nfunction compareNodes(a, b, customFn) {\n    const aStr = nodeToString(a);\n    const bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\nfunction isSome(input) {\n    return input != null;\n}\nfunction assertSome(input, message = 'Value should be something') {\n    if (input == null) {\n        throw new Error(message);\n    }\n}\n\nexports.AggregateError = globalThis.AggregateError;\nif (typeof exports.AggregateError === 'undefined') {\n    class AggregateErrorClass extends Error {\n        constructor(errors, message = '') {\n            super(message);\n            this.errors = errors;\n            this.name = 'AggregateError';\n            Error.captureStackTrace(this, AggregateErrorClass);\n        }\n    }\n    exports.AggregateError = function (errors, message) {\n        return new AggregateErrorClass(errors, message);\n    };\n}\nfunction isAggregateError(error) {\n    return 'errors' in error && Array.isArray(error['errors']);\n}\n\n// Taken from graphql-js\n/* eslint-disable @typescript-eslint/ban-types */\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\nfunction inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch (typeof value) {\n        case 'string':\n            return JSON.stringify(value);\n        case 'function':\n            return value.name ? `[function ${value.name}]` : '[function]';\n        case 'object':\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatError(value) {\n    if (value instanceof graphql.GraphQLError) {\n        return value.toString();\n    }\n    return `${value.name}: ${value.message};\\n ${value.stack}`;\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (value === null) {\n        return 'null';\n    }\n    if (value instanceof Error) {\n        if (isAggregateError(value)) {\n            return formatError(value) + '\\n' + formatArray(value.errors, previouslySeenValues);\n        }\n        return formatError(value);\n    }\n    if (previouslySeenValues.includes(value)) {\n        return '[Circular]';\n    }\n    const seenValues = [...previouslySeenValues, value];\n    if (isJSONable(value)) {\n        const jsonValue = value.toJSON();\n        // check for infinite recursion\n        if (jsonValue !== value) {\n            return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n        }\n    }\n    else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction isJSONable(value) {\n    return typeof value.toJSON === 'function';\n}\nfunction formatObject(object, seenValues) {\n    const entries = Object.entries(object);\n    if (entries.length === 0) {\n        return '{}';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[' + getObjectTag(object) + ']';\n    }\n    const properties = entries.map(([key, value]) => key + ': ' + formatValue(value, seenValues));\n    return '{ ' + properties.join(', ') + ' }';\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return '[]';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[Array]';\n    }\n    const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n    const remaining = array.length - len;\n    const items = [];\n    for (let i = 0; i < len; ++i) {\n        items.push(formatValue(array[i], seenValues));\n    }\n    if (remaining === 1) {\n        items.push('... 1 more item');\n    }\n    else if (remaining > 1) {\n        items.push(`... ${remaining} more items`);\n    }\n    return '[' + items.join(', ') + ']';\n}\nfunction getObjectTag(object) {\n    const tag = Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object /, '')\n        .replace(/]$/, '');\n    if (tag === 'Object' && typeof object.constructor === 'function') {\n        const name = object.constructor.name;\n        if (typeof name === 'string' && name !== '') {\n            return name;\n        }\n    }\n    return tag;\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getArgumentValues(def, node, variableValues = {}) {\n    var _a;\n    const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({\n        ...prev,\n        [key]: value,\n    }), {});\n    const coercedValues = {};\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n    const argNodeMap = argumentNodes.reduce((prev, arg) => ({\n        ...prev,\n        [arg.name.value]: arg,\n    }), {});\n    for (const { name, type: argType, defaultValue } of def.args) {\n        const argumentNode = argNodeMap[name];\n        if (!argumentNode) {\n            if (defaultValue !== undefined) {\n                coercedValues[name] = defaultValue;\n            }\n            else if (graphql.isNonNullType(argType)) {\n                throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n            }\n            continue;\n        }\n        const valueNode = argumentNode.value;\n        let isNull = valueNode.kind === graphql.Kind.NULL;\n        if (valueNode.kind === graphql.Kind.VARIABLE) {\n            const variableName = valueNode.name.value;\n            if (variableValues == null || !variableMap[variableName]) {\n                if (defaultValue !== undefined) {\n                    coercedValues[name] = defaultValue;\n                }\n                else if (graphql.isNonNullType(argType)) {\n                    throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n                        `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n                }\n                continue;\n            }\n            isNull = variableValues[variableName] == null;\n        }\n        if (isNull && graphql.isNonNullType(argType)) {\n            throw new graphql.GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n        }\n        const coercedValue = graphql.valueFromAST(valueNode, argType, variableValues);\n        if (coercedValue === undefined) {\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\n            // execution. This is a runtime check to ensure execution does not\n            // continue with an invalid argument value.\n            throw new graphql.GraphQLError(`Argument \"${name}\" has invalid value ${graphql.print(valueNode)}.`, valueNode);\n        }\n        coercedValues[name] = coercedValue;\n    }\n    return coercedValues;\n}\n\nfunction getDirectivesInExtensions(node, pathToDirectivesInExtensions = ['directives']) {\n    return pathToDirectivesInExtensions.reduce((acc, pathSegment) => (acc == null ? acc : acc[pathSegment]), node === null || node === void 0 ? void 0 : node.extensions);\n}\nfunction _getDirectiveInExtensions(directivesInExtensions, directiveName) {\n    const directiveInExtensions = directivesInExtensions.filter(directiveAnnotation => directiveAnnotation.name === directiveName);\n    if (!directiveInExtensions.length) {\n        return undefined;\n    }\n    return directiveInExtensions.map(directive => { var _a; return (_a = directive.args) !== null && _a !== void 0 ? _a : {}; });\n}\nfunction getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => (acc == null ? acc : acc[pathSegment]), node === null || node === void 0 ? void 0 : node.extensions);\n    if (directivesInExtensions === undefined) {\n        return undefined;\n    }\n    if (Array.isArray(directivesInExtensions)) {\n        return _getDirectiveInExtensions(directivesInExtensions, directiveName);\n    }\n    // Support condensed format by converting to longer format\n    // The condensed format does not preserve ordering of directives when  repeatable directives are used.\n    // See https://github.com/ardatan/graphql-tools/issues/2534\n    const reformattedDirectivesInExtensions = [];\n    for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {\n        if (Array.isArray(argsOrArrayOfArgs)) {\n            for (const args of argsOrArrayOfArgs) {\n                reformattedDirectivesInExtensions.push({ name, args });\n            }\n        }\n        else {\n            reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });\n        }\n    }\n    return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);\n}\nfunction getDirectives(schema, node, pathToDirectivesInExtensions = ['directives']) {\n    const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n    if (directivesInExtensions != null && directivesInExtensions.length > 0) {\n        return directivesInExtensions;\n    }\n    const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n    const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n        schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n        return schemaDirectiveMap;\n    }, {});\n    let astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = [...astNodes, ...node.extensionASTNodes];\n    }\n    const result = [];\n    for (const astNode of astNodes) {\n        if (astNode.directives) {\n            for (const directiveNode of astNode.directives) {\n                const schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n                if (schemaDirective) {\n                    result.push({ name: directiveNode.name.value, args: getArgumentValues(schemaDirective, directiveNode) });\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);\n    if (directiveInExtensions != null) {\n        return directiveInExtensions;\n    }\n    const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;\n    if (schemaDirective == null) {\n        return undefined;\n    }\n    let astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = [...astNodes, ...node.extensionASTNodes];\n    }\n    const result = [];\n    for (const astNode of astNodes) {\n        if (astNode.directives) {\n            for (const directiveNode of astNode.directives) {\n                if (directiveNode.name.value === directiveName) {\n                    result.push(getArgumentValues(schemaDirective, directiveNode));\n                }\n            }\n        }\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    return result;\n}\n\nfunction parseDirectiveValue(value) {\n    switch (value.kind) {\n        case graphql.Kind.INT:\n            return parseInt(value.value);\n        case graphql.Kind.FLOAT:\n            return parseFloat(value.value);\n        case graphql.Kind.BOOLEAN:\n            return Boolean(value.value);\n        case graphql.Kind.STRING:\n        case graphql.Kind.ENUM:\n            return value.value;\n        case graphql.Kind.LIST:\n            return value.values.map(v => parseDirectiveValue(v));\n        case graphql.Kind.OBJECT:\n            return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});\n        case graphql.Kind.NULL:\n            return null;\n        default:\n            return null;\n    }\n}\nfunction getFieldsWithDirectives(documentNode, options = {}) {\n    const result = {};\n    let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n    if (options.includeInputTypes) {\n        selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n    }\n    const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n    for (const type of allTypes) {\n        const typeName = type.name.value;\n        if (type.fields == null) {\n            continue;\n        }\n        for (const field of type.fields) {\n            if (field.directives && field.directives.length > 0) {\n                const fieldName = field.name.value;\n                const key = `${typeName}.${fieldName}`;\n                const directives = field.directives.map(d => ({\n                    name: d.name.value,\n                    args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {}),\n                }));\n                result[key] = directives;\n            }\n        }\n    }\n    return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n    const allTypesMap = schema.getTypeMap();\n    const result = [];\n    for (const graphqlTypeName in allTypesMap) {\n        const graphqlType = allTypesMap[graphqlTypeName];\n        if (graphql.isObjectType(graphqlType)) {\n            const allInterfaces = graphqlType.getInterfaces();\n            if (allInterfaces.find(int => int.name === interfaceName)) {\n                result.push(graphqlType.name);\n            }\n        }\n    }\n    return result;\n}\n\nfunction astFromType(type) {\n    if (graphql.isNonNullType(type)) {\n        const innerType = astFromType(type.ofType);\n        if (innerType.kind === graphql.Kind.NON_NULL_TYPE) {\n            throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n        }\n        return {\n            kind: graphql.Kind.NON_NULL_TYPE,\n            type: innerType,\n        };\n    }\n    else if (graphql.isListType(type)) {\n        return {\n            kind: graphql.Kind.LIST_TYPE,\n            type: astFromType(type.ofType),\n        };\n    }\n    return {\n        kind: graphql.Kind.NAMED_TYPE,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n    };\n}\n\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\nfunction astFromValueUntyped(value) {\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: graphql.Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (Array.isArray(value)) {\n        const valuesNodes = [];\n        for (const item of value) {\n            const itemNode = astFromValueUntyped(item);\n            if (itemNode != null) {\n                valuesNodes.push(itemNode);\n            }\n        }\n        return { kind: graphql.Kind.LIST, values: valuesNodes };\n    }\n    if (typeof value === 'object') {\n        const fieldNodes = [];\n        for (const fieldName in value) {\n            const fieldValue = value[fieldName];\n            const ast = astFromValueUntyped(fieldValue);\n            if (ast) {\n                fieldNodes.push({\n                    kind: graphql.Kind.OBJECT_FIELD,\n                    name: { kind: graphql.Kind.NAME, value: fieldName },\n                    value: ast,\n                });\n            }\n        }\n        return { kind: graphql.Kind.OBJECT, fields: fieldNodes };\n    }\n    // Others serialize based on their corresponding JavaScript scalar types.\n    if (typeof value === 'boolean') {\n        return { kind: graphql.Kind.BOOLEAN, value };\n    }\n    // JavaScript numbers can be Int or Float values.\n    if (typeof value === 'number' && isFinite(value)) {\n        const stringNum = String(value);\n        return integerStringRegExp.test(stringNum)\n            ? { kind: graphql.Kind.INT, value: stringNum }\n            : { kind: graphql.Kind.FLOAT, value: stringNum };\n    }\n    if (typeof value === 'string') {\n        return { kind: graphql.Kind.STRING, value };\n    }\n    throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n\nfunction memoize1(fn) {\n    const memoize1cache = new WeakMap();\n    return function memoized(a1) {\n        const cachedValue = memoize1cache.get(a1);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1);\n            memoize1cache.set(a1, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize2(fn) {\n    const memoize2cache = new WeakMap();\n    return function memoized(a1, a2) {\n        let cache2 = memoize2cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2cache.set(a1, cache2);\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize3(fn) {\n    const memoize3Cache = new WeakMap();\n    return function memoized(a1, a2, a3) {\n        let cache2 = memoize3Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize3Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        const cachedValue = cache3.get(a3);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize4(fn) {\n    const memoize4Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize4Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize4Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cache4 = cache3.get(a3);\n        if (!cache4) {\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cachedValue = cache4.get(a4);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize5(fn) {\n    const memoize5Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4, a5) {\n        let cache2 = memoize5Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize5Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache4 = cache3.get(a3);\n        if (!cache4) {\n            cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache5 = cache4.get(a4);\n        if (!cache5) {\n            cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        const cachedValue = cache5.get(a5);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nconst memoize2of4cache = new WeakMap();\nfunction memoize2of4(fn) {\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize2of4cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2of4cache.set(a1, cache2);\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\n\nfunction getDefinedRootType(schema, operation) {\n    const rootTypeMap = getRootTypeMap(schema);\n    const rootType = rootTypeMap.get(operation);\n    if (rootType == null) {\n        throw new Error(`Root type for operation \"${operation}\" not defined by the given schema.`);\n    }\n    return rootType;\n}\nconst getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n    const rootTypes = getRootTypes(schema);\n    return new Set([...rootTypes].map(type => type.name));\n});\nconst getRootTypes = memoize1(function getRootTypes(schema) {\n    const rootTypeMap = getRootTypeMap(schema);\n    return new Set(rootTypeMap.values());\n});\nconst getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n    const rootTypeMap = new Map();\n    const queryType = schema.getQueryType();\n    if (queryType) {\n        rootTypeMap.set('query', queryType);\n    }\n    const mutationType = schema.getMutationType();\n    if (mutationType) {\n        rootTypeMap.set('mutation', mutationType);\n    }\n    const subscriptionType = schema.getSubscriptionType();\n    if (subscriptionType) {\n        rootTypeMap.set('subscription', subscriptionType);\n    }\n    return rootTypeMap;\n});\n\nfunction getDocumentNodeFromSchema(schema, options = {}) {\n    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n    const typesMap = schema.getTypeMap();\n    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n    const definitions = schemaNode != null ? [schemaNode] : [];\n    const directives = schema.getDirectives();\n    for (const directive of directives) {\n        if (graphql.isSpecifiedDirective(directive)) {\n            continue;\n        }\n        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n    }\n    for (const typeName in typesMap) {\n        const type = typesMap[typeName];\n        const isPredefinedScalar = graphql.isSpecifiedScalarType(type);\n        const isIntrospection = graphql.isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (graphql.isObjectType(type)) {\n            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isInterfaceType(type)) {\n            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isUnionType(type)) {\n            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isInputObjectType(type)) {\n            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isEnumType(type)) {\n            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isScalarType(type)) {\n            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n        }\n        else {\n            throw new Error(`Unknown type ${type}.`);\n        }\n    }\n    return {\n        kind: graphql.Kind.DOCUMENT,\n        definitions,\n    };\n}\n// this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\nfunction printSchemaWithDirectives(schema, options = {}) {\n    const documentNode = getDocumentNodeFromSchema(schema, options);\n    return graphql.print(documentNode);\n}\nfunction astFromSchema(schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    const operationTypeMap = new Map([\n        ['query', undefined],\n        ['mutation', undefined],\n        ['subscription', undefined],\n    ]);\n    const nodes = [];\n    if (schema.astNode != null) {\n        nodes.push(schema.astNode);\n    }\n    if (schema.extensionASTNodes != null) {\n        for (const extensionASTNode of schema.extensionASTNodes) {\n            nodes.push(extensionASTNode);\n        }\n    }\n    for (const node of nodes) {\n        if (node.operationTypes) {\n            for (const operationTypeDefinitionNode of node.operationTypes) {\n                operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n            }\n        }\n    }\n    const rootTypeMap = getRootTypeMap(schema);\n    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n        const rootType = rootTypeMap.get(operationTypeNode);\n        if (rootType != null) {\n            const rootTypeAST = astFromType(rootType);\n            if (operationTypeDefinitionNode != null) {\n                operationTypeDefinitionNode.type = rootTypeAST;\n            }\n            else {\n                operationTypeMap.set(operationTypeNode, {\n                    kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n                    operation: operationTypeNode,\n                    type: rootTypeAST,\n                });\n            }\n        }\n    }\n    const operationTypes = [...operationTypeMap.values()].filter(isSome);\n    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n    if (!operationTypes.length && !directives.length) {\n        return null;\n    }\n    const schemaNode = {\n        kind: operationTypes != null ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,\n        operationTypes,\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n    // This code is so weird because it needs to support GraphQL.js 14\n    // In GraphQL.js 14 there is no `description` value on schemaNode\n    schemaNode.description =\n        ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null)\n            ? {\n                kind: graphql.Kind.STRING,\n                value: schema.description,\n                block: true,\n            }\n            : undefined;\n    return schemaNode;\n}\nfunction astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c, _d;\n    return {\n        kind: graphql.Kind.DIRECTIVE_DEFINITION,\n        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (directive.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: directive.description,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: directive.name,\n        },\n        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        repeatable: directive.isRepeatable,\n        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map(location => ({\n            kind: graphql.Kind.NAME,\n            value: location,\n        }))) || [],\n    };\n}\nfunction getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let nodes = [];\n    if (entity.astNode != null) {\n        nodes.push(entity.astNode);\n    }\n    if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n        nodes = nodes.concat(entity.extensionASTNodes);\n    }\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = [];\n        for (const node of nodes) {\n            if (node.directives) {\n                directives.push(...node.directives);\n            }\n        }\n    }\n    return directives;\n}\nfunction getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    let directiveNodesBesidesDeprecated = [];\n    let deprecatedDirectiveNode = null;\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n    }\n    if (directives != null) {\n        directiveNodesBesidesDeprecated = directives.filter(directive => directive.name.value !== 'deprecated');\n        if (entity.deprecationReason != null) {\n            deprecatedDirectiveNode = (_b = directives.filter(directive => directive.name.value === 'deprecated')) === null || _b === void 0 ? void 0 : _b[0];\n        }\n    }\n    if (entity.deprecationReason != null &&\n        deprecatedDirectiveNode == null) {\n        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n    }\n    return deprecatedDirectiveNode == null\n        ? directiveNodesBesidesDeprecated\n        : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\nfunction astFromArg(arg, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    return {\n        kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (arg.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: arg.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: arg.name,\n        },\n        type: astFromType(arg.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        defaultValue: arg.defaultValue !== undefined ? (_c = graphql.astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,\n        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    const node = {\n        kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n    if ('getInterfaces' in type) {\n        node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n    }\n    return node;\n}\nfunction astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.UNION_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n        types: type.getTypes().map(type => astFromType(type)),\n    };\n}\nfunction astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.ENUM_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n    const directives = directivesInExtensions\n        ? makeDirectiveNodes(schema, directivesInExtensions)\n        : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];\n    const specifiedByValue = (type['specifiedByUrl'] || type['specifiedByURL']);\n    if (specifiedByValue && !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n        const specifiedByArgs = {\n            url: specifiedByValue,\n        };\n        directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n    }\n    return {\n        kind: graphql.Kind.SCALAR_TYPE_DEFINITION,\n        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n}\nfunction astFromField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.FIELD_DEFINITION,\n        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (field.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: field.name,\n        },\n        arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromInputField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    return {\n        kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (field.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: field.name,\n        },\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n        defaultValue: (_c = graphql.astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined,\n    };\n}\nfunction astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.ENUM_VALUE_DEFINITION,\n        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (value.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: value.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: value.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction makeDeprecatedDirective(deprecationReason) {\n    return makeDirectiveNode('deprecated', { reason: deprecationReason }, graphql.GraphQLDeprecatedDirective);\n}\nfunction makeDirectiveNode(name, args, directive) {\n    const directiveArguments = [];\n    if (directive != null) {\n        for (const arg of directive.args) {\n            const argName = arg.name;\n            const argValue = args[argName];\n            if (argValue !== undefined) {\n                const value = graphql.astFromValue(argValue, arg.type);\n                if (value) {\n                    directiveArguments.push({\n                        kind: graphql.Kind.ARGUMENT,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: argName,\n                        },\n                        value,\n                    });\n                }\n            }\n        }\n    }\n    else {\n        for (const argName in args) {\n            const argValue = args[argName];\n            const value = astFromValueUntyped(argValue);\n            if (value) {\n                directiveArguments.push({\n                    kind: graphql.Kind.ARGUMENT,\n                    name: {\n                        kind: graphql.Kind.NAME,\n                        value: argName,\n                    },\n                    value,\n                });\n            }\n        }\n    }\n    return {\n        kind: graphql.Kind.DIRECTIVE,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: name,\n        },\n        arguments: directiveArguments,\n    };\n}\nfunction makeDirectiveNodes(schema, directiveValues) {\n    const directiveNodes = [];\n    for (const directiveName in directiveValues) {\n        const arrayOrSingleValue = directiveValues[directiveName];\n        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n        if (Array.isArray(arrayOrSingleValue)) {\n            for (const value of arrayOrSingleValue) {\n                directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n            }\n        }\n        else {\n            directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n        }\n    }\n    return directiveNodes;\n}\n\nasync function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {\n    const allFragmentMap = new Map();\n    const documentFileObjectsToValidate = [];\n    for (const documentFile of documentFiles) {\n        if (documentFile.document) {\n            const definitionsToValidate = [];\n            for (const definitionNode of documentFile.document.definitions) {\n                if (definitionNode.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n                    allFragmentMap.set(definitionNode.name.value, definitionNode);\n                }\n                else {\n                    definitionsToValidate.push(definitionNode);\n                }\n            }\n            documentFileObjectsToValidate.push({\n                location: documentFile.location,\n                document: {\n                    kind: graphql.Kind.DOCUMENT,\n                    definitions: definitionsToValidate,\n                },\n            });\n        }\n    }\n    const allErrors = [];\n    const allFragmentsDocument = {\n        kind: graphql.Kind.DOCUMENT,\n        definitions: [...allFragmentMap.values()],\n    };\n    await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {\n        const documentToValidate = graphql.concatAST([allFragmentsDocument, documentFile.document]);\n        const errors = graphql.validate(schema, documentToValidate, effectiveRules);\n        if (errors.length > 0) {\n            allErrors.push({\n                filePath: documentFile.location,\n                errors,\n            });\n        }\n    }));\n    return allErrors;\n}\nfunction checkValidationErrors(loadDocumentErrors) {\n    if (loadDocumentErrors.length > 0) {\n        const errors = [];\n        for (const loadDocumentError of loadDocumentErrors) {\n            for (const graphQLError of loadDocumentError.errors) {\n                const error = new Error();\n                error.name = 'GraphQLDocumentError';\n                error.message = `${error.name}: ${graphQLError.message}`;\n                error.stack = error.message;\n                if (graphQLError.locations) {\n                    for (const location of graphQLError.locations) {\n                        error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;\n                    }\n                }\n                errors.push(error);\n            }\n        }\n        throw new exports.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;\n  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join('\\n\\n')}`);\n    }\n}\nfunction createDefaultRules() {\n    let ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n    if (graphql.versionInfo.major < 15) {\n        ignored = ignored.map(rule => rule.replace(/Rule$/, ''));\n    }\n    return graphql.specifiedRules.filter((f) => !ignored.includes(f.name));\n}\n\nfunction stripBOM(content) {\n    content = content.toString();\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (content.charCodeAt(0) === 0xfeff) {\n        content = content.slice(1);\n    }\n    return content;\n}\nfunction parseBOM(content) {\n    return JSON.parse(stripBOM(content));\n}\nfunction parseGraphQLJSON(location, jsonContent, options) {\n    let parsedJson = parseBOM(jsonContent);\n    if (parsedJson.data) {\n        parsedJson = parsedJson.data;\n    }\n    if (parsedJson.kind === 'Document') {\n        return {\n            location,\n            document: parsedJson,\n        };\n    }\n    else if (parsedJson.__schema) {\n        const schema = graphql.buildClientSchema(parsedJson, options);\n        return {\n            location,\n            schema,\n        };\n    }\n    else if (typeof parsedJson === 'string') {\n        return {\n            location,\n            rawSDL: parsedJson,\n        };\n    }\n    throw new Error(`Not valid JSON content`);\n}\n\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction resetComments() {\n    commentsRegistry = {};\n}\nfunction collectComment(node) {\n    var _a;\n    const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n    if (entityName == null) {\n        return;\n    }\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            if (node.values) {\n                for (const value of node.values) {\n                    pushComment(value, entityName, value.name.value);\n                }\n            }\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                for (const field of node.fields) {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        for (const arg of field.arguments) {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}\nfunction pushComment(node, entity, field, argument) {\n    const comment = getComment(node);\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nfunction printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n    var _a;\n    return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        var _a;\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n        const items = [];\n        if (node.kind.includes('Definition') && commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n    const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n    Name: { leave: node => node.value },\n    Variable: { leave: node => '$' + node.name },\n    // Document\n    Document: {\n        leave: node => join(node.definitions, '\\n\\n'),\n    },\n    OperationDefinition: {\n        leave: node => {\n            const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n            const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n            // the query short form.\n            return prefix + ' ' + node.selectionSet;\n        },\n    },\n    VariableDefinition: {\n        leave: ({ variable, type, defaultValue, directives }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' ')),\n    },\n    SelectionSet: { leave: ({ selections }) => block(selections) },\n    Field: {\n        leave({ alias, name, arguments: args, directives, selectionSet }) {\n            const prefix = wrap('', alias, ': ') + name;\n            let argsLine = prefix + wrap('(', join(args, ', '), ')');\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n            }\n            return join([argsLine, join(directives, ' '), selectionSet], ' ');\n        },\n    },\n    Argument: { leave: ({ name, value }) => name + ': ' + value },\n    // Fragments\n    FragmentSpread: {\n        leave: ({ name, directives }) => '...' + name + wrap(' ', join(directives, ' ')),\n    },\n    InlineFragment: {\n        leave: ({ typeCondition, directives, selectionSet }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' '),\n    },\n    FragmentDefinition: {\n        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => \n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n            `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n            selectionSet,\n    },\n    // Value\n    IntValue: { leave: ({ value }) => value },\n    FloatValue: { leave: ({ value }) => value },\n    StringValue: {\n        leave: ({ value, block: isBlockString }) => {\n            if (isBlockString) {\n                return printBlockString(value);\n            }\n            return JSON.stringify(value);\n        },\n    },\n    BooleanValue: { leave: ({ value }) => (value ? 'true' : 'false') },\n    NullValue: { leave: () => 'null' },\n    EnumValue: { leave: ({ value }) => value },\n    ListValue: { leave: ({ values }) => '[' + join(values, ', ') + ']' },\n    ObjectValue: { leave: ({ fields }) => '{' + join(fields, ', ') + '}' },\n    ObjectField: { leave: ({ name, value }) => name + ': ' + value },\n    // Directive\n    Directive: {\n        leave: ({ name, arguments: args }) => '@' + name + wrap('(', join(args, ', '), ')'),\n    },\n    // Type\n    NamedType: { leave: ({ name }) => name },\n    ListType: { leave: ({ type }) => '[' + type + ']' },\n    NonNullType: { leave: ({ type }) => type + '!' },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    OperationTypeDefinition: {\n        leave: ({ operation, type }) => operation + ': ' + type,\n    },\n    ScalarTypeDefinition: {\n        leave: ({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    FieldDefinition: {\n        leave: ({ name, arguments: args, type, directives }) => name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            ': ' +\n            type +\n            wrap(' ', join(directives, ' ')),\n    },\n    InputValueDefinition: {\n        leave: ({ name, type, defaultValue, directives }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' '),\n    },\n    InterfaceTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeDefinition: {\n        leave: ({ name, directives, types }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeDefinition: {\n        leave: ({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    EnumValueDefinition: {\n        leave: ({ name, directives }) => join([name, join(directives, ' ')], ' '),\n    },\n    InputObjectTypeDefinition: {\n        leave: ({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' '),\n    },\n    DirectiveDefinition: {\n        leave: ({ name, arguments: args, repeatable, locations }) => 'directive @' +\n            name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            (repeatable ? ' repeatable' : '') +\n            ' on ' +\n            join(locations, ' | '),\n    },\n    SchemaExtension: {\n        leave: ({ directives, operationTypes }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    ScalarTypeExtension: {\n        leave: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    InterfaceTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeExtension: {\n        leave: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeExtension: {\n        leave: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    InputObjectTypeExtension: {\n        leave: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n    },\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n    ...prev,\n    [key]: {\n        leave: addDescription(printDocASTReducer[key].leave),\n    },\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n    return graphql.visit(ast, printDocASTReducerWithComments);\n}\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nfunction getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n        return getComment(node);\n    }\n}\nfunction getComment(node) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n        return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n}\nfunction getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === graphql.TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nfunction dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\n/**\n * @internal\n */\nfunction getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL, options = {}) {\n    let document;\n    try {\n        if (options.commentDescriptions && rawSDL.includes('#')) {\n            document = transformCommentsToDescriptions(rawSDL, options);\n            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n            // into descriptions.\n            if (options.noLocation) {\n                document = graphql.parse(graphql.print(document), options);\n            }\n        }\n        else {\n            document = graphql.parse(new graphql.Source(rawSDL, location), options);\n        }\n    }\n    catch (e) {\n        if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n            document = {\n                kind: graphql.Kind.DOCUMENT,\n                definitions: [],\n            };\n        }\n        else {\n            throw e;\n        }\n    }\n    return {\n        location,\n        document,\n    };\n}\nfunction transformCommentsToDescriptions(sourceSdl, options = {}) {\n    const parsedDoc = graphql.parse(sourceSdl, {\n        ...options,\n        noLocation: false,\n    });\n    const modifiedDoc = graphql.visit(parsedDoc, {\n        leave: (node) => {\n            if (isDescribable(node)) {\n                const rawValue = getLeadingCommentBlock(node);\n                if (rawValue !== undefined) {\n                    const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n                    const isBlock = commentsBlock.includes('\\n');\n                    if (!node.description) {\n                        return {\n                            ...node,\n                            description: {\n                                kind: graphql.Kind.STRING,\n                                value: commentsBlock,\n                                block: isBlock,\n                            },\n                        };\n                    }\n                    else {\n                        return {\n                            ...node,\n                            description: {\n                                ...node.description,\n                                value: node.description.value + '\\n' + commentsBlock,\n                                block: true,\n                            },\n                        };\n                    }\n                }\n            }\n        },\n    });\n    return modifiedDoc;\n}\nfunction isDescribable(node) {\n    return (graphql.isTypeSystemDefinitionNode(node) ||\n        node.kind === graphql.Kind.FIELD_DEFINITION ||\n        node.kind === graphql.Kind.INPUT_VALUE_DEFINITION ||\n        node.kind === graphql.Kind.ENUM_VALUE_DEFINITION);\n}\n\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true, }) {\n    resetOperationVariables();\n    resetFieldMap();\n    const rootTypeNames = getRootTypeNames(schema);\n    const operationNode = buildOperationAndCollectVariables({\n        schema,\n        fieldName: field,\n        kind,\n        models: models || [],\n        ignore,\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames,\n        selectedFields,\n        rootTypeNames,\n    });\n    // attach variables\n    operationNode.variableDefinitions = [...operationVariables];\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nfunction buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames, }) {\n    const type = getDefinedRootType(schema, kind);\n    const field = type.getFields()[fieldName];\n    const operationName = `${fieldName}_${kind}`;\n    if (field.args) {\n        for (const arg of field.args) {\n            const argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        }\n    }\n    return {\n        kind: graphql.Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type,\n                    field,\n                    models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore,\n                    depthLimit,\n                    circularReferenceDepth,\n                    schema,\n                    depth: 0,\n                    argNames,\n                    selectedFields,\n                    rootTypeNames,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if (graphql.isUnionType(type)) {\n        const types = type.getTypes();\n        return {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (graphql.isInterfaceType(type)) {\n        const types = Object.values(schema.getTypeMap()).filter((t) => graphql.isObjectType(t) && t.getInterfaces().includes(type));\n        return {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (graphql.isObjectType(type) && !rootTypeNames.has(type.name)) {\n        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n        const isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: graphql.Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: graphql.Kind.FIELD,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        const fields = type.getFields();\n        return {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: Object.keys(fields)\n                .filter(fieldName => {\n                return !hasCircularRef([...ancestors, graphql.getNamedType(fields[fieldName].type)], {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(fieldName => {\n                const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type: type,\n                        field: fields[fieldName],\n                        models,\n                        path: [...path, fieldName],\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields: selectedSubFields,\n                        rootTypeNames,\n                    });\n                }\n                return null;\n            })\n                .filter((f) => {\n                var _a, _b;\n                if (f == null) {\n                    return false;\n                }\n                else if ('selectionSet' in f) {\n                    return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n                }\n                return true;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if (graphql.isListType(type)) {\n            return {\n                kind: graphql.Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if (graphql.isNonNullType(type)) {\n            return {\n                kind: graphql.Kind.NON_NULL_TYPE,\n                // for v16 compatibility\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: graphql.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: graphql.Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: graphql.Kind.VARIABLE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return [...path, name].join('_');\n}\nfunction resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    const namedType = graphql.getNamedType(field.type);\n    let args = [];\n    let removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(arg => {\n            const argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if (graphql.isNonNullType(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: graphql.Kind.ARGUMENT,\n                name: {\n                    kind: graphql.Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: graphql.Kind.VARIABLE,\n                    name: {\n                        kind: graphql.Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    const fieldPath = [...path, field.name];\n    const fieldPathStr = fieldPath.join('.');\n    let fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!graphql.isScalarType(namedType) && !graphql.isEnumType(namedType)) {\n        return {\n            kind: graphql.Kind.FIELD,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: field.name,\n            },\n            ...(fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } }),\n            selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models,\n                firstCall,\n                path: fieldPath,\n                ancestors: [...ancestors, type],\n                ignore,\n                depthLimit,\n                circularReferenceDepth,\n                schema,\n                depth: depth + 1,\n                argNames,\n                selectedFields,\n                rootTypeNames,\n            }) || undefined,\n            arguments: args,\n        };\n    }\n    return {\n        kind: graphql.Kind.FIELD,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: field.name,\n        },\n        ...(fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } }),\n        arguments: args,\n    };\n}\nfunction hasCircularRef(types, config = {\n    depth: 1,\n}) {\n    const type = types[types.length - 1];\n    if (graphql.isScalarType(type)) {\n        return false;\n    }\n    const size = types.filter(t => t.name === type.name).length;\n    return size > config.depth;\n}\n\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(exports.MapperKind || (exports.MapperKind = {}));\n\nfunction getObjectTypeFromTypeMap(typeMap, type) {\n    if (type) {\n        const maybeObjectType = typeMap[type.name];\n        if (graphql.isObjectType(maybeObjectType)) {\n            return maybeObjectType;\n        }\n    }\n}\n\nfunction createNamedStub(name, type) {\n    let constructor;\n    if (type === 'object') {\n        constructor = graphql.GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = graphql.GraphQLInterfaceType;\n    }\n    else {\n        constructor = graphql.GraphQLInputObjectType;\n    }\n    return new constructor({\n        name,\n        fields: {\n            _fake: {\n                type: graphql.GraphQLString,\n            },\n        },\n    });\n}\nfunction createStub(node, type) {\n    switch (node.kind) {\n        case graphql.Kind.LIST_TYPE:\n            return new graphql.GraphQLList(createStub(node.type, type));\n        case graphql.Kind.NON_NULL_TYPE:\n            return new graphql.GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nfunction isNamedStub(type) {\n    if ('getFields' in type) {\n        const fields = type.getFields();\n        // eslint-disable-next-line no-unreachable-loop\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            return field.name === '_fake';\n        }\n    }\n    return false;\n}\nfunction getBuiltInForStub(type) {\n    switch (type.name) {\n        case graphql.GraphQLInt.name:\n            return graphql.GraphQLInt;\n        case graphql.GraphQLFloat.name:\n            return graphql.GraphQLFloat;\n        case graphql.GraphQLString.name:\n            return graphql.GraphQLString;\n        case graphql.GraphQLBoolean.name:\n            return graphql.GraphQLBoolean;\n        case graphql.GraphQLID.name:\n            return graphql.GraphQLID;\n        default:\n            return type;\n    }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n    const referenceTypeMap = Object.create(null);\n    for (const typeName in originalTypeMap) {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    }\n    const newTypeMap = Object.create(null);\n    for (const typeName in referenceTypeMap) {\n        const namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const newName = namedType.name;\n        if (newName.startsWith('__')) {\n            continue;\n        }\n        if (newTypeMap[newName] != null) {\n            throw new Error(`Duplicate schema type name ${newName}`);\n        }\n        newTypeMap[newName] = namedType;\n    }\n    for (const typeName in newTypeMap) {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    }\n    const newDirectives = directives.map(directive => rewireDirective(directive));\n    return {\n        typeMap: newTypeMap,\n        directives: newDirectives,\n    };\n    function rewireDirective(directive) {\n        if (graphql.isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        const directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new graphql.GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        const rewiredArgs = {};\n        for (const argName in args) {\n            const arg = args[argName];\n            const rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        }\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (graphql.isObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n                interfaces: () => rewireNamedTypes(config.interfaces),\n            };\n            return new graphql.GraphQLObjectType(newConfig);\n        }\n        else if (graphql.isInterfaceType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n            };\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n            }\n            return new graphql.GraphQLInterfaceType(newConfig);\n        }\n        else if (graphql.isUnionType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                types: () => rewireNamedTypes(config.types),\n            };\n            return new graphql.GraphQLUnionType(newConfig);\n        }\n        else if (graphql.isInputObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireInputFields(config.fields),\n            };\n            return new graphql.GraphQLInputObjectType(newConfig);\n        }\n        else if (graphql.isEnumType(type)) {\n            const enumConfig = type.toConfig();\n            return new graphql.GraphQLEnumType(enumConfig);\n        }\n        else if (graphql.isScalarType(type)) {\n            if (graphql.isSpecifiedScalarType(type)) {\n                return type;\n            }\n            const scalarConfig = type.toConfig();\n            return new graphql.GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function rewireFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null && field.args) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        const rewiredTypes = [];\n        for (const namedType of namedTypes) {\n            const rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        }\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (graphql.isListType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new graphql.GraphQLList(rewiredType) : null;\n        }\n        else if (graphql.isNonNullType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new graphql.GraphQLNonNull(rewiredType) : null;\n        }\n        else if (graphql.isNamedType(type)) {\n            let rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n\nfunction transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = graphql.getNullableType(type);\n    if (graphql.isLeafType(nullableType)) {\n        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n    }\n    else if (graphql.isListType(nullableType)) {\n        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n    }\n    else if (graphql.isInputObjectType(nullableType)) {\n        const fields = nullableType.getFields();\n        const newValue = {};\n        for (const key in value) {\n            const field = fields[key];\n            if (field != null) {\n                newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n            }\n        }\n        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n    }\n    // unreachable, no other possible return value\n}\nfunction serializeInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\nfunction parseInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\nfunction parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n\nfunction mapSchema(schema, schemaMapper = {}) {\n    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => graphql.isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !graphql.isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n    return new graphql.GraphQLSchema({\n        ...schema.toConfig(),\n        query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n        mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n        subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    }\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [exports.MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            for (const externalValue in originalEnumValueConfigMap) {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            }\n            return correctASTNodes(new graphql.GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => graphql.isEnumType(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [exports.MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [exports.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if (graphql.isListType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql.GraphQLList(newType) : null;\n    }\n    else if (graphql.isNonNullType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql.GraphQLNonNull(newType) : null;\n    }\n    else if (graphql.isNamedType(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType) && !graphql.isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            }\n            if (graphql.isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if (graphql.isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const newArgumentConfigMap = {};\n                for (const argumentName of argumentNames) {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                }\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            }\n            if (graphql.isObjectType(originalType)) {\n                newTypeMap[typeName] = new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if (graphql.isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new graphql.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new graphql.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    for (const directive of originalDirectives) {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    }\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [exports.MapperKind.TYPE];\n    if (graphql.isObjectType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.OBJECT_TYPE);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.QUERY);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.MUTATION);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (graphql.isInputObjectType(type)) {\n        specifiers.push(exports.MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (graphql.isInterfaceType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.INTERFACE_TYPE);\n    }\n    else if (graphql.isUnionType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.UNION_TYPE);\n    }\n    else if (graphql.isEnumType(type)) {\n        specifiers.push(exports.MapperKind.ENUM_TYPE);\n    }\n    else if (graphql.isScalarType(type)) {\n        specifiers.push(exports.MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [exports.MapperKind.FIELD];\n    if (graphql.isObjectType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.OBJECT_FIELD);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (graphql.isInterfaceType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.INTERFACE_FIELD);\n    }\n    else if (graphql.isInputObjectType(type)) {\n        specifiers.push(exports.MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        // TODO: fix this as unknown cast\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[exports.MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[exports.MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[exports.MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type) {\n    if (graphql.isObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql.Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql.GraphQLObjectType(config);\n    }\n    else if (graphql.isInterfaceType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql.Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql.GraphQLInterfaceType(config);\n    }\n    else if (graphql.isInputObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql.GraphQLInputObjectType(config);\n    }\n    else if (graphql.isEnumType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            for (const enumKey in config.values) {\n                const enumValueConfig = config.values[enumKey];\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new graphql.GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\n\nfunction filterSchema({ schema, typeFilter = () => true, fieldFilter = undefined, rootFieldFilter = undefined, objectFieldFilter = undefined, interfaceFieldFilter = undefined, inputObjectFieldFilter = undefined, argumentFilter = undefined, }) {\n    const filteredSchema = mapSchema(schema, {\n        [exports.MapperKind.QUERY]: (type) => filterRootFields(type, 'Query', rootFieldFilter, argumentFilter),\n        [exports.MapperKind.MUTATION]: (type) => filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter),\n        [exports.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter),\n        [exports.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(graphql.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter)\n            : null,\n        [exports.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(graphql.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter)\n            : null,\n        [exports.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(graphql.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter)\n            : null,\n        [exports.MapperKind.UNION_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [exports.MapperKind.ENUM_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [exports.MapperKind.SCALAR_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n    });\n    return filteredSchema;\n}\nfunction filterRootFields(type, operation, rootFieldFilter, argumentFilter) {\n    if (rootFieldFilter || argumentFilter) {\n        const config = type.toConfig();\n        for (const fieldName in config.fields) {\n            const field = config.fields[fieldName];\n            if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n                delete config.fields[fieldName];\n            }\n            else if (argumentFilter && field.args) {\n                for (const argName in field.args) {\n                    if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {\n                        delete field.args[argName];\n                    }\n                }\n            }\n        }\n        return new graphql.GraphQLObjectType(config);\n    }\n    return type;\n}\nfunction filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {\n    if (fieldFilter || argumentFilter) {\n        const config = type.toConfig();\n        for (const fieldName in config.fields) {\n            const field = config.fields[fieldName];\n            if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n                delete config.fields[fieldName];\n            }\n            else if (argumentFilter && 'args' in field) {\n                for (const argName in field.args) {\n                    if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {\n                        delete field.args[argName];\n                    }\n                }\n            }\n        }\n        return new ElementConstructor(config);\n    }\n}\n\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nfunction healSchema(schema) {\n    healTypes(schema.getTypeMap(), schema.getDirectives());\n    return schema;\n}\nfunction healTypes(originalTypeMap, directives) {\n    const actualNamedTypeMap = Object.create(null);\n    // If any of the .name properties of the GraphQLNamedType objects in\n    // schema.getTypeMap() have changed, the keys of the type map need to\n    // be updated accordingly.\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const actualName = namedType.name;\n        if (actualName.startsWith('__')) {\n            continue;\n        }\n        if (actualName in actualNamedTypeMap) {\n            throw new Error(`Duplicate schema type name ${actualName}`);\n        }\n        actualNamedTypeMap[actualName] = namedType;\n        // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n    }\n    // Now add back every named type by its actual name.\n    for (const typeName in actualNamedTypeMap) {\n        const namedType = actualNamedTypeMap[typeName];\n        originalTypeMap[typeName] = namedType;\n    }\n    // Directive declaration argument types can refer to named types.\n    for (const decl of directives) {\n        decl.args = decl.args.filter(arg => {\n            arg.type = healType(arg.type);\n            return arg.type !== null;\n        });\n    }\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        // Heal all named types, except for dangling references, kept only to redirect.\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n            if (namedType != null) {\n                healNamedType(namedType);\n            }\n        }\n    }\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n            delete originalTypeMap[typeName];\n        }\n    }\n    function healNamedType(type) {\n        if (graphql.isObjectType(type)) {\n            healFields(type);\n            healInterfaces(type);\n            return;\n        }\n        else if (graphql.isInterfaceType(type)) {\n            healFields(type);\n            if ('getInterfaces' in type) {\n                healInterfaces(type);\n            }\n            return;\n        }\n        else if (graphql.isUnionType(type)) {\n            healUnderlyingTypes(type);\n            return;\n        }\n        else if (graphql.isInputObjectType(type)) {\n            healInputFields(type);\n            return;\n        }\n        else if (graphql.isLeafType(type)) {\n            return;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function healFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.args\n                .map(arg => {\n                arg.type = healType(arg.type);\n                return arg.type === null ? null : arg;\n            })\n                .filter(Boolean);\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healInterfaces(type) {\n        if ('getInterfaces' in type) {\n            const interfaces = type.getInterfaces();\n            interfaces.push(...interfaces\n                .splice(0)\n                .map(iface => healType(iface))\n                .filter(Boolean));\n        }\n    }\n    function healInputFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healUnderlyingTypes(type) {\n        const types = type.getTypes();\n        types.push(...types\n            .splice(0)\n            .map(t => healType(t))\n            .filter(Boolean));\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (graphql.isListType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new graphql.GraphQLList(healedType) : null;\n        }\n        else if (graphql.isNonNullType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new graphql.GraphQLNonNull(healedType) : null;\n        }\n        else if (graphql.isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            // Note that new types can still be simply added by adding a field, as\n            // the official type will be undefined, not null.\n            const officialType = originalTypeMap[type.name];\n            if (officialType && type !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\n\nfunction getResolversFromSchema(schema) {\n    var _a, _b;\n    const resolvers = Object.create(null);\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        if (!typeName.startsWith('__')) {\n            const type = typeMap[typeName];\n            if (graphql.isScalarType(type)) {\n                if (!graphql.isSpecifiedScalarType(type)) {\n                    const config = type.toConfig();\n                    delete config.astNode; // avoid AST duplication elsewhere\n                    resolvers[typeName] = new graphql.GraphQLScalarType(config);\n                }\n            }\n            else if (graphql.isEnumType(type)) {\n                resolvers[typeName] = {};\n                const values = type.getValues();\n                for (const value of values) {\n                    resolvers[typeName][value.name] = value.value;\n                }\n            }\n            else if (graphql.isInterfaceType(type)) {\n                if (type.resolveType != null) {\n                    resolvers[typeName] = {\n                        __resolveType: type.resolveType,\n                    };\n                }\n            }\n            else if (graphql.isUnionType(type)) {\n                if (type.resolveType != null) {\n                    resolvers[typeName] = {\n                        __resolveType: type.resolveType,\n                    };\n                }\n            }\n            else if (graphql.isObjectType(type)) {\n                resolvers[typeName] = {};\n                if (type.isTypeOf != null) {\n                    resolvers[typeName].__isTypeOf = type.isTypeOf;\n                }\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    if (field.subscribe != null) {\n                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n                        resolvers[typeName][fieldName].subscribe = field.subscribe;\n                    }\n                    if (field.resolve != null &&\n                        ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== 'defaultFieldResolver' &&\n                        ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== 'defaultMergedResolver') {\n                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n                        resolvers[typeName][fieldName].resolve = field.resolve;\n                    }\n                }\n            }\n        }\n    }\n    return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!graphql.getNamedType(type).name.startsWith('__') && graphql.isObjectType(type)) {\n            const fields = type.getFields();\n            for (const fieldName in fields) {\n                const field = fields[fieldName];\n                fn(field, typeName, fieldName);\n            }\n        }\n    }\n}\n\nfunction forEachDefaultValue(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if (!graphql.getNamedType(type).name.startsWith('__')) {\n            if (graphql.isObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    for (const arg of field.args) {\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\n                    }\n                }\n            }\n            else if (graphql.isInputObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    field.defaultValue = fn(field.type, field.defaultValue);\n                }\n            }\n        }\n    }\n}\n\n// addTypes uses toConfig to create a new schema with a new or replaced\nfunction addTypes(schema, newTypesOrDirectives) {\n    const config = schema.toConfig();\n    const originalTypeMap = {};\n    for (const type of config.types) {\n        originalTypeMap[type.name] = type;\n    }\n    const originalDirectiveMap = {};\n    for (const directive of config.directives) {\n        originalDirectiveMap[directive.name] = directive;\n    }\n    for (const newTypeOrDirective of newTypesOrDirectives) {\n        if (graphql.isNamedType(newTypeOrDirective)) {\n            originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n        else if (graphql.isDirective(newTypeOrDirective)) {\n            originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n    }\n    const { typeMap, directives } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));\n    return new graphql.GraphQLSchema({\n        ...config,\n        query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),\n        mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),\n        subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\n\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\nfunction pruneSchema(schema, options = {}) {\n    const pruningContext = {\n        schema,\n        unusedTypes: Object.create(null),\n        implementations: Object.create(null),\n    };\n    for (const typeName in schema.getTypeMap()) {\n        const type = schema.getType(typeName);\n        if (type && 'getInterfaces' in type) {\n            for (const iface of type.getInterfaces()) {\n                const implementations = getImplementations(pruningContext, iface);\n                if (implementations == null) {\n                    pruningContext.implementations[iface.name] = Object.create(null);\n                }\n                pruningContext.implementations[iface.name][type.name] = true;\n            }\n        }\n    }\n    visitTypes(pruningContext, schema);\n    return mapSchema(schema, {\n        [exports.MapperKind.TYPE]: (type) => {\n            // If we should NOT prune the type, return it immediately as unmodified\n            if (options.skipPruning && options.skipPruning(type)) {\n                return type;\n            }\n            if (graphql.isObjectType(type) || graphql.isInputObjectType(type)) {\n                if ((!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else if (graphql.isUnionType(type)) {\n                if ((!type.getTypes().length && !options.skipEmptyUnionPruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else if (graphql.isInterfaceType(type)) {\n                const implementations = getImplementations(pruningContext, type);\n                if ((!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning) ||\n                    (implementations && !Object.keys(implementations).length && !options.skipUnimplementedInterfacesPruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else {\n                if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n                    return null;\n                }\n            }\n        },\n    });\n}\nfunction visitOutputType(visitedTypes, pruningContext, type) {\n    if (visitedTypes[type.name]) {\n        return;\n    }\n    visitedTypes[type.name] = true;\n    pruningContext.unusedTypes[type.name] = false;\n    if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n        const fields = type.getFields();\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const namedType = graphql.getNamedType(field.type);\n            visitOutputType(visitedTypes, pruningContext, namedType);\n            for (const arg of field.args) {\n                const type = graphql.getNamedType(arg.type);\n                visitInputType(visitedTypes, pruningContext, type);\n            }\n        }\n        if (graphql.isInterfaceType(type)) {\n            const implementations = getImplementations(pruningContext, type);\n            if (implementations) {\n                for (const typeName in implementations) {\n                    visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));\n                }\n            }\n        }\n        if ('getInterfaces' in type) {\n            for (const iFace of type.getInterfaces()) {\n                visitOutputType(visitedTypes, pruningContext, iFace);\n            }\n        }\n    }\n    else if (graphql.isUnionType(type)) {\n        const types = type.getTypes();\n        for (const type of types) {\n            visitOutputType(visitedTypes, pruningContext, type);\n        }\n    }\n}\n/**\n * Get the implementations of an interface. May return undefined.\n */\nfunction getImplementations(pruningContext, type) {\n    return pruningContext.implementations[type.name];\n}\nfunction visitInputType(visitedTypes, pruningContext, type) {\n    if (visitedTypes[type.name]) {\n        return;\n    }\n    pruningContext.unusedTypes[type.name] = false;\n    visitedTypes[type.name] = true;\n    if (graphql.isInputObjectType(type)) {\n        const fields = type.getFields();\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const namedType = graphql.getNamedType(field.type);\n            visitInputType(visitedTypes, pruningContext, namedType);\n        }\n    }\n}\nfunction visitTypes(pruningContext, schema) {\n    for (const typeName in schema.getTypeMap()) {\n        if (!typeName.startsWith('__')) {\n            pruningContext.unusedTypes[typeName] = true;\n        }\n    }\n    const visitedTypes = Object.create(null);\n    const rootTypes = getRootTypes(schema);\n    for (const rootType of rootTypes) {\n        visitOutputType(visitedTypes, pruningContext, rootType);\n    }\n    for (const directive of schema.getDirectives()) {\n        for (const arg of directive.args) {\n            const type = graphql.getNamedType(arg.type);\n            visitInputType(visitedTypes, pruningContext, type);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction mergeDeep(sources, respectPrototype = false) {\n    const target = sources[0] || {};\n    const output = {};\n    if (respectPrototype) {\n        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));\n    }\n    for (const source of sources) {\n        if (isObject(target) && isObject(source)) {\n            if (respectPrototype) {\n                const outputPrototype = Object.getPrototypeOf(output);\n                const sourcePrototype = Object.getPrototypeOf(source);\n                if (sourcePrototype) {\n                    for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n                        const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n                        if (isSome(descriptor)) {\n                            Object.defineProperty(outputPrototype, key, descriptor);\n                        }\n                    }\n                }\n            }\n            for (const key in source) {\n                if (isObject(source[key])) {\n                    if (!(key in output)) {\n                        Object.assign(output, { [key]: source[key] });\n                    }\n                    else {\n                        output[key] = mergeDeep([output[key], source[key]], respectPrototype);\n                    }\n                }\n                else {\n                    Object.assign(output, { [key]: source[key] });\n                }\n            }\n        }\n    }\n    return output;\n}\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction parseSelectionSet(selectionSet, options) {\n    const query = graphql.parse(selectionSet, options).definitions[0];\n    return query.selectionSet;\n}\n\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\nfunction getResponseKeyFromInfo(info) {\n    return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n    if (schema.getType(typeName) == null) {\n        return addTypes(schema, [\n            new graphql.GraphQLObjectType({\n                name: typeName,\n                fields: additionalFields,\n            }),\n        ]);\n    }\n    return mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n                }\n                for (const fieldName in additionalFields) {\n                    newFieldConfigMap[fieldName] = additionalFields[fieldName];\n                }\n                return correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n}\nfunction removeObjectFields(schema, typeName, testFn) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                }\n                return correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\nfunction selectObjectFields(schema, typeName, testFn) {\n    const selectedFields = {};\n    mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        selectedFields[fieldName] = originalFieldConfig;\n                    }\n                }\n            }\n            return undefined;\n        },\n    });\n    return selectedFields;\n}\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                }\n                for (const fieldName in newFields) {\n                    const fieldConfig = newFields[fieldName];\n                    newFieldConfigMap[fieldName] = fieldConfig;\n                }\n                return correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n    if (graphql.isObjectType(type)) {\n        return new graphql.GraphQLObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isInterfaceType(type)) {\n        return new graphql.GraphQLInterfaceType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isUnionType(type)) {\n        return new graphql.GraphQLUnionType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isInputObjectType(type)) {\n        return new graphql.GraphQLInputObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isEnumType(type)) {\n        return new graphql.GraphQLEnumType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isScalarType(type)) {\n        return new graphql.GraphQLScalarType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    throw new Error(`Unknown type ${type}.`);\n}\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n    let $return;\n    let abruptClose;\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => Promise.reject(error);\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n    }\n    let mapReject;\n    if (rejectCallback) {\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = rejectCallback;\n        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            return $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            return Promise.reject(error).catch(abruptClose);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction asyncMapValue(value, callback) {\n    return new Promise(resolve => resolve(callback(value)));\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\n\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {\n    argumentNodes[argName] = {\n        kind: graphql.Kind.ARGUMENT,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: argName,\n        },\n        value: {\n            kind: graphql.Kind.VARIABLE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: varName,\n            },\n        },\n    };\n    variableDefinitionsMap[varName] = {\n        kind: graphql.Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: graphql.Kind.VARIABLE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: varName,\n            },\n        },\n        type: astFromType(type),\n    };\n    if (value !== undefined) {\n        variableValues[varName] = value;\n        return;\n    }\n    // including the variable in the map with value of `undefined`\n    // will actually be translated by graphql-js into `null`\n    // see https://github.com/graphql/graphql-js/issues/2533\n    if (varName in variableValues) {\n        delete variableValues[varName];\n    }\n}\nfunction createVariableNameGenerator(variableDefinitionMap) {\n    let varCounter = 0;\n    return (argName) => {\n        let varName;\n        do {\n            varName = `_v${(varCounter++).toString()}_${argName}`;\n        } while (varName in variableDefinitionMap);\n        return varName;\n    };\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n    if (typeB == null || typeA == null) {\n        return false;\n    }\n    else if (typeA === typeB) {\n        return true;\n    }\n    else if (graphql.isCompositeType(typeA) && graphql.isCompositeType(typeB)) {\n        return graphql.doTypesOverlap(schema, typeA, typeB);\n    }\n    return false;\n}\n\nfunction relocatedError(originalError, path) {\n    return new graphql.GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction observableToAsyncIterable(observable) {\n    const pullQueue = [];\n    const pushQueue = [];\n    let listening = true;\n    const pushValue = (value) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value, done: false });\n        }\n        else {\n            pushQueue.push({ value, done: false });\n        }\n    };\n    const pushError = (error) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\n        }\n        else {\n            pushQueue.push({ value: { errors: [error] }, done: false });\n        }\n    };\n    const pushDone = () => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ done: true });\n        }\n        else {\n            pushQueue.push({ done: true });\n        }\n    };\n    const pullValue = () => new Promise(resolve => {\n        if (pushQueue.length !== 0) {\n            const element = pushQueue.shift();\n            // either {value: {errors: [...]}} or {value: ...}\n            resolve(element);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const subscription = observable.subscribe({\n        next(value) {\n            pushValue(value);\n        },\n        error(err) {\n            pushError(err);\n        },\n        complete() {\n            pushDone();\n        },\n    });\n    const emptyQueue = () => {\n        if (listening) {\n            listening = false;\n            subscription.unsubscribe();\n            for (const resolve of pullQueue) {\n                resolve({ value: undefined, done: true });\n            }\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    return {\n        next() {\n            // return is a defined method, so it is safe to call it.\n            return listening ? pullValue() : this.return();\n        },\n        return() {\n            emptyQueue();\n            return Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            emptyQueue();\n            return Promise.reject(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n\nfunction getOperationASTFromDocument(documentNode, operationName) {\n    const doc = graphql.getOperationAST(documentNode, operationName);\n    if (!doc) {\n        throw new Error(`Cannot infer operation ${operationName || ''}`);\n    }\n    return doc;\n}\nconst getOperationASTFromRequest = memoize1(function getOperationASTFromRequest(request) {\n    return getOperationASTFromDocument(request.document, request.operationName);\n});\n\n// Taken from GraphQL-JS v16 for backwards compat\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case graphql.Kind.FIELD: {\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                const name = getFieldEntryKey(selection);\n                const fieldList = fields.get(name);\n                if (fieldList !== undefined) {\n                    fieldList.push(selection);\n                }\n                else {\n                    fields.set(name, [selection]);\n                }\n                break;\n            }\n            case graphql.Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(variableValues, selection) ||\n                    !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n            case graphql.Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                visitedFragmentNames.add(fragName);\n                const fragment = fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n        }\n    }\n    return fields;\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(variableValues, node) {\n    const skip = graphql.getDirectiveValues(graphql.GraphQLSkipDirective, node, variableValues);\n    if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n        return false;\n    }\n    const include = graphql.getDirectiveValues(graphql.GraphQLIncludeDirective, node, variableValues);\n    if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = graphql.typeFromAST(schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if (graphql.isAbstractType(conditionalType)) {\n        const possibleTypes = schema.getPossibleTypes(conditionalType);\n        return possibleTypes.includes(type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\nconst collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n    const subFieldNodes = new Map();\n    const visitedFragmentNames = new Set();\n    for (const fieldNode of fieldNodes) {\n        if (fieldNode.selectionSet) {\n            collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n        }\n    }\n    return subFieldNodes;\n});\n\nfunction visitData(data, enter, leave) {\n    if (Array.isArray(data)) {\n        return data.map(value => visitData(value, enter, leave));\n    }\n    else if (typeof data === 'object') {\n        const newData = enter != null ? enter(data) : data;\n        if (newData != null) {\n            for (const key in newData) {\n                const value = newData[key];\n                Object.defineProperty(newData, key, {\n                    value: visitData(value, enter, leave),\n                });\n            }\n        }\n        return leave != null ? leave(newData) : newData;\n    }\n    return data;\n}\nfunction visitErrors(errors, visitor) {\n    return errors.map(error => visitor(error));\n}\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n    const fragments = request.document.definitions.reduce((acc, def) => {\n        if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n            acc[def.name.value] = def;\n        }\n        return acc;\n    }, {});\n    const variableValues = request.variables || {};\n    const errorInfo = {\n        segmentInfoMap: new Map(),\n        unpathedErrors: new Set(),\n    };\n    const data = result.data;\n    const errors = result.errors;\n    const visitingErrors = errors != null && errorVisitorMap != null;\n    const operationDocumentNode = getOperationASTFromRequest(request);\n    if (data != null && operationDocumentNode != null) {\n        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n    }\n    if (errors != null && errorVisitorMap) {\n        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n    }\n    return result;\n}\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n    const segmentInfoMap = errorInfo.segmentInfoMap;\n    const unpathedErrors = errorInfo.unpathedErrors;\n    const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n    return errors.map(originalError => {\n        const pathSegmentsInfo = segmentInfoMap.get(originalError);\n        const newError = pathSegmentsInfo == null\n            ? originalError\n            : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n                const typeName = segmentInfo.type.name;\n                const typeVisitorMap = errorVisitorMap[typeName];\n                if (typeVisitorMap == null) {\n                    return acc;\n                }\n                const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n                return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n            }, originalError);\n        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n            return unpathedErrorVisitor(newError);\n        }\n        return newError;\n    });\n}\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n    const operationRootType = graphql.getOperationRootType(schema, operation);\n    const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n    return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    const fieldMap = type.getFields();\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n    const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n    const newObject = enterObject != null ? enterObject(object) : object;\n    let sortedErrors;\n    let errorMap = null;\n    if (errors != null) {\n        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n        errorMap = sortedErrors.errorMap;\n        for (const error of sortedErrors.unpathedErrors) {\n            errorInfo.unpathedErrors.add(error);\n        }\n    }\n    for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n        const fieldName = subFieldNodes[0].name.value;\n        const fieldType = fieldName === '__typename' ? graphql.TypeNameMetaFieldDef.type : fieldMap[fieldName].type;\n        const newPathIndex = pathIndex + 1;\n        let fieldErrors;\n        if (errorMap) {\n            fieldErrors = errorMap[responseKey];\n            if (fieldErrors != null) {\n                delete errorMap[responseKey];\n            }\n            addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n        }\n        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n    }\n    const oldTypename = newObject.__typename;\n    if (oldTypename != null) {\n        updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n    }\n    if (errorMap) {\n        for (const errorsKey in errorMap) {\n            const errors = errorMap[errorsKey];\n            for (const error of errors) {\n                errorInfo.unpathedErrors.add(error);\n            }\n        }\n    }\n    const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n    return leaveObject != null ? leaveObject(newObject) : newObject;\n}\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n    if (typeVisitorMap == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const fieldVisitor = typeVisitorMap[fieldName];\n    if (fieldVisitor == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const visitedValue = fieldVisitor(newValue);\n    if (visitedValue === undefined) {\n        delete object[responseKey];\n        return;\n    }\n    object[responseKey] = visitedValue;\n}\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = graphql.getNullableType(returnType);\n    if (graphql.isListType(nullableType)) {\n        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (graphql.isAbstractType(nullableType)) {\n        const finalType = schema.getType(value.__typename);\n        const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);\n        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (graphql.isObjectType(nullableType)) {\n        const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);\n        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n    if (typeVisitorMap == null) {\n        return value;\n    }\n    const visitedValue = typeVisitorMap(value);\n    return visitedValue === undefined ? value : visitedValue;\n}\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n    var _a;\n    const errorMap = Object.create(null);\n    const unpathedErrors = new Set();\n    for (const error of errors) {\n        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n        if (pathSegment == null) {\n            unpathedErrors.add(error);\n            continue;\n        }\n        if (pathSegment in errorMap) {\n            errorMap[pathSegment].push(error);\n        }\n        else {\n            errorMap[pathSegment] = [error];\n        }\n    }\n    return {\n        errorMap,\n        unpathedErrors,\n    };\n}\nfunction addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {\n    for (const error of errors) {\n        const segmentInfo = {\n            type,\n            fieldName,\n            pathIndex,\n        };\n        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n        if (pathSegmentsInfo == null) {\n            errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n        }\n        else {\n            pathSegmentsInfo.push(segmentInfo);\n        }\n    }\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n    if (value == null) {\n        return value === criteria;\n    }\n    else if (Array.isArray(value)) {\n        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n    }\n    else if (typeof value === 'object') {\n        return (typeof criteria === 'object' &&\n            criteria &&\n            Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName])));\n    }\n    else if (criteria instanceof RegExp) {\n        return criteria.test(value);\n    }\n    return value === criteria;\n}\n\nfunction isAsyncIterable(value) {\n    return (typeof value === 'object' &&\n        value != null &&\n        Symbol.asyncIterator in value &&\n        typeof value[Symbol.asyncIterator] === 'function');\n}\n\nfunction isDocumentNode(object) {\n    return object && typeof object === 'object' && 'kind' in object && object.kind === graphql.Kind.DOCUMENT;\n}\n\nfunction withCancel(asyncIteratorLike, onCancel) {\n    const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();\n    if (!asyncIterator.return) {\n        asyncIterator.return = () => Promise.resolve({ value: undefined, done: true });\n    }\n    const savedReturn = asyncIterator.return.bind(asyncIterator);\n    asyncIterator.return = () => {\n        onCancel();\n        return savedReturn();\n    };\n    return asyncIterator;\n}\n\nfunction buildFixedSchema(schema, options) {\n    const document = getDocumentNodeFromSchema(schema);\n    return graphql.buildASTSchema(document, {\n        ...(options || {}),\n    });\n}\nfunction fixSchemaAst(schema, options) {\n    // eslint-disable-next-line no-undef-init\n    let schemaWithValidAst = undefined;\n    if (!schema.astNode || !schema.extensionASTNodes) {\n        schemaWithValidAst = buildFixedSchema(schema, options);\n    }\n    if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n        schema.astNode = schemaWithValidAst.astNode;\n    }\n    if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n    }\n    return schema;\n}\n\nexports.addTypes = addTypes;\nexports.appendObjectFields = appendObjectFields;\nexports.asArray = asArray;\nexports.assertSome = assertSome;\nexports.astFromArg = astFromArg;\nexports.astFromDirective = astFromDirective;\nexports.astFromEnumType = astFromEnumType;\nexports.astFromEnumValue = astFromEnumValue;\nexports.astFromField = astFromField;\nexports.astFromInputField = astFromInputField;\nexports.astFromInputObjectType = astFromInputObjectType;\nexports.astFromInterfaceType = astFromInterfaceType;\nexports.astFromObjectType = astFromObjectType;\nexports.astFromScalarType = astFromScalarType;\nexports.astFromSchema = astFromSchema;\nexports.astFromUnionType = astFromUnionType;\nexports.astFromValueUntyped = astFromValueUntyped;\nexports.buildOperationNodeForField = buildOperationNodeForField;\nexports.checkValidationErrors = checkValidationErrors;\nexports.collectComment = collectComment;\nexports.collectFields = collectFields;\nexports.collectSubFields = collectSubFields;\nexports.compareNodes = compareNodes;\nexports.compareStrings = compareStrings;\nexports.correctASTNodes = correctASTNodes;\nexports.createDefaultRules = createDefaultRules;\nexports.createNamedStub = createNamedStub;\nexports.createStub = createStub;\nexports.createVariableNameGenerator = createVariableNameGenerator;\nexports.dedentBlockStringValue = dedentBlockStringValue;\nexports.filterSchema = filterSchema;\nexports.fixSchemaAst = fixSchemaAst;\nexports.forEachDefaultValue = forEachDefaultValue;\nexports.forEachField = forEachField;\nexports.getArgumentValues = getArgumentValues;\nexports.getBlockStringIndentation = getBlockStringIndentation;\nexports.getBuiltInForStub = getBuiltInForStub;\nexports.getComment = getComment;\nexports.getDefinedRootType = getDefinedRootType;\nexports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;\nexports.getDescription = getDescription;\nexports.getDirective = getDirective;\nexports.getDirectiveInExtensions = getDirectiveInExtensions;\nexports.getDirectiveNodes = getDirectiveNodes;\nexports.getDirectives = getDirectives;\nexports.getDirectivesInExtensions = getDirectivesInExtensions;\nexports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;\nexports.getFieldsWithDirectives = getFieldsWithDirectives;\nexports.getImplementingTypes = getImplementingTypes;\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nexports.getOperationASTFromDocument = getOperationASTFromDocument;\nexports.getOperationASTFromRequest = getOperationASTFromRequest;\nexports.getResolversFromSchema = getResolversFromSchema;\nexports.getResponseKeyFromInfo = getResponseKeyFromInfo;\nexports.getRootTypeMap = getRootTypeMap;\nexports.getRootTypeNames = getRootTypeNames;\nexports.getRootTypes = getRootTypes;\nexports.healSchema = healSchema;\nexports.healTypes = healTypes;\nexports.implementsAbstractType = implementsAbstractType;\nexports.inspect = inspect;\nexports.isAggregateError = isAggregateError;\nexports.isAsyncIterable = isAsyncIterable;\nexports.isDescribable = isDescribable;\nexports.isDocumentNode = isDocumentNode;\nexports.isDocumentString = isDocumentString;\nexports.isNamedStub = isNamedStub;\nexports.isSome = isSome;\nexports.isValidPath = isValidPath;\nexports.makeDeprecatedDirective = makeDeprecatedDirective;\nexports.makeDirectiveNode = makeDirectiveNode;\nexports.makeDirectiveNodes = makeDirectiveNodes;\nexports.mapAsyncIterator = mapAsyncIterator;\nexports.mapSchema = mapSchema;\nexports.memoize1 = memoize1;\nexports.memoize2 = memoize2;\nexports.memoize2of4 = memoize2of4;\nexports.memoize3 = memoize3;\nexports.memoize4 = memoize4;\nexports.memoize5 = memoize5;\nexports.mergeDeep = mergeDeep;\nexports.modifyObjectFields = modifyObjectFields;\nexports.nodeToString = nodeToString;\nexports.observableToAsyncIterable = observableToAsyncIterable;\nexports.parseGraphQLJSON = parseGraphQLJSON;\nexports.parseGraphQLSDL = parseGraphQLSDL;\nexports.parseInputValue = parseInputValue;\nexports.parseInputValueLiteral = parseInputValueLiteral;\nexports.parseSelectionSet = parseSelectionSet;\nexports.printComment = printComment;\nexports.printSchemaWithDirectives = printSchemaWithDirectives;\nexports.printWithComments = printWithComments;\nexports.pruneSchema = pruneSchema;\nexports.pushComment = pushComment;\nexports.relocatedError = relocatedError;\nexports.removeObjectFields = removeObjectFields;\nexports.renameType = renameType;\nexports.resetComments = resetComments;\nexports.rewireTypes = rewireTypes;\nexports.selectObjectFields = selectObjectFields;\nexports.serializeInputValue = serializeInputValue;\nexports.transformCommentsToDescriptions = transformCommentsToDescriptions;\nexports.transformInputValue = transformInputValue;\nexports.updateArgument = updateArgument;\nexports.validateGraphQlDocuments = validateGraphQlDocuments;\nexports.valueMatchesCriteria = valueMatchesCriteria;\nexports.visitData = visitData;\nexports.visitErrors = visitErrors;\nexports.visitResult = visitResult;\nexports.withCancel = withCancel;\n"]},"metadata":{},"sourceType":"script"}