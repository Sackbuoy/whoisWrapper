{"ast":null,"code":"/* globals AbortController */\n'use strict';\n\nconst {\n  extractBody,\n  mixinBody,\n  cloneBody\n} = require('./body');\n\nconst {\n  Headers,\n  fill: fillHeaders,\n  HeadersList\n} = require('./headers');\n\nconst util = require('../core/util');\n\nconst {\n  isValidHTTPToken,\n  EnvironmentSettingsObject,\n  toUSVString\n} = require('./util');\n\nconst {\n  forbiddenMethods,\n  corsSafeListedMethods,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache\n} = require('./constants');\n\nconst {\n  kEnumerableProperty\n} = util;\n\nconst {\n  kHeaders,\n  kSignal,\n  kState,\n  kGuard,\n  kRealm\n} = require('./symbols');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst assert = require('assert');\n\nlet TransformStream;\nconst kInit = Symbol('init'); // https://fetch.spec.whatwg.org/#request-class\n\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor() {\n    if ((arguments.length <= 0 ? undefined : arguments[0]) === kInit) {\n      return;\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    if (arguments.length >= 1 && typeof (arguments.length <= 1 ? undefined : arguments[1]) !== 'object' && (arguments.length <= 1 ? undefined : arguments[1]) !== undefined) {\n      throw new TypeError(\"Failed to construct 'Request': cannot convert to dictionary.\");\n    }\n\n    const input = (arguments.length <= 0 ? undefined : arguments[0]) instanceof Request ? arguments.length <= 0 ? undefined : arguments[0] : toUSVString(arguments.length <= 0 ? undefined : arguments[0]);\n    const init = arguments.length >= 1 ? (arguments.length <= 1 ? undefined : arguments[1]) ?? {} : {}; // TODO\n\n    this[kRealm] = {\n      settingsObject: {}\n    }; // 1. Let request be null.\n\n    let request = null; // 2. Let fallbackMode be null.\n\n    let fallbackMode = null; // 3. Let baseURL be this’s relevant settings object’s API base URL.\n\n    const baseUrl = this[kRealm].settingsObject.baseUrl; // 4. Let signal be null.\n\n    let signal = null; // 5. If input is a string, then:\n\n    if (typeof input === 'string') {\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL;\n\n      try {\n        parsedURL = new URL(input, baseUrl);\n      } catch (err) {\n        const error = new TypeError('Failed to parse URL from ' + input);\n        error.cause = err;\n        throw error;\n      } // 3. If parsedURL includes credentials, then throw a TypeError.\n\n\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError('Request cannot be constructed from a URL that includes credentials: ' + input);\n      } // 4. Set request to a new request whose URL is parsedURL.\n\n\n      request = makeRequest({\n        urlList: [parsedURL]\n      }); // 5. Set fallbackMode to \"cors\".\n\n      fallbackMode = 'cors';\n    } else {\n      // 6. Otherwise:\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request); // 8. Set request to input’s request.\n\n      request = input[kState]; // 9. Set signal to input’s signal.\n\n      signal = input[kSignal];\n    } // 7. Let origin be this’s relevant settings object’s origin.\n\n\n    const origin = this[kRealm].settingsObject.origin; // 8. Let window be \"client\".\n\n    let window = 'client'; // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n\n    if (request.window instanceof EnvironmentSettingsObject && request.window.origin === origin) {\n      window = request.window;\n    } // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n\n\n    if ('window' in init && window !== null) {\n      throw new TypeError(`'window' option '${window}' must be null`);\n    } // 11. If init[\"window\"] exists, then set window to \"no-window\".\n\n\n    if ('window' in init) {\n      window = 'no-window';\n    } // 12. Set request to a new request with the following properties:\n\n\n    request = makeRequest({ ...request,\n      window\n    }); // 13. If init is not empty, then:\n\n    if (Object.keys(init).length > 0) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin';\n      } // 2. Unset request’s reload-navigation flag.\n\n\n      request.reloadNavigation = false; // 3. Unset request’s history-navigation flag.\n\n      request.historyNavigation = false; // 4. Set request’s referrer to \"client\"\n\n      request.referrer = 'client'; // 5. Set request’s referrer policy to the empty string.\n\n      request.referrerPolicy = '';\n    } // 14. If init[\"referrer\"] exists, then:\n\n\n    if ('referrer' in init) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer; // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n\n      if (!referrer === '') {\n        request.referrer = 'no-referrer';\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer;\n\n        try {\n          parsedReferrer = new URL(referrer, baseUrl);\n        } catch (err) {\n          const error = new TypeError(`Referrer \"${referrer}\" is not a valid URL.`);\n          error.cause = err;\n          throw error;\n        } // 3. If one of the following is true\n        // parsedReferrer’s cannot-be-a-base-URL is true, scheme is \"about\",\n        // and path contains a single string \"client\"\n        // parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        // TODO\n        // 4. Otherwise, set request’s referrer to parsedReferrer.\n\n\n        request.referrer = parsedReferrer;\n      }\n    } // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n\n\n    if ('referrerPolicy' in init) {\n      request.referrerPolicy = init.referrerPolicy;\n\n      if (!referrerPolicy.includes(request.referrerPolicy)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`);\n      }\n    } // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n\n\n    let mode;\n\n    if ('mode' in init) {\n      mode = init.mode;\n\n      if (!requestMode.includes(mode)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`);\n      }\n    } else {\n      mode = fallbackMode;\n    } // 17. If mode is \"navigate\", then throw a TypeError.\n\n\n    if (mode === 'navigate') {\n      throw new TypeError();\n    } // 18. If mode is non-null, set request’s mode to mode.\n\n\n    if (mode !== null) {\n      request.mode = mode;\n    } // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n\n\n    if ('credentials' in init) {\n      request.credentials = init.credentials;\n\n      if (!requestCredentials.includes(request.credentials)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`);\n      }\n    } // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n\n\n    if ('cache' in init) {\n      request.cache = init.cache;\n\n      if (!requestCache.includes(request.cache)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`);\n      }\n    } // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n\n\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n    } // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n\n\n    if ('redirect' in init) {\n      request.redirect = init.redirect;\n\n      if (!requestRedirect.includes(request.redirect)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`);\n      }\n    } // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n\n\n    if ('integrity' in init) {\n      request.integrity = String(init.integrity);\n    } // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n\n\n    if ('keepalive' in init) {\n      request.keepalive = Boolean(init.keepalive);\n    } // 25. If init[\"method\"] exists, then:\n\n\n    if ('method' in init) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method; // 2. If method is not a method or method is a forbidden method, then\n      // throw a TypeError.\n\n      if (!isValidHTTPToken(init.method)) {\n        throw TypeError(`'${init.method}' is not a valid HTTP method.`);\n      }\n\n      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n        throw TypeError(`'${init.method}' HTTP method is unsupported.`);\n      } // 3. Normalize method.\n      // https://fetch.spec.whatwg.org/#concept-method-normalize\n\n\n      method = init.method.toUpperCase(); // 4. Set request’s method to method.\n\n      request.method = method;\n    } // 26. If init[\"signal\"] exists, then set signal to it.\n\n\n    if ('signal' in init) {\n      signal = init.signal;\n    } // 27. Set this’s request to request.\n\n\n    this[kState] = request; // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n\n    const ac = new AbortController();\n    this[kSignal] = ac.signal;\n    this[kSignal][kRealm] = this[kRealm]; // 29. If signal is not null, then make this’s signal follow signal.\n\n    if (signal != null) {\n      if (!signal || typeof signal.aborted !== 'boolean' || typeof signal.addEventListener !== 'function') {\n        throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n      }\n\n      if (signal.aborted) {\n        ac.abort();\n      } else {\n        // TODO: Remove this listener on failure/success.\n        signal.addEventListener('abort', function () {\n          ac.abort();\n        }, {\n          once: true\n        });\n      }\n    } // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n\n\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'request';\n    this[kHeaders][kHeadersList] = request.headersList;\n    this[kHeaders][kRealm] = this[kRealm]; // 31. If this’s request’s mode is \"no-cors\", then:\n\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethods.includes(request.method)) {\n        throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);\n      } // 2. Set this’s headers’s guard to \"request-no-cors\".\n\n\n      this[kHeaders][kGuard] = 'request-no-cors';\n    } // 32. If init is not empty, then:\n\n\n    if (Object.keys(init).length !== 0) {\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      let headers = new Headers(this.headers); // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n\n      if ('headers' in init) {\n        headers = init.headers;\n      } // 3. Empty this’s headers’s header list.\n\n\n      this[kState].headersList = new HeadersList();\n      this[kHeaders][kHeadersList] = this[kState].headersList; // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n\n      if (headers instanceof Headers) {\n        this[kState].headersList.push(...headers[kHeadersList]);\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kState].headersList, headers);\n      }\n    } // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n\n\n    const inputBody = input instanceof Request ? input[kState].body : null; // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n\n    if (('body' in init && init.body != null || inputBody != null) && (request.method === 'GET' || request.method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.');\n    } // 35. Let initBody be null.\n\n\n    let initBody = null; // 36. If init[\"body\"] exists and is non-null, then:\n\n    if ('body' in init && init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(init.body, request.keepalive);\n      initBody = extractedBody; // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n\n      if (contentType && !this[kHeaders].has('content-type')) {\n        this[kHeaders].append('content-type', contentType);\n      }\n    } // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n\n\n    const inputOrInitBody = initBody ?? inputBody; // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n      } // 2. Set this’s request’s use-CORS-preflight flag.\n\n\n      request.useCORSPreflightFlag = true;\n    } // 39. Let finalBody be inputOrInitBody.\n\n\n    let finalBody = inputOrInitBody; // 40. If initBody is null and inputBody is non-null, then:\n\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError('Cannot construct a Request with a Request object that has already been used.');\n      } // 2. Set finalBody to the result of creating a proxy for inputBody.\n\n\n      if (!TransformStream) {\n        TransformStream = require('stream/web').TransformStream;\n      } // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n\n\n      const identityTransform = new TransformStream();\n      inputBody.stream.pipeThrough(identityTransform);\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      };\n    } // 41. Set this’s request’s body to finalBody.\n\n\n    this[kState].body = finalBody;\n  }\n\n  get [Symbol.toStringTag]() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this.constructor.name;\n  } // Returns request’s HTTP method, which is \"GET\" by default.\n\n\n  get method() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The method getter steps are to return this’s request’s method.\n\n\n    return this[kState].method;\n  } // Returns the URL of request as a string.\n\n\n  get url() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The url getter steps are to return this’s request’s URL, serialized.\n\n\n    return this[kState].url.toString();\n  } // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n\n\n  get headers() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The headers getter steps are to return this’s headers.\n\n\n    return this[kHeaders];\n  } // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n\n\n  get destination() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The destination getter are to return this’s request’s destination.\n\n\n    return this[kState].destination;\n  } // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n\n\n  get referrer() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n\n\n    if (this[kState].referrer === 'no-referrer') {\n      return '';\n    } // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n\n\n    if (this[kState].referrer === 'client') {\n      return 'about:client';\n    } // Return this’s request’s referrer, serialized.\n\n\n    return this[kState].referrer.toString();\n  } // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n\n\n  get referrerPolicy() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n\n\n    return this[kState].referrerPolicy;\n  } // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n\n\n  get mode() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The mode getter steps are to return this’s request’s mode.\n\n\n    return this[kState].mode;\n  } // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n\n\n  get credentials() {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials;\n  } // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n\n\n  get cache() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The cache getter steps are to return this’s request’s cache mode.\n\n\n    return this[kState].cache;\n  } // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n\n\n  get redirect() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The redirect getter steps are to return this’s request’s redirect mode.\n\n\n    return this[kState].redirect;\n  } // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n\n\n  get integrity() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n\n\n    return this[kState].integrity;\n  } // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n\n\n  get keepalive() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The keepalive getter steps are to return this’s request’s keepalive.\n\n\n    return this[kState].keepalive;\n  } // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n\n\n  get isReloadNavigation() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n\n\n    return this[kState].reloadNavigation;\n  } // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-foward navigation).\n\n\n  get isHistoryNavigation() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n\n\n    return this[kState].historyNavigation;\n  } // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n\n\n  get signal() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The signal getter steps are to return this’s signal.\n\n\n    return this[kSignal];\n  } // Returns a clone of request.\n\n\n  clone() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // 1. If this is unusable, then throw a TypeError.\n\n\n    if (this.bodyUsed || this.body && this.body.locked) {\n      throw new TypeError('unusable');\n    } // 2. Let clonedRequest be the result of cloning this’s request.\n\n\n    const clonedRequest = cloneRequest(this[kState]); // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n\n    const clonedRequestObject = new Request(kInit);\n    clonedRequestObject[kState] = clonedRequest;\n    clonedRequestObject[kRealm] = this[kRealm];\n    clonedRequestObject[kHeaders] = new Headers();\n    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;\n    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]; // 4. Make clonedRequestObject’s signal follow this’s signal.\n\n    const ac = new AbortController();\n\n    if (this.signal.aborted) {\n      ac.abort();\n    } else {\n      this.signal.addEventListener('abort', function () {\n        ac.abort();\n      }, {\n        once: true\n      });\n    }\n\n    clonedRequestObject[kSignal] = ac.signal; // 4. Return clonedRequestObject.\n\n    return clonedRequestObject;\n  }\n\n}\n\nmixinBody(Request.prototype);\n\nfunction makeRequest(init) {\n  // https://fetch.spec.whatwg.org/#requests\n  const request = {\n    method: 'GET',\n    localURLsOnly: false,\n    unsafeRequest: false,\n    body: null,\n    client: null,\n    reservedClient: null,\n    replacesClientId: '',\n    window: 'client',\n    keepalive: false,\n    serviceWorkers: 'all',\n    initiator: '',\n    destination: '',\n    priority: null,\n    origin: 'client',\n    policyContainer: 'client',\n    referrer: 'client',\n    referrerPolicy: '',\n    mode: 'no-cors',\n    useCORSPreflightFlag: false,\n    credentials: 'same-origin',\n    useCredentials: false,\n    cache: 'default',\n    redirect: 'follow',\n    integrity: '',\n    cryptoGraphicsNonceMetadata: '',\n    parserMetadata: '',\n    reloadNavigation: false,\n    historyNavigation: false,\n    userActivation: false,\n    taintedOrigin: false,\n    redirectCount: 0,\n    responseTainting: 'basic',\n    preventNoCacheCacheControlHeaderModification: false,\n    done: false,\n    timingAllowFailed: false,\n    ...init,\n    headersList: init.headersList ? new HeadersList(...init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList.map(url => new URL(url))] : []\n  };\n  request.url = request.urlList[0];\n  return request;\n} // https://fetch.spec.whatwg.org/#concept-request-clone\n\n\nfunction cloneRequest(request) {\n  // To clone a request request, run these steps:\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request,\n    body: null\n  }); // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n\n  if (request.body !== null) {\n    newRequest.body = cloneBody(request.body);\n  } // 3. Return newRequest.\n\n\n  return newRequest;\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty\n});\nmodule.exports = {\n  Request,\n  makeRequest\n};","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/fetch/request.js"],"names":["extractBody","mixinBody","cloneBody","require","Headers","fill","fillHeaders","HeadersList","util","isValidHTTPToken","EnvironmentSettingsObject","toUSVString","forbiddenMethods","corsSafeListedMethods","referrerPolicy","requestRedirect","requestMode","requestCredentials","requestCache","kEnumerableProperty","kHeaders","kSignal","kState","kGuard","kRealm","kHeadersList","assert","TransformStream","kInit","Symbol","Request","constructor","length","TypeError","undefined","input","init","settingsObject","request","fallbackMode","baseUrl","signal","parsedURL","URL","err","error","cause","username","password","makeRequest","urlList","origin","window","Object","keys","mode","reloadNavigation","historyNavigation","referrer","parsedReferrer","includes","credentials","cache","redirect","integrity","String","keepalive","Boolean","method","indexOf","toUpperCase","ac","AbortController","aborted","addEventListener","abort","once","headersList","headers","push","inputBody","body","initBody","extractedBody","contentType","has","append","inputOrInitBody","source","useCORSPreflightFlag","finalBody","isDisturbed","stream","locked","identityTransform","pipeThrough","readable","toStringTag","name","url","toString","destination","isReloadNavigation","isHistoryNavigation","clone","bodyUsed","clonedRequest","cloneRequest","clonedRequestObject","prototype","localURLsOnly","unsafeRequest","client","reservedClient","replacesClientId","serviceWorkers","initiator","priority","policyContainer","useCredentials","cryptoGraphicsNonceMetadata","parserMetadata","userActivation","taintedOrigin","redirectCount","responseTainting","preventNoCacheCacheControlHeaderModification","done","timingAllowFailed","map","newRequest","defineProperties","module","exports"],"mappings":"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","sourcesContent":["/* globals AbortController */\n\n'use strict'\n\nconst { extractBody, mixinBody, cloneBody } = require('./body')\nconst { Headers, fill: fillHeaders, HeadersList } = require('./headers')\nconst util = require('../core/util')\nconst {\n  isValidHTTPToken,\n  EnvironmentSettingsObject,\n  toUSVString\n} = require('./util')\nconst {\n  forbiddenMethods,\n  corsSafeListedMethods,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache\n} = require('./constants')\nconst { kEnumerableProperty } = util\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = require('./symbols')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\n\nlet TransformStream\n\nconst kInit = Symbol('init')\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (...args) {\n    if (args[0] === kInit) {\n      return\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to construct 'Request': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n    const input = args[0] instanceof Request ? args[0] : toUSVString(args[0])\n    const init = args.length >= 1 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = this[kRealm].settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        const error = new TypeError('Failed to parse URL from ' + input)\n        error.cause = err\n        throw error\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to input’s request.\n      request = input[kState]\n\n      // 9. Set signal to input’s signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = this[kRealm].settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window instanceof EnvironmentSettingsObject &&\n      request.window.origin === origin\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if ('window' in init && window !== null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      ...request,\n      window\n    })\n\n    // 13. If init is not empty, then:\n    if (Object.keys(init).length > 0) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 5. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if ('referrer' in init) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (!referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          const error = new TypeError(\n            `Referrer \"${referrer}\" is not a valid URL.`\n          )\n          error.cause = err\n          throw error\n        }\n\n        // 3. If one of the following is true\n        // parsedReferrer’s cannot-be-a-base-URL is true, scheme is \"about\",\n        // and path contains a single string \"client\"\n        // parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        // TODO\n\n        // 4. Otherwise, set request’s referrer to parsedReferrer.\n        request.referrer = parsedReferrer\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if ('referrerPolicy' in init) {\n      request.referrerPolicy = init.referrerPolicy\n      if (!referrerPolicy.includes(request.referrerPolicy)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`\n        )\n      }\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if ('mode' in init) {\n      mode = init.mode\n      if (!requestMode.includes(mode)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`\n        )\n      }\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw new TypeError()\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode !== null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if ('credentials' in init) {\n      request.credentials = init.credentials\n      if (!requestCredentials.includes(request.credentials)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`\n        )\n      }\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if ('cache' in init) {\n      request.cache = init.cache\n      if (!requestCache.includes(request.cache)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`\n        )\n      }\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if ('redirect' in init) {\n      request.redirect = init.redirect\n      if (!requestRedirect.includes(request.redirect)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`\n        )\n      }\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if ('integrity' in init) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if ('keepalive' in init) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if ('method' in init) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      // 2. If method is not a method or method is a forbidden method, then\n      // throw a TypeError.\n      if (!isValidHTTPToken(init.method)) {\n        throw TypeError(`'${init.method}' is not a valid HTTP method.`)\n      }\n\n      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n        throw TypeError(`'${init.method}' HTTP method is unsupported.`)\n      }\n\n      // 3. Normalize method.\n      // https://fetch.spec.whatwg.org/#concept-method-normalize\n      method = init.method.toUpperCase()\n\n      // 4. Set request’s method to method.\n      request.method = method\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if ('signal' in init) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this[kState] = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n    this[kSignal][kRealm] = this[kRealm]\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort()\n      } else {\n        // TODO: Remove this listener on failure/success.\n        signal.addEventListener(\n          'abort',\n          function () {\n            ac.abort()\n          },\n          { once: true }\n        )\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'request'\n    this[kHeaders][kHeadersList] = request.headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethods.includes(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      this[kHeaders][kGuard] = 'request-no-cors'\n    }\n\n    // 32. If init is not empty, then:\n    if (Object.keys(init).length !== 0) {\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      let headers = new Headers(this.headers)\n\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      if ('headers' in init) {\n        headers = init.headers\n      }\n\n      // 3. Empty this’s headers’s header list.\n      this[kState].headersList = new HeadersList()\n      this[kHeaders][kHeadersList] = this[kState].headersList\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof Headers) {\n        this[kState].headersList.push(...headers[kHeadersList])\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kState].headersList, headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (('body' in init && init.body != null) || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if ('body' in init && init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !this[kHeaders].has('content-type')) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 2. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      if (!TransformStream) {\n        TransformStream = require('stream/web').TransformStream\n      }\n\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The method getter steps are to return this’s request’s method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return this[kState].url.toString()\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The destination getter are to return this’s request’s destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-foward navigation).\n  get isHistoryNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The signal getter steps are to return this’s signal.\n    return this[kSignal]\n  }\n\n  // Returns a clone of request.\n  clone () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    const clonedRequestObject = new Request(kInit)\n    clonedRequestObject[kState] = clonedRequest\n    clonedRequestObject[kRealm] = this[kRealm]\n    clonedRequestObject[kHeaders] = new Headers()\n    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList\n    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort()\n    } else {\n      this.signal.addEventListener(\n        'abort',\n        function () {\n          ac.abort()\n        },\n        { once: true }\n      )\n    }\n    clonedRequestObject[kSignal] = ac.signal\n\n    // 4. Return clonedRequestObject.\n    return clonedRequestObject\n  }\n}\n\nmixinBody(Request.prototype)\n\nfunction makeRequest (init) {\n  // https://fetch.spec.whatwg.org/#requests\n  const request = {\n    method: 'GET',\n    localURLsOnly: false,\n    unsafeRequest: false,\n    body: null,\n    client: null,\n    reservedClient: null,\n    replacesClientId: '',\n    window: 'client',\n    keepalive: false,\n    serviceWorkers: 'all',\n    initiator: '',\n    destination: '',\n    priority: null,\n    origin: 'client',\n    policyContainer: 'client',\n    referrer: 'client',\n    referrerPolicy: '',\n    mode: 'no-cors',\n    useCORSPreflightFlag: false,\n    credentials: 'same-origin',\n    useCredentials: false,\n    cache: 'default',\n    redirect: 'follow',\n    integrity: '',\n    cryptoGraphicsNonceMetadata: '',\n    parserMetadata: '',\n    reloadNavigation: false,\n    historyNavigation: false,\n    userActivation: false,\n    taintedOrigin: false,\n    redirectCount: 0,\n    responseTainting: 'basic',\n    preventNoCacheCacheControlHeaderModification: false,\n    done: false,\n    timingAllowFailed: false,\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList.map((url) => new URL(url))] : []\n  }\n  request.url = request.urlList[0]\n  return request\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body !== null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty\n})\n\nmodule.exports = { Request, makeRequest }\n"]},"metadata":{},"sourceType":"script"}