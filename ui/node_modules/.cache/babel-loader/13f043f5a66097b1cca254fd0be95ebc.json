{"ast":null,"code":"'use strict';\n\nconst {\n  kClients\n} = require('../core/symbols');\n\nconst Agent = require('../agent');\n\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols');\n\nconst MockClient = require('./mock-client');\n\nconst MockPool = require('./mock-pool');\n\nconst {\n  matchValue,\n  buildMockOptions\n} = require('./mock-utils');\n\nconst {\n  InvalidArgumentError\n} = require('../core/errors');\n\nconst Dispatcher = require('../dispatcher');\n\nconst {\n  WeakRef\n} = require('../compat/dispatcher-weakref')();\n\nclass MockAgent extends Dispatcher {\n  constructor(opts) {\n    super(opts);\n    this[kNetConnect] = true;\n    this[kIsMockActive] = true; // Instantiate Agent and encapsulate\n\n    if (opts && opts.agent && typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent');\n    }\n\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n    this[kAgent] = agent;\n    this[kClients] = agent[kClients];\n    this[kOptions] = buildMockOptions(opts);\n  }\n\n  get(origin) {\n    let dispatcher = this[kMockAgentGet](origin);\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin);\n      this[kMockAgentSet](origin, dispatcher);\n    }\n\n    return dispatcher;\n  }\n\n  dispatch(opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin);\n    return this[kAgent].dispatch(opts, handler);\n  }\n\n  async close() {\n    await this[kAgent].close();\n    this[kClients].clear();\n  }\n\n  deactivate() {\n    this[kIsMockActive] = false;\n  }\n\n  activate() {\n    this[kIsMockActive] = true;\n  }\n\n  enableNetConnect(matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher);\n      } else {\n        this[kNetConnect] = [matcher];\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true;\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.');\n    }\n  }\n\n  disableNetConnect() {\n    this[kNetConnect] = false;\n  }\n\n  [kMockAgentSet](origin, dispatcher) {\n    this[kClients].set(origin, new WeakRef(dispatcher));\n  }\n\n  [kFactory](origin) {\n    const mockOptions = Object.assign({\n      agent: this\n    }, this[kOptions]);\n    return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n  }\n\n  [kMockAgentGet](origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin);\n\n    if (ref) {\n      return ref.deref();\n    } // If the origin is not a string create a dummy parent pool and return to user\n\n\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999');\n      this[kMockAgentSet](origin, dispatcher);\n      return dispatcher;\n    } // If we match, create a pool and assign the same dispatches\n\n\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref();\n\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin);\n        this[kMockAgentSet](origin, dispatcher);\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n        return dispatcher;\n      }\n    }\n  }\n\n  [kGetNetConnect]() {\n    return this[kNetConnect];\n  }\n\n}\n\nmodule.exports = MockAgent;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/mock/mock-agent.js"],"names":["kClients","require","Agent","kAgent","kMockAgentSet","kMockAgentGet","kDispatches","kIsMockActive","kNetConnect","kGetNetConnect","kOptions","kFactory","MockClient","MockPool","matchValue","buildMockOptions","InvalidArgumentError","Dispatcher","WeakRef","MockAgent","constructor","opts","agent","dispatch","get","origin","dispatcher","handler","close","clear","deactivate","activate","enableNetConnect","matcher","RegExp","Array","isArray","push","disableNetConnect","set","mockOptions","Object","assign","connections","ref","deref","keyMatcher","nonExplicitRef","from","nonExplicitDispatcher","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { kClients } = require('../core/symbols')\nconst Agent = require('../agent')\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols')\nconst MockClient = require('./mock-client')\nconst MockPool = require('./mock-pool')\nconst { matchValue, buildMockOptions } = require('./mock-utils')\nconst { InvalidArgumentError } = require('../core/errors')\nconst Dispatcher = require('../dispatcher')\nconst { WeakRef } = require('../compat/dispatcher-weakref')()\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, new WeakRef(dispatcher))\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin)\n    if (ref) {\n      return ref.deref()\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref()\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n}\n\nmodule.exports = MockAgent\n"]},"metadata":{},"sourceType":"script"}