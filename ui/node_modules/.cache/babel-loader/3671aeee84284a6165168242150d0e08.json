{"ast":null,"code":"'use strict';\n\nconst util = require('../core/util');\n\nconst {\n  kBodyUsed\n} = require('../core/symbols');\n\nconst assert = require('assert');\n\nconst {\n  InvalidArgumentError\n} = require('../core/errors');\n\nconst EE = require('events');\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308];\nconst kBody = Symbol('body');\n\nclass BodyAsyncIterable {\n  constructor(body) {\n    this[kBody] = body;\n    this[kBodyUsed] = false;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    assert(!this[kBodyUsed], 'disturbed');\n    this[kBodyUsed] = true;\n    yield* this[kBody];\n  }\n\n}\n\nclass RedirectHandler {\n  constructor(dispatcher, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n\n    util.validateHandler(handler, opts.method, opts.upgrade);\n    this.dispatcher = dispatcher;\n    this.location = null;\n    this.abort = null;\n    this.opts = { ...opts,\n      maxRedirections: 0\n    }; // opts must be a copy\n\n    this.maxRedirections = maxRedirections;\n    this.handler = handler;\n    this.history = [];\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body.on('data', function () {\n          assert(false);\n        });\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false;\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true;\n        });\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body);\n    } else if (this.opts.body && typeof this.opts.body !== 'string' && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body);\n    }\n  }\n\n  onConnect(abort) {\n    this.abort = abort;\n    this.handler.onConnect(abort, {\n      history: this.history\n    });\n  }\n\n  onUpgrade(statusCode, headers, socket) {\n    this.handler.onUpgrade(statusCode, headers, socket);\n  }\n\n  onError(error) {\n    this.handler.onError(error);\n  }\n\n  onHeaders(statusCode, headers, resume, statusText) {\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin));\n    }\n\n    if (!this.location) {\n      return this.handler.onHeaders(statusCode, headers, resume, statusText);\n    }\n\n    const {\n      origin,\n      pathname,\n      search\n    } = util.parseURL(new URL(this.location, this.opts.origin));\n    const path = search ? `${pathname}${search}` : pathname; // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n    this.opts.path = path;\n    this.opts.origin = origin;\n    this.opts.maxRedirections = 0; // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET';\n      this.opts.body = null;\n    }\n  }\n\n  onData(chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n         TLDR: undici always ignores 3xx response bodies.\n         Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n         For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n         For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      return this.handler.onData(chunk);\n    }\n  }\n\n  onComplete(trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n         TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n         See comment on onData method above for more detailed informations.\n      */\n      this.location = null;\n      this.abort = null;\n      this.dispatcher.dispatch(this.opts, this);\n    } else {\n      this.handler.onComplete(trailers);\n    }\n  }\n\n  onBodySent(chunk) {\n    if (this.handler.onBodySent) {\n      this.handler.onBodySent(chunk);\n    }\n  }\n\n}\n\nfunction parseLocation(statusCode, headers) {\n  if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n    return null;\n  }\n\n  for (let i = 0; i < headers.length; i += 2) {\n    if (headers[i].toString().toLowerCase() === 'location') {\n      return headers[i + 1];\n    }\n  }\n} // https://tools.ietf.org/html/rfc7231#section-6.4.4\n\n\nfunction shouldRemoveHeader(header, removeContent, unknownOrigin) {\n  return header.length === 4 && header.toString().toLowerCase() === 'host' || removeContent && header.toString().toLowerCase().indexOf('content-') === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization';\n} // https://tools.ietf.org/html/rfc7231#section-6.4\n\n\nfunction cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n  const ret = [];\n\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1]);\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    for (const key of Object.keys(headers)) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, headers[key]);\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array');\n  }\n\n  return ret;\n}\n\nmodule.exports = RedirectHandler;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/handler/redirect.js"],"names":["util","require","kBodyUsed","assert","InvalidArgumentError","EE","redirectableStatusCodes","kBody","Symbol","BodyAsyncIterable","constructor","body","asyncIterator","RedirectHandler","dispatcher","maxRedirections","opts","handler","Number","isInteger","validateHandler","method","upgrade","location","abort","history","isStream","bodyLength","on","readableDidRead","prototype","call","pipeTo","ArrayBuffer","isView","isIterable","onConnect","onUpgrade","statusCode","headers","socket","onError","error","onHeaders","resume","statusText","length","isDisturbed","parseLocation","origin","push","URL","path","pathname","search","parseURL","cleanRequestHeaders","onData","chunk","onComplete","trailers","dispatch","onBodySent","indexOf","i","toString","toLowerCase","shouldRemoveHeader","header","removeContent","unknownOrigin","ret","Array","isArray","key","Object","keys","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('../core/util')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { InvalidArgumentError } = require('../core/errors')\nconst EE = require('events')\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  constructor (dispatcher, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    util.validateHandler(handler, opts.method, opts.upgrade)\n\n    this.dispatcher = dispatcher\n    this.location = null\n    this.abort = null\n    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onConnect (abort) {\n    this.abort = abort\n    this.handler.onConnect(abort, { history: this.history })\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    this.handler.onUpgrade(statusCode, headers, socket)\n  }\n\n  onError (error) {\n    this.handler.onError(error)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)\n      ? null\n      : parseLocation(statusCode, headers)\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      return this.handler.onHeaders(statusCode, headers, resume, statusText)\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.maxRedirections = 0\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      this.opts.body = null\n    }\n  }\n\n  onData (chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      return this.handler.onData(chunk)\n    }\n  }\n\n  onComplete (trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed informations.\n      */\n\n      this.location = null\n      this.abort = null\n\n      this.dispatcher.dispatch(this.opts, this)\n    } else {\n      this.handler.onComplete(trailers)\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) {\n      this.handler.onBodySent(chunk)\n    }\n  }\n}\n\nfunction parseLocation (statusCode, headers) {\n  if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n    return null\n  }\n\n  for (let i = 0; i < headers.length; i += 2) {\n    if (headers[i].toString().toLowerCase() === 'location') {\n      return headers[i + 1]\n    }\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  return (\n    (header.length === 4 && header.toString().toLowerCase() === 'host') ||\n    (removeContent && header.toString().toLowerCase().indexOf('content-') === 0) ||\n    (unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization')\n  )\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    for (const key of Object.keys(headers)) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, headers[key])\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n"]},"metadata":{},"sourceType":"script"}