{"ast":null,"code":"import { isScalarType, getNamedType, defaultFieldResolver, isSchema, isSpecifiedScalarType, isEnumType, isUnionType, isObjectType, isInterfaceType, GraphQLEnumType, GraphQLScalarType, GraphQLUnionType, GraphQLObjectType, GraphQLInterfaceType, buildSchema, buildASTSchema } from 'graphql';\nimport { forEachField, mapSchema, MapperKind, forEachDefaultValue, serializeInputValue, healSchema, parseInputValue, pruneSchema, asArray, getResolversFromSchema } from '@graphql-tools/utils';\nimport { mergeTypeDefs, mergeResolvers, mergeExtensions, applyExtensions, extractExtensionsFromSchema } from '@graphql-tools/merge';\n\nfunction assertResolversPresent(schema) {\n  let resolverValidationOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    requireResolversForArgs,\n    requireResolversForNonScalar,\n    requireResolversForAllFields\n  } = resolverValidationOptions;\n\n  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n    throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');\n  }\n\n  forEachField(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n    } // requires a resolver on every field that has arguments\n\n\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n    } // requires a resolver on every field that returns a non-scalar type\n\n\n    if (requireResolversForNonScalar !== 'ignore' && !isScalarType(getNamedType(field.type))) {\n      expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n  if (!field.resolve) {\n    const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n\n    if (behavior === 'error') {\n      throw new Error(message);\n    }\n\n    if (behavior === 'warn') {\n      // eslint-disable-next-line no-console\n      console.warn(message);\n    }\n\n    return;\n  }\n\n  if (typeof field.resolve !== 'function') {\n    throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n  }\n}\n\nfunction chainResolvers(resolvers) {\n  return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n    if (curResolver != null) {\n      return curResolver(prev, args, ctx, info);\n    }\n\n    return defaultFieldResolver(prev, args, ctx, info);\n  }, root);\n} // If we have any union or interface types throw if no there is no resolveType resolver\n\n\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n  mapSchema(schema, {\n    [MapperKind.ABSTRACT_TYPE]: type => {\n      if (!type.resolveType) {\n        const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` + '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n\n        if (requireResolversForResolveType === 'error') {\n          throw new Error(message);\n        }\n\n        if (requireResolversForResolveType === 'warn') {\n          // eslint-disable-next-line no-console\n          console.warn(message);\n        }\n      }\n\n      return undefined;\n    }\n  });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n  const extendedResolvers = {};\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName];\n\n    if ('getInterfaces' in type) {\n      extendedResolvers[typeName] = {};\n\n      for (const iFace of type.getInterfaces()) {\n        if (resolvers[iFace.name]) {\n          for (const fieldName in resolvers[iFace.name]) {\n            if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n            }\n          }\n        }\n      }\n\n      const typeResolvers = resolvers[typeName];\n      extendedResolvers[typeName] = { ...extendedResolvers[typeName],\n        ...typeResolvers\n      };\n    } else {\n      const typeResolvers = resolvers[typeName];\n\n      if (typeResolvers != null) {\n        extendedResolvers[typeName] = typeResolvers;\n      }\n    }\n  }\n\n  return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n  const options = isSchema(schemaOrOptions) ? {\n    schema: schemaOrOptions,\n    resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},\n    resolverValidationOptions: legacyInputValidationOptions\n  } : schemaOrOptions;\n  let {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n    updateResolversInPlace = false\n  } = options;\n  const {\n    requireResolversToMatchSchema = 'error',\n    requireResolversForResolveType\n  } = resolverValidationOptions;\n  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;\n\n  for (const typeName in resolvers) {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object') {\n      throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n    }\n\n    const type = schema.getType(typeName);\n\n    if (type == null) {\n      if (requireResolversToMatchSchema === 'ignore') {\n        break;\n      }\n\n      throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n    } else if (isSpecifiedScalarType(type)) {\n      // allow -- without recommending -- overriding of specified scalar types\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if (isEnumType(type)) {\n      const values = type.getValues();\n\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && !values.some(value => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n        }\n      }\n    } else if (isUnionType(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n        }\n      }\n    } else if (isObjectType(type) || isInterfaceType(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__')) {\n          const fields = type.getFields();\n          const field = fields[fieldName];\n\n          if (field == null) {\n            // Field present in resolver but not in schema\n            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n            }\n          } else {\n            // Field present in both the resolver and schema\n            const fieldResolve = resolverValue[fieldName];\n\n            if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n\n  if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n    checkForResolveTypeResolver(schema, requireResolversForResolveType);\n  }\n\n  return schema;\n}\n\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in resolvers) {\n    const type = schema.getType(typeName);\n    const resolverValue = resolvers[typeName];\n\n    if (isScalarType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && type.astNode != null) {\n          type.astNode = { ...type.astNode,\n            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.astNode.description,\n            directives: ((_d = type.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n          type.extensionASTNodes = type.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if (isEnumType(type)) {\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          config[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && config.astNode != null) {\n          config.astNode = { ...config.astNode,\n            description: (_m = (_l = (_k = resolverValue) === null || _k === void 0 ? void 0 : _k.astNode) === null || _l === void 0 ? void 0 : _l.description) !== null && _m !== void 0 ? _m : config.astNode.description,\n            directives: ((_o = config.astNode.directives) !== null && _o !== void 0 ? _o : []).concat((_r = (_q = (_p = resolverValue) === null || _p === void 0 ? void 0 : _p.astNode) === null || _q === void 0 ? void 0 : _q.directives) !== null && _r !== void 0 ? _r : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n          config.extensionASTNodes = config.extensionASTNodes.concat((_t = (_s = resolverValue) === null || _s === void 0 ? void 0 : _s.extensionASTNodes) !== null && _t !== void 0 ? _t : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else if (enumValueConfigMap[fieldName]) {\n          enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n        }\n      }\n\n      typeMap[typeName] = new GraphQLEnumType(config);\n    } else if (isUnionType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        }\n      }\n    } else if (isObjectType(type) || isInterfaceType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          break;\n        }\n\n        const fields = type.getFields();\n        const field = fields[fieldName];\n\n        if (field != null) {\n          const fieldResolve = resolverValue[fieldName];\n\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            field.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(field, fieldResolve);\n          }\n        }\n      }\n    }\n  } // serialize all default values prior to healing fields with new scalar/enum types.\n\n\n  forEachDefaultValue(schema, serializeInputValue); // schema may have new scalar/enum types that require healing\n\n  healSchema(schema); // reparse all default values with new parsing functions.\n\n  forEachDefaultValue(schema, parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    forEachField(schema, field => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n  schema = mapSchema(schema, {\n    [MapperKind.SCALAR_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n      const config = type.toConfig();\n      const resolverValue = resolvers[type.name];\n\n      if (!isSpecifiedScalarType(type) && resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n              directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else {\n            config[fieldName] = resolverValue[fieldName];\n          }\n        }\n\n        return new GraphQLScalarType(config);\n      }\n    },\n    [MapperKind.ENUM_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n      const resolverValue = resolvers[type.name];\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      if (resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n              directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        }\n\n        return new GraphQLEnumType(config);\n      }\n    },\n    [MapperKind.UNION_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n\n        return new GraphQLUnionType(config);\n      }\n    },\n    [MapperKind.OBJECT_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__isTypeOf']) {\n          config.isTypeOf = resolverValue['__isTypeOf'];\n        }\n\n        return new GraphQLObjectType(config);\n      }\n    },\n    [MapperKind.INTERFACE_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n\n        return new GraphQLInterfaceType(config);\n      }\n    },\n    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n      const resolverValue = resolvers[typeName];\n\n      if (resolverValue != null) {\n        const fieldResolve = resolverValue[fieldName];\n\n        if (fieldResolve != null) {\n          const newFieldConfig = { ...fieldConfig\n          };\n\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(newFieldConfig, fieldResolve);\n          }\n\n          return newFieldConfig;\n        }\n      }\n    }\n  });\n\n  if (defaultFieldResolver != null) {\n    schema = mapSchema(schema, {\n      [MapperKind.OBJECT_FIELD]: fieldConfig => ({ ...fieldConfig,\n        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver\n      })\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(field, propertiesObj) {\n  for (const propertyName in propertiesObj) {\n    field[propertyName] = propertiesObj[propertyName];\n  }\n}\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\n\n\nfunction makeExecutableSchema(_ref) {\n  let {\n    typeDefs,\n    resolvers = {},\n    resolverValidationOptions = {},\n    parseOptions = {},\n    inheritResolversFromInterfaces = false,\n    pruningOptions,\n    updateResolversInPlace = false,\n    schemaExtensions\n  } = _ref;\n\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  }\n\n  let schema;\n\n  if (isSchema(typeDefs)) {\n    schema = typeDefs;\n  } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n    const mergedTypeDefs = mergeTypeDefs(typeDefs, { ...parseOptions,\n      commentDescriptions: true\n    });\n    schema = buildSchema(mergedTypeDefs, parseOptions);\n  } else {\n    const mergedTypeDefs = mergeTypeDefs(typeDefs, parseOptions);\n    schema = buildASTSchema(mergedTypeDefs, parseOptions);\n  }\n\n  if (pruningOptions) {\n    schema = pruneSchema(schema);\n  } // We allow passing in an array of resolver maps, in which case we merge them\n\n\n  schema = addResolversToSchema({\n    schema,\n    resolvers: mergeResolvers(resolvers),\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n    updateResolversInPlace\n  });\n\n  if (Object.keys(resolverValidationOptions).length > 0) {\n    assertResolversPresent(schema, resolverValidationOptions);\n  }\n\n  if (schemaExtensions) {\n    schemaExtensions = mergeExtensions(asArray(schemaExtensions));\n    applyExtensions(schema, schemaExtensions);\n  }\n\n  return schema;\n}\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\n\n\nfunction mergeSchemas(config) {\n  const extractedTypeDefs = asArray(config.typeDefs || []);\n  const extractedResolvers = asArray(config.resolvers || []);\n  const extractedSchemaExtensions = asArray(config.schemaExtensions || []);\n  const schemas = config.schemas || [];\n\n  for (const schema of schemas) {\n    extractedTypeDefs.push(schema);\n    extractedResolvers.push(getResolversFromSchema(schema));\n    extractedSchemaExtensions.push(extractExtensionsFromSchema(schema));\n  }\n\n  return makeExecutableSchema({\n    parseOptions: config,\n    ...config,\n    typeDefs: extractedTypeDefs,\n    resolvers: extractedResolvers,\n    schemaExtensions: extractedSchemaExtensions\n  });\n}\n\nexport { addResolversToSchema, assertResolversPresent, chainResolvers, checkForResolveTypeResolver, extendResolversFromInterfaces, makeExecutableSchema, mergeSchemas };","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/@graphql-tools/schema/index.mjs"],"names":["isScalarType","getNamedType","defaultFieldResolver","isSchema","isSpecifiedScalarType","isEnumType","isUnionType","isObjectType","isInterfaceType","GraphQLEnumType","GraphQLScalarType","GraphQLUnionType","GraphQLObjectType","GraphQLInterfaceType","buildSchema","buildASTSchema","forEachField","mapSchema","MapperKind","forEachDefaultValue","serializeInputValue","healSchema","parseInputValue","pruneSchema","asArray","getResolversFromSchema","mergeTypeDefs","mergeResolvers","mergeExtensions","applyExtensions","extractExtensionsFromSchema","assertResolversPresent","schema","resolverValidationOptions","requireResolversForArgs","requireResolversForNonScalar","requireResolversForAllFields","TypeError","field","typeName","fieldName","expectResolver","args","length","type","validator","behavior","resolve","message","Error","console","warn","chainResolvers","resolvers","root","ctx","info","reduce","prev","curResolver","checkForResolveTypeResolver","requireResolversForResolveType","ABSTRACT_TYPE","resolveType","name","undefined","extendResolversFromInterfaces","extendedResolvers","typeMap","getTypeMap","iFace","getInterfaces","startsWith","typeResolvers","addResolversToSchema","schemaOrOptions","legacyInputResolvers","legacyInputValidationOptions","options","inputResolvers","inheritResolversFromInterfaces","updateResolversInPlace","requireResolversToMatchSchema","resolverValue","resolverType","getType","substring","values","getValues","some","value","fields","getFields","fieldResolve","addResolversToExistingSchema","createNewSchemaWithResolvers","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","astNode","description","directives","concat","extensionASTNodes","extensions","Object","assign","create","config","toConfig","enumValueConfigMap","bind","setFieldProperties","SCALAR_TYPE","ENUM_TYPE","UNION_TYPE","OBJECT_TYPE","isTypeOf","INTERFACE_TYPE","COMPOSITE_FIELD","fieldConfig","newFieldConfig","OBJECT_FIELD","propertiesObj","propertyName","makeExecutableSchema","typeDefs","parseOptions","pruningOptions","schemaExtensions","commentDescriptions","mergedTypeDefs","keys","mergeSchemas","extractedTypeDefs","extractedResolvers","extractedSchemaExtensions","schemas","push"],"mappings":"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","sourcesContent":["import { isScalarType, getNamedType, defaultFieldResolver, isSchema, isSpecifiedScalarType, isEnumType, isUnionType, isObjectType, isInterfaceType, GraphQLEnumType, GraphQLScalarType, GraphQLUnionType, GraphQLObjectType, GraphQLInterfaceType, buildSchema, buildASTSchema } from 'graphql';\nimport { forEachField, mapSchema, MapperKind, forEachDefaultValue, serializeInputValue, healSchema, parseInputValue, pruneSchema, asArray, getResolversFromSchema } from '@graphql-tools/utils';\nimport { mergeTypeDefs, mergeResolvers, mergeExtensions, applyExtensions, extractExtensionsFromSchema } from '@graphql-tools/merge';\n\nfunction assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    forEachField(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar !== 'ignore' && !isScalarType(getNamedType(field.type))) {\n            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n    if (!field.resolve) {\n        const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n        if (behavior === 'error') {\n            throw new Error(message);\n        }\n        if (behavior === 'warn') {\n            // eslint-disable-next-line no-console\n            console.warn(message);\n        }\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n\nfunction chainResolvers(resolvers) {\n    return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n        if (curResolver != null) {\n            return curResolver(prev, args, ctx, info);\n        }\n        return defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n\n// If we have any union or interface types throw if no there is no resolveType resolver\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    mapSchema(schema, {\n        [MapperKind.ABSTRACT_TYPE]: type => {\n            if (!type.resolveType) {\n                const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` +\n                    '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n                if (requireResolversForResolveType === 'error') {\n                    throw new Error(message);\n                }\n                if (requireResolversForResolveType === 'warn') {\n                    // eslint-disable-next-line no-console\n                    console.warn(message);\n                }\n            }\n            return undefined;\n        },\n    });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n    const extendedResolvers = {};\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if ('getInterfaces' in type) {\n            extendedResolvers[typeName] = {};\n            for (const iFace of type.getInterfaces()) {\n                if (resolvers[iFace.name]) {\n                    for (const fieldName in resolvers[iFace.name]) {\n                        if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n                        }\n                    }\n                }\n            }\n            const typeResolvers = resolvers[typeName];\n            extendedResolvers[typeName] = {\n                ...extendedResolvers[typeName],\n                ...typeResolvers,\n            };\n        }\n        else {\n            const typeResolvers = resolvers[typeName];\n            if (typeResolvers != null) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    }\n    return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n    const options = isSchema(schemaOrOptions)\n        ? {\n            schema: schemaOrOptions,\n            resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},\n            resolverValidationOptions: legacyInputValidationOptions,\n        }\n        : schemaOrOptions;\n    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, } = options;\n    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    for (const typeName in resolvers) {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (resolverType !== 'object') {\n            throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n        }\n        const type = schema.getType(typeName);\n        if (type == null) {\n            if (requireResolversToMatchSchema === 'ignore') {\n                break;\n            }\n            throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n        }\n        else if (isSpecifiedScalarType(type)) {\n            // allow -- without recommending -- overriding of specified scalar types\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (isEnumType(type)) {\n            const values = type.getValues();\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    !values.some(value => value.name === fieldName) &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n                }\n            }\n        }\n        else if (isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n                }\n            }\n        }\n        else if (isObjectType(type) || isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__')) {\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field == null) {\n                        // Field present in resolver but not in schema\n                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n                        }\n                    }\n                    else {\n                        // Field present in both the resolver and schema\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n        checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    }\n    return schema;\n}\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n    const typeMap = schema.getTypeMap();\n    for (const typeName in resolvers) {\n        const type = schema.getType(typeName);\n        const resolverValue = resolvers[typeName];\n        if (isScalarType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && type.astNode != null) {\n                    type.astNode = {\n                        ...type.astNode,\n                        description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.astNode.description,\n                        directives: ((_d = type.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                    type.extensionASTNodes = type.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (isEnumType(type)) {\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    config[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && config.astNode != null) {\n                    config.astNode = {\n                        ...config.astNode,\n                        description: (_m = (_l = (_k = resolverValue) === null || _k === void 0 ? void 0 : _k.astNode) === null || _l === void 0 ? void 0 : _l.description) !== null && _m !== void 0 ? _m : config.astNode.description,\n                        directives: ((_o = config.astNode.directives) !== null && _o !== void 0 ? _o : []).concat((_r = (_q = (_p = resolverValue) === null || _p === void 0 ? void 0 : _p.astNode) === null || _q === void 0 ? void 0 : _q.directives) !== null && _r !== void 0 ? _r : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                    config.extensionASTNodes = config.extensionASTNodes.concat((_t = (_s = resolverValue) === null || _s === void 0 ? void 0 : _s.extensionASTNodes) !== null && _t !== void 0 ? _t : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else if (enumValueConfigMap[fieldName]) {\n                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                }\n            }\n            typeMap[typeName] = new GraphQLEnumType(config);\n        }\n        else if (isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (isObjectType(type) || isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    // this is for isTypeOf and resolveType and all the other stuff.\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                    break;\n                }\n                const fields = type.getFields();\n                const field = fields[fieldName];\n                if (field != null) {\n                    const fieldResolve = resolverValue[fieldName];\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        field.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(field, fieldResolve);\n                    }\n                }\n            }\n        }\n    }\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    forEachDefaultValue(schema, serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    healSchema(schema);\n    // reparse all default values with new parsing functions.\n    forEachDefaultValue(schema, parseInputValue);\n    if (defaultFieldResolver != null) {\n        forEachField(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = mapSchema(schema, {\n        [MapperKind.SCALAR_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!isSpecifiedScalarType(type) && resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                }\n                return new GraphQLScalarType(config);\n            }\n        },\n        [MapperKind.ENUM_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                }\n                return new GraphQLEnumType(config);\n            }\n        },\n        [MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new GraphQLUnionType(config);\n            }\n        },\n        [MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__isTypeOf']) {\n                    config.isTypeOf = resolverValue['__isTypeOf'];\n                }\n                return new GraphQLObjectType(config);\n            }\n        },\n        [MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new GraphQLInterfaceType(config);\n            }\n        },\n        [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = mapSchema(schema, {\n            [MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    for (const propertyName in propertiesObj) {\n        field[propertyName] = propertiesObj[propertyName];\n    }\n}\n\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions, }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    let schema;\n    if (isSchema(typeDefs)) {\n        schema = typeDefs;\n    }\n    else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n        const mergedTypeDefs = mergeTypeDefs(typeDefs, {\n            ...parseOptions,\n            commentDescriptions: true,\n        });\n        schema = buildSchema(mergedTypeDefs, parseOptions);\n    }\n    else {\n        const mergedTypeDefs = mergeTypeDefs(typeDefs, parseOptions);\n        schema = buildASTSchema(mergedTypeDefs, parseOptions);\n    }\n    if (pruningOptions) {\n        schema = pruneSchema(schema);\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    schema = addResolversToSchema({\n        schema,\n        resolvers: mergeResolvers(resolvers),\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n    });\n    if (Object.keys(resolverValidationOptions).length > 0) {\n        assertResolversPresent(schema, resolverValidationOptions);\n    }\n    if (schemaExtensions) {\n        schemaExtensions = mergeExtensions(asArray(schemaExtensions));\n        applyExtensions(schema, schemaExtensions);\n    }\n    return schema;\n}\n\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nfunction mergeSchemas(config) {\n    const extractedTypeDefs = asArray(config.typeDefs || []);\n    const extractedResolvers = asArray(config.resolvers || []);\n    const extractedSchemaExtensions = asArray(config.schemaExtensions || []);\n    const schemas = config.schemas || [];\n    for (const schema of schemas) {\n        extractedTypeDefs.push(schema);\n        extractedResolvers.push(getResolversFromSchema(schema));\n        extractedSchemaExtensions.push(extractExtensionsFromSchema(schema));\n    }\n    return makeExecutableSchema({\n        parseOptions: config,\n        ...config,\n        typeDefs: extractedTypeDefs,\n        resolvers: extractedResolvers,\n        schemaExtensions: extractedSchemaExtensions,\n    });\n}\n\nexport { addResolversToSchema, assertResolversPresent, chainResolvers, checkForResolveTypeResolver, extendResolversFromInterfaces, makeExecutableSchema, mergeSchemas };\n"]},"metadata":{},"sourceType":"module"}