{"ast":null,"code":"'use strict';\n\nconst {\n  finished\n} = require('stream');\n\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass StreamHandler extends AsyncResource {\n  constructor(opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo\n    } = opts;\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory');\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n\n      super('UNDICI_STREAM');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n\n      throw err;\n    }\n\n    this.opaque = opaque || null;\n    this.factory = factory;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.context = null;\n    this.trailers = null;\n    this.body = body;\n    this.onInfo = onInfo || null;\n\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, headers, resume) {\n    const {\n      factory,\n      opaque,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({\n          statusCode,\n          headers: util.parseHeaders(headers)\n        });\n      }\n\n      return;\n    }\n\n    this.factory = null;\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      opaque,\n      context\n    });\n\n    if (!res || typeof res.write !== 'function' || typeof res.end !== 'function' || typeof res.on !== 'function') {\n      throw new InvalidReturnValueError('expected Writable');\n    }\n\n    res.on('drain', resume); // TODO: Avoid finished. It registers an unecessary amount of listeners.\n\n    finished(res, {\n      readable: false\n    }, err => {\n      const {\n        callback,\n        res,\n        opaque,\n        trailers,\n        abort\n      } = this;\n      this.res = null;\n\n      if (err || !res.readable) {\n        util.destroy(res, err);\n      }\n\n      this.callback = null;\n      this.runInAsyncScope(callback, null, err || null, {\n        opaque,\n        trailers\n      });\n\n      if (err) {\n        abort();\n      }\n    });\n    this.res = res;\n    const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n    return needDrain !== true;\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.write(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    this.trailers = util.parseHeaders(trailers);\n    res.end();\n  }\n\n  onError(err) {\n    const {\n      res,\n      callback,\n      opaque,\n      body\n    } = this;\n    removeSignal(this);\n    this.factory = null;\n\n    if (res) {\n      this.res = null;\n      util.destroy(res, err);\n    } else if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n\n}\n\nfunction stream(opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = stream;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/api/api-stream.js"],"names":["finished","require","InvalidArgumentError","InvalidReturnValueError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","StreamHandler","constructor","opts","factory","callback","signal","method","opaque","body","onInfo","on","addEventListener","err","isStream","destroy","nop","res","abort","context","trailers","onError","onConnect","onHeaders","statusCode","headers","resume","parseHeaders","runInAsyncScope","write","end","readable","needDrain","writableNeedDrain","undefined","_writableState","onData","chunk","onComplete","queueMicrotask","stream","Promise","resolve","reject","call","data","dispatch","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { finished } = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { factory, opaque, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    this.factory = null\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    res.on('drain', resume)\n    // TODO: Avoid finished. It registers an unecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState && res._writableState.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res.write(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n"]},"metadata":{},"sourceType":"script"}