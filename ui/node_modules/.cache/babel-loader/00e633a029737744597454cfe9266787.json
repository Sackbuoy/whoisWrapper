{"ast":null,"code":"'use strict';\n\nconst {\n  redirectStatus\n} = require('./constants');\n\nconst {\n  performance\n} = require('perf_hooks');\n\nconst {\n  Blob\n} = require('buffer');\n\nconst nodeUtil = require('util');\n\nlet ReadableStream; // https://fetch.spec.whatwg.org/#block-bad-port\n\nconst badPorts = ['1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79', '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137', '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532', '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723', '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697', '10080'];\n\nfunction responseURL(response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList;\n  const length = urlList.length;\n  return length === 0 ? null : urlList[length - 1].toString();\n} // https://fetch.spec.whatwg.org/#concept-response-location-url\n\n\nfunction responseLocationURL(response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null;\n  } // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n\n\n  let location = response.headersList.get('location'); // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n\n  location = location ? new URL(location, responseURL(response)) : null; // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n\n  if (location && !location.hash) {\n    location.hash = requestFragment;\n  } // 5. Return location.\n\n\n  return location;\n}\n\nfunction requestCurrentURL(request) {\n  return request.urlList[request.urlList.length - 1];\n}\n\nfunction requestBadPort(request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request); // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n\n  if (/^http?s/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked';\n  } // 3. Return allowed.\n\n\n  return 'allowed';\n} // based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\n\n\nfunction isBlobLike(object) {\n  return object instanceof Blob || object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n} // Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\n\n\nfunction isValidReasonPhrase(statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i);\n\n    if (!(c === 0x09 || // HTAB\n    c >= 0x20 && c <= 0x7e || // SP / VCHAR\n    c >= 0x80 && c <= 0xff // obs-text\n    )) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isTokenChar(c) {\n  return !(c >= 0x7f || c <= 0x20 || c === '(' || c === ')' || c === '<' || c === '>' || c === '@' || c === ',' || c === ';' || c === ':' || c === '\\\\' || c === '\"' || c === '/' || c === '[' || c === ']' || c === '?' || c === '=' || c === '{' || c === '}');\n} // See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\n\n\nfunction isValidHTTPToken(characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false;\n  }\n\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i);\n\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ReadableStreamFrom(iterable) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  if (ReadableStream.from) {\n    // https://github.com/whatwg/streams/pull/1083\n    return ReadableStream.from(iterable);\n  }\n\n  let iterator;\n  return new ReadableStream({\n    async start() {\n      iterator = iterable[Symbol.asyncIterator]();\n    },\n\n    async pull(controller) {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        queueMicrotask(() => {\n          controller.close();\n        });\n      } else {\n        const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n        controller.enqueue(new Uint8Array(buf));\n      }\n\n      return controller.desiredSize > 0;\n    },\n\n    async cancel(reason) {\n      await iterator.return();\n    }\n\n  }, 0);\n} // https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\n\n\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = ''; // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n\n  if (policy !== '') {\n    request.referrerPolicy = policy;\n  }\n} // https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\n\n\nfunction crossOriginResourcePolicyCheck() {\n  // TODO\n  return 'allowed';\n} // https://fetch.spec.whatwg.org/#concept-cors-check\n\n\nfunction corsCheck() {\n  // TODO\n  return 'success';\n} // https://fetch.spec.whatwg.org/#concept-tao-check\n\n\nfunction TAOCheck() {\n  // TODO\n  return 'success';\n}\n\nfunction appendFetchMetadata(httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null; //  3. Set header’s value to r’s mode.\n\n  header = httpRequest.mode; //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n\n  httpRequest.headersList.append('sec-fetch-mode', header); //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n} // https://fetch.spec.whatwg.org/#append-a-request-origin-header\n\n\nfunction appendRequestOriginHeader(request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin; // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin);\n    }\n  } // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null;\n        break;\n\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n\n        break;\n\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (request.origin !== requestCurrentURL(request).origin) {\n          serializedOrigin = null;\n        }\n\n        break;\n\n      default: // Do nothing.\n\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin);\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now();\n}\n\nfunction makeTimingInfo(init) {\n  return {\n    startTime: 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null,\n    ...init\n  };\n} // https://html.spec.whatwg.org/multipage/origin.html#policy-container\n\n\nfunction makePolicyContainer() {\n  // TODO\n  return {};\n} // https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\n\n\nfunction clonePolicyContainer() {\n  // TODO\n  return {};\n} // https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\n\n\nfunction determineRequestsReferrer(request) {\n  // TODO\n  return 'no-referrer';\n}\n\nfunction matchRequestIntegrity(request, bytes) {\n  return false;\n} // https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\n\n\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {// TODO\n}\n\nclass ServiceWorkerGlobalScope {} // dummy\n\n\nclass Window {} // dummy\n\n\nclass EnvironmentSettingsObject {} // dummy\n\n\nmodule.exports = {\n  ServiceWorkerGlobalScope,\n  Window,\n  EnvironmentSettingsObject,\n  toUSVString: nodeUtil.toUSVString || (val => `${val}`),\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  matchRequestIntegrity,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  ReadableStreamFrom,\n  makeTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isValidReasonPhrase\n};","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/fetch/util.js"],"names":["redirectStatus","require","performance","Blob","nodeUtil","ReadableStream","badPorts","responseURL","response","urlList","length","toString","responseLocationURL","requestFragment","includes","status","location","headersList","get","URL","hash","requestCurrentURL","request","requestBadPort","url","test","protocol","port","isBlobLike","object","constructor","stream","arrayBuffer","Symbol","toStringTag","isValidReasonPhrase","statusText","i","c","charCodeAt","isTokenChar","isValidHTTPToken","characters","ReadableStreamFrom","iterable","from","iterator","start","asyncIterator","pull","controller","done","value","next","queueMicrotask","close","buf","Buffer","isBuffer","enqueue","Uint8Array","desiredSize","cancel","reason","return","setRequestReferrerPolicyOnRedirect","actualResponse","policy","referrerPolicy","crossOriginResourcePolicyCheck","corsCheck","TAOCheck","appendFetchMetadata","httpRequest","header","mode","append","appendRequestOriginHeader","serializedOrigin","origin","responseTainting","method","coarsenedSharedCurrentTime","crossOriginIsolatedCapability","now","makeTimingInfo","init","startTime","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","makePolicyContainer","clonePolicyContainer","determineRequestsReferrer","matchRequestIntegrity","bytes","tryUpgradeRequestToAPotentiallyTrustworthyURL","ServiceWorkerGlobalScope","Window","EnvironmentSettingsObject","module","exports","toUSVString","val"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { redirectStatus } = require('./constants')\nconst { performance } = require('perf_hooks')\nconst { Blob } = require('buffer')\nconst nodeUtil = require('util')\n\nlet ReadableStream\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',\n  '10080'\n]\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^http?s/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike (object) {\n  return object instanceof Blob || (\n    object &&\n    typeof object === 'object' &&\n    typeof object.constructor === 'function' &&\n    (typeof object.stream === 'function' ||\n      typeof object.arrayBuffer === 'function') &&\n    /^(Blob|File)$/.test(object[Symbol.toStringTag])\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction ReadableStreamFrom (iterable) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  if (ReadableStream.from) {\n    // https://github.com/whatwg/streams/pull/1083\n    return ReadableStream.from(iterable)\n  }\n\n  let iterator\n  return new ReadableStream(\n    {\n      async start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { done, value } = await iterator.next()\n        if (done) {\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n          controller.enqueue(new Uint8Array(buf))\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    },\n    0\n  )\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = ''\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.append('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (request.origin !== requestCurrentURL(request).origin) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\nfunction makeTimingInfo (init) {\n  return {\n    startTime: 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null,\n    ...init\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // TODO\n  return 'no-referrer'\n}\n\nfunction matchRequestIntegrity (request, bytes) {\n  return false\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\nclass ServiceWorkerGlobalScope {} // dummy\nclass Window {} // dummy\nclass EnvironmentSettingsObject {} // dummy\n\nmodule.exports = {\n  ServiceWorkerGlobalScope,\n  Window,\n  EnvironmentSettingsObject,\n  toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  matchRequestIntegrity,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  ReadableStreamFrom,\n  makeTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isValidReasonPhrase\n}\n"]},"metadata":{},"sourceType":"script"}