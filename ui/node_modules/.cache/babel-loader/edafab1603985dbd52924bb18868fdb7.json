{"ast":null,"code":"'use strict';\n\nconst Readable = require('./readable');\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass RequestHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo\n    } = opts;\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n\n      super('UNDICI_REQUEST');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n\n      throw err;\n    }\n\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.body = body;\n    this.trailers = {};\n    this.context = null;\n    this.onInfo = onInfo || null;\n\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, headers, resume) {\n    const {\n      callback,\n      opaque,\n      abort,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({\n          statusCode,\n          headers: util.parseHeaders(headers)\n        });\n      }\n\n      return;\n    }\n\n    const parsedHeaders = util.parseHeaders(headers);\n    const body = new Readable(resume, abort, parsedHeaders['content-type']);\n    this.callback = null;\n    this.res = body;\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: parsedHeaders,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    });\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.push(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    util.parseHeaders(trailers, this.trailers);\n    res.push(null);\n  }\n\n  onError(err) {\n    const {\n      res,\n      callback,\n      body,\n      opaque\n    } = this;\n    removeSignal(this);\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n\n    if (res) {\n      this.res = null; // Ensure all queued handlers are invoked before destroying res.\n\n      queueMicrotask(() => {\n        util.destroy(res, err);\n      });\n    }\n\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n\n}\n\nfunction request(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = request;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/api/api-request.js"],"names":["Readable","require","InvalidArgumentError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","RequestHandler","constructor","opts","callback","signal","method","opaque","body","onInfo","on","addEventListener","err","isStream","destroy","nop","res","abort","trailers","context","onError","onConnect","onHeaders","statusCode","headers","resume","parseHeaders","parsedHeaders","runInAsyncScope","onData","chunk","push","onComplete","queueMicrotask","request","undefined","Promise","resolve","reject","call","data","dispatch","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAM;AACJC,EAAAA,oBADI;AAEJC,EAAAA;AAFI,IAGFF,OAAO,CAAC,gBAAD,CAHX;;AAIA,MAAMG,IAAI,GAAGH,OAAO,CAAC,cAAD,CAApB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAoBJ,OAAO,CAAC,aAAD,CAAjC;;AACA,MAAM;AAAEK,EAAAA,SAAF;AAAaC,EAAAA;AAAb,IAA8BN,OAAO,CAAC,gBAAD,CAA3C;;AAEA,MAAMO,cAAN,SAA6BH,aAA7B,CAA2C;AACzCI,EAAAA,WAAW,CAAEC,IAAF,EAAQC,QAAR,EAAkB;AAC3B,QAAI,CAACD,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EAAuC;AACrC,YAAM,IAAIR,oBAAJ,CAAyB,cAAzB,CAAN;AACD;;AAED,UAAM;AAAEU,MAAAA,MAAF;AAAUC,MAAAA,MAAV;AAAkBC,MAAAA,MAAlB;AAA0BC,MAAAA,IAA1B;AAAgCC,MAAAA;AAAhC,QAA2CN,IAAjD;;AAEA,QAAI;AACF,UAAI,OAAOC,QAAP,KAAoB,UAAxB,EAAoC;AAClC,cAAM,IAAIT,oBAAJ,CAAyB,kBAAzB,CAAN;AACD;;AAED,UAAIU,MAAM,IAAI,OAAOA,MAAM,CAACK,EAAd,KAAqB,UAA/B,IAA6C,OAAOL,MAAM,CAACM,gBAAd,KAAmC,UAApF,EAAgG;AAC9F,cAAM,IAAIhB,oBAAJ,CAAyB,+CAAzB,CAAN;AACD;;AAED,UAAIW,MAAM,KAAK,SAAf,EAA0B;AACxB,cAAM,IAAIX,oBAAJ,CAAyB,gBAAzB,CAAN;AACD;;AAED,UAAIc,MAAM,IAAI,OAAOA,MAAP,KAAkB,UAAhC,EAA4C;AAC1C,cAAM,IAAId,oBAAJ,CAAyB,yBAAzB,CAAN;AACD;;AAED,YAAM,gBAAN;AACD,KAlBD,CAkBE,OAAOiB,GAAP,EAAY;AACZ,UAAIf,IAAI,CAACgB,QAAL,CAAcL,IAAd,CAAJ,EAAyB;AACvBX,QAAAA,IAAI,CAACiB,OAAL,CAAaN,IAAI,CAACE,EAAL,CAAQ,OAAR,EAAiBb,IAAI,CAACkB,GAAtB,CAAb,EAAyCH,GAAzC;AACD;;AACD,YAAMA,GAAN;AACD;;AAED,SAAKL,MAAL,GAAcA,MAAM,IAAI,IAAxB;AACA,SAAKH,QAAL,GAAgBA,QAAhB;AACA,SAAKY,GAAL,GAAW,IAAX;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKT,IAAL,GAAYA,IAAZ;AACA,SAAKU,QAAL,GAAgB,EAAhB;AACA,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKV,MAAL,GAAcA,MAAM,IAAI,IAAxB;;AAEA,QAAIZ,IAAI,CAACgB,QAAL,CAAcL,IAAd,CAAJ,EAAyB;AACvBA,MAAAA,IAAI,CAACE,EAAL,CAAQ,OAAR,EAAkBE,GAAD,IAAS;AACxB,aAAKQ,OAAL,CAAaR,GAAb;AACD,OAFD;AAGD;;AAEDb,IAAAA,SAAS,CAAC,IAAD,EAAOM,MAAP,CAAT;AACD;;AAEDgB,EAAAA,SAAS,CAAEJ,KAAF,EAASE,OAAT,EAAkB;AACzB,QAAI,CAAC,KAAKf,QAAV,EAAoB;AAClB,YAAM,IAAIR,mBAAJ,EAAN;AACD;;AAED,SAAKqB,KAAL,GAAaA,KAAb;AACA,SAAKE,OAAL,GAAeA,OAAf;AACD;;AAEDG,EAAAA,SAAS,CAAEC,UAAF,EAAcC,OAAd,EAAuBC,MAAvB,EAA+B;AACtC,UAAM;AAAErB,MAAAA,QAAF;AAAYG,MAAAA,MAAZ;AAAoBU,MAAAA,KAApB;AAA2BE,MAAAA;AAA3B,QAAuC,IAA7C;;AAEA,QAAII,UAAU,GAAG,GAAjB,EAAsB;AACpB,UAAI,KAAKd,MAAT,EAAiB;AACf,aAAKA,MAAL,CAAY;AAAEc,UAAAA,UAAF;AAAcC,UAAAA,OAAO,EAAE3B,IAAI,CAAC6B,YAAL,CAAkBF,OAAlB;AAAvB,SAAZ;AACD;;AACD;AACD;;AAED,UAAMG,aAAa,GAAG9B,IAAI,CAAC6B,YAAL,CAAkBF,OAAlB,CAAtB;AACA,UAAMhB,IAAI,GAAG,IAAIf,QAAJ,CAAagC,MAAb,EAAqBR,KAArB,EAA4BU,aAAa,CAAC,cAAD,CAAzC,CAAb;AAEA,SAAKvB,QAAL,GAAgB,IAAhB;AACA,SAAKY,GAAL,GAAWR,IAAX;AAEA,SAAKoB,eAAL,CAAqBxB,QAArB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C;AACzCmB,MAAAA,UADyC;AAEzCC,MAAAA,OAAO,EAAEG,aAFgC;AAGzCT,MAAAA,QAAQ,EAAE,KAAKA,QAH0B;AAIzCX,MAAAA,MAJyC;AAKzCC,MAAAA,IALyC;AAMzCW,MAAAA;AANyC,KAA3C;AAQD;;AAEDU,EAAAA,MAAM,CAAEC,KAAF,EAAS;AACb,UAAM;AAAEd,MAAAA;AAAF,QAAU,IAAhB;AACA,WAAOA,GAAG,CAACe,IAAJ,CAASD,KAAT,CAAP;AACD;;AAEDE,EAAAA,UAAU,CAAEd,QAAF,EAAY;AACpB,UAAM;AAAEF,MAAAA;AAAF,QAAU,IAAhB;AAEAhB,IAAAA,YAAY,CAAC,IAAD,CAAZ;AAEAH,IAAAA,IAAI,CAAC6B,YAAL,CAAkBR,QAAlB,EAA4B,KAAKA,QAAjC;AAEAF,IAAAA,GAAG,CAACe,IAAJ,CAAS,IAAT;AACD;;AAEDX,EAAAA,OAAO,CAAER,GAAF,EAAO;AACZ,UAAM;AAAEI,MAAAA,GAAF;AAAOZ,MAAAA,QAAP;AAAiBI,MAAAA,IAAjB;AAAuBD,MAAAA;AAAvB,QAAkC,IAAxC;AAEAP,IAAAA,YAAY,CAAC,IAAD,CAAZ;;AAEA,QAAII,QAAJ,EAAc;AACZ;AACA,WAAKA,QAAL,GAAgB,IAAhB;AACA6B,MAAAA,cAAc,CAAC,MAAM;AACnB,aAAKL,eAAL,CAAqBxB,QAArB,EAA+B,IAA/B,EAAqCQ,GAArC,EAA0C;AAAEL,UAAAA;AAAF,SAA1C;AACD,OAFa,CAAd;AAGD;;AAED,QAAIS,GAAJ,EAAS;AACP,WAAKA,GAAL,GAAW,IAAX,CADO,CAEP;;AACAiB,MAAAA,cAAc,CAAC,MAAM;AACnBpC,QAAAA,IAAI,CAACiB,OAAL,CAAaE,GAAb,EAAkBJ,GAAlB;AACD,OAFa,CAAd;AAGD;;AAED,QAAIJ,IAAJ,EAAU;AACR,WAAKA,IAAL,GAAY,IAAZ;AACAX,MAAAA,IAAI,CAACiB,OAAL,CAAaN,IAAb,EAAmBI,GAAnB;AACD;AACF;;AA9HwC;;AAiI3C,SAASsB,OAAT,CAAkB/B,IAAlB,EAAwBC,QAAxB,EAAkC;AAChC,MAAIA,QAAQ,KAAK+B,SAAjB,EAA4B;AAC1B,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCJ,MAAAA,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBpC,IAAnB,EAAyB,CAACS,GAAD,EAAM4B,IAAN,KAAe;AACtC,eAAO5B,GAAG,GAAG0B,MAAM,CAAC1B,GAAD,CAAT,GAAiByB,OAAO,CAACG,IAAD,CAAlC;AACD,OAFD;AAGD,KAJM,CAAP;AAKD;;AAED,MAAI;AACF,SAAKC,QAAL,CAActC,IAAd,EAAoB,IAAIF,cAAJ,CAAmBE,IAAnB,EAAyBC,QAAzB,CAApB;AACD,GAFD,CAEE,OAAOQ,GAAP,EAAY;AACZ,QAAI,OAAOR,QAAP,KAAoB,UAAxB,EAAoC;AAClC,YAAMQ,GAAN;AACD;;AACD,UAAML,MAAM,GAAGJ,IAAI,IAAIA,IAAI,CAACI,MAA5B;AACA0B,IAAAA,cAAc,CAAC,MAAM7B,QAAQ,CAACQ,GAAD,EAAM;AAAEL,MAAAA;AAAF,KAAN,CAAf,CAAd;AACD;AACF;;AAEDmC,MAAM,CAACC,OAAP,GAAiBT,OAAjB","sourcesContent":["'use strict'\n\nconst Readable = require('./readable')\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { callback, opaque, abort, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    const parsedHeaders = util.parseHeaders(headers)\n    const body = new Readable(resume, abort, parsedHeaders['content-type'])\n\n    this.callback = null\n    this.res = body\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: parsedHeaders,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    })\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\n"]},"metadata":{},"sourceType":"script"}