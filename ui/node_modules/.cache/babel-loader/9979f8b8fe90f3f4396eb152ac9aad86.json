{"ast":null,"code":"/* eslint-disable */\n'use strict'; // Extracted from node/lib/internal/fixed_queue.js\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\n\nconst kSize = 2048;\nconst kMask = kSize - 1; // The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return (this.top + 1 & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = this.top + 1 & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined) return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = this.bottom + 1 & kMask;\n    return nextItem;\n  }\n\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n\n    return next;\n  }\n\n};","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/node/fixed-queue.js"],"names":["kSize","kMask","FixedCircularBuffer","constructor","bottom","top","list","Array","next","isEmpty","isFull","push","data","shift","nextItem","undefined","module","exports","FixedQueue","head","tail"],"mappings":"AAAA;AAEA,a,CAEA;AAEA;;AACA,MAAMA,KAAK,GAAG,IAAd;AACA,MAAMC,KAAK,GAAGD,KAAK,GAAG,CAAtB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,mBAAN,CAA0B;AACxBC,EAAAA,WAAW,GAAG;AACZ,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,GAAL,GAAW,CAAX;AACA,SAAKC,IAAL,GAAY,IAAIC,KAAJ,CAAUP,KAAV,CAAZ;AACA,SAAKQ,IAAL,GAAY,IAAZ;AACD;;AAEDC,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKJ,GAAL,KAAa,KAAKD,MAAzB;AACD;;AAEDM,EAAAA,MAAM,GAAG;AACP,WAAO,CAAE,KAAKL,GAAL,GAAW,CAAZ,GAAiBJ,KAAlB,MAA6B,KAAKG,MAAzC;AACD;;AAEDO,EAAAA,IAAI,CAACC,IAAD,EAAO;AACT,SAAKN,IAAL,CAAU,KAAKD,GAAf,IAAsBO,IAAtB;AACA,SAAKP,GAAL,GAAY,KAAKA,GAAL,GAAW,CAAZ,GAAiBJ,KAA5B;AACD;;AAEDY,EAAAA,KAAK,GAAG;AACN,UAAMC,QAAQ,GAAG,KAAKR,IAAL,CAAU,KAAKF,MAAf,CAAjB;AACA,QAAIU,QAAQ,KAAKC,SAAjB,EACE,OAAO,IAAP;AACF,SAAKT,IAAL,CAAU,KAAKF,MAAf,IAAyBW,SAAzB;AACA,SAAKX,MAAL,GAAe,KAAKA,MAAL,GAAc,CAAf,GAAoBH,KAAlC;AACA,WAAOa,QAAP;AACD;;AA5BuB;;AA+B1BE,MAAM,CAACC,OAAP,GAAiB,MAAMC,UAAN,CAAiB;AAChCf,EAAAA,WAAW,GAAG;AACZ,SAAKgB,IAAL,GAAY,KAAKC,IAAL,GAAY,IAAIlB,mBAAJ,EAAxB;AACD;;AAEDO,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKU,IAAL,CAAUV,OAAV,EAAP;AACD;;AAEDE,EAAAA,IAAI,CAACC,IAAD,EAAO;AACT,QAAI,KAAKO,IAAL,CAAUT,MAAV,EAAJ,EAAwB;AACtB;AACA;AACA,WAAKS,IAAL,GAAY,KAAKA,IAAL,CAAUX,IAAV,GAAiB,IAAIN,mBAAJ,EAA7B;AACD;;AACD,SAAKiB,IAAL,CAAUR,IAAV,CAAeC,IAAf;AACD;;AAEDC,EAAAA,KAAK,GAAG;AACN,UAAMO,IAAI,GAAG,KAAKA,IAAlB;AACA,UAAMZ,IAAI,GAAGY,IAAI,CAACP,KAAL,EAAb;;AACA,QAAIO,IAAI,CAACX,OAAL,MAAkBW,IAAI,CAACZ,IAAL,KAAc,IAApC,EAA0C;AACxC;AACA,WAAKY,IAAL,GAAYA,IAAI,CAACZ,IAAjB;AACD;;AACD,WAAOA,IAAP;AACD;;AA1B+B,CAAlC","sourcesContent":["/* eslint-disable */\n\n'use strict'\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}