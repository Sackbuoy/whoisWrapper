{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst utils = require('@graphql-tools/utils');\n\nconst graphql = require('graphql');\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\n\n\nfunction mergeResolvers(resolversDefinitions, options) {\n  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {\n    return {};\n  }\n\n  if (!Array.isArray(resolversDefinitions)) {\n    return resolversDefinitions;\n  }\n\n  if (resolversDefinitions.length === 1) {\n    return resolversDefinitions[0] || {};\n  }\n\n  const resolvers = new Array();\n\n  for (let resolversDefinition of resolversDefinitions) {\n    if (Array.isArray(resolversDefinition)) {\n      resolversDefinition = mergeResolvers(resolversDefinition);\n    }\n\n    if (typeof resolversDefinition === 'object' && resolversDefinition) {\n      resolvers.push(resolversDefinition);\n    }\n  }\n\n  const result = utils.mergeDeep(resolvers, true);\n\n  if (options === null || options === void 0 ? void 0 : options.exclusions) {\n    for (const exclusion of options.exclusions) {\n      const [typeName, fieldName] = exclusion.split('.');\n\n      if (!fieldName || fieldName === '*') {\n        delete result[typeName];\n      } else if (result[typeName]) {\n        delete result[typeName][fieldName];\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n  const result = deduplicateArguments([...args2, ...args1].filter(utils.isSome));\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  return result;\n}\n\nfunction deduplicateArguments(args) {\n  return args.reduce((acc, current) => {\n    const dup = acc.find(arg => arg.name.value === current.name.value);\n\n    if (!dup) {\n      return acc.concat([current]);\n    }\n\n    return acc;\n  }, []);\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n  return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\n\nfunction nameAlreadyExists(name, namesArr) {\n  return namesArr.some(_ref => {\n    let {\n      value\n    } = _ref;\n    return value === name.value;\n  });\n}\n\nfunction mergeArguments$1(a1, a2) {\n  const result = [...a2];\n\n  for (const argument of a1) {\n    const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n\n    if (existingIndex > -1) {\n      const existingArg = result[existingIndex];\n\n      if (existingArg.value.kind === 'ListValue') {\n        const source = existingArg.value.values;\n        const target = argument.value.values; // merge values of two lists\n\n        existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n          const value = targetVal.value;\n          return !value || !source.some(sourceVal => sourceVal.value === value);\n        });\n      } else {\n        existingArg.value = argument.value;\n      }\n    } else {\n      result.push(argument);\n    }\n  }\n\n  return result;\n}\n\nfunction deduplicateDirectives(directives) {\n  return directives.map((directive, i, all) => {\n    const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n\n    if (firstAt !== i) {\n      const dup = all[firstAt];\n      directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n      return null;\n    }\n\n    return directive;\n  }).filter(utils.isSome);\n}\n\nfunction mergeDirectives() {\n  let d1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let d2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let config = arguments.length > 2 ? arguments[2] : undefined;\n  const reverseOrder = config && config.reverseDirectives;\n  const asNext = reverseOrder ? d1 : d2;\n  const asFirst = reverseOrder ? d2 : d1;\n  const result = deduplicateDirectives([...asNext]);\n\n  for (const directive of asFirst) {\n    if (directiveAlreadyExists(result, directive)) {\n      const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n      const existingDirective = result[existingDirectiveIndex];\n      result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n    } else {\n      result.push(directive);\n    }\n  }\n\n  return result;\n}\n\nfunction validateInputs(node, existingNode) {\n  const printedNode = graphql.print({ ...node,\n    description: undefined\n  });\n  const printedExistingNode = graphql.print({ ...existingNode,\n    description: undefined\n  }); // eslint-disable-next-line\n\n  const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n  const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n\n  if (!sameArguments) {\n    throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n  }\n}\n\nfunction mergeDirective(node, existingNode) {\n  if (existingNode) {\n    validateInputs(node, existingNode);\n    return { ...node,\n      locations: [...existingNode.locations, ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations))]\n    };\n  }\n\n  return node;\n}\n\nfunction deduplicateLists(source, target, filterFn) {\n  return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n  if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {\n    const reversed = [];\n\n    if (first) {\n      reversed.push(...first);\n    }\n\n    first = second;\n    second = reversed;\n  }\n\n  const enumValueMap = new Map();\n\n  if (first) {\n    for (const firstValue of first) {\n      enumValueMap.set(firstValue.name.value, firstValue);\n    }\n  }\n\n  if (second) {\n    for (const secondValue of second) {\n      const enumValue = secondValue.name.value;\n\n      if (enumValueMap.has(enumValue)) {\n        const firstValue = enumValueMap.get(enumValue);\n        firstValue.description = secondValue.description || firstValue.description;\n        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n      } else {\n        enumValueMap.set(enumValue, secondValue);\n      }\n    }\n  }\n\n  const result = [...enumValueMap.values()];\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n  if (e2) {\n    return {\n      name: e1.name,\n      description: e1['description'] || e2['description'],\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition' ? 'EnumTypeDefinition' : 'EnumTypeExtension',\n      loc: e1.loc,\n      directives: mergeDirectives(e1.directives, e2.directives, config),\n      values: mergeEnumValues(e1.values, e2.values, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...e1,\n    kind: graphql.Kind.ENUM_TYPE_DEFINITION\n  } : e1;\n}\n\nfunction isStringTypes(types) {\n  return typeof types === 'string';\n}\n\nfunction isSourceTypes(types) {\n  return types instanceof graphql.Source;\n}\n\nfunction extractType(type) {\n  let visitedType = type;\n\n  while (visitedType.kind === graphql.Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n    visitedType = visitedType.type;\n  }\n\n  return visitedType;\n}\n\nfunction isWrappingTypeNode(type) {\n  return type.kind !== graphql.Kind.NAMED_TYPE;\n}\n\nfunction isListTypeNode(type) {\n  return type.kind === graphql.Kind.LIST_TYPE;\n}\n\nfunction isNonNullTypeNode(type) {\n  return type.kind === graphql.Kind.NON_NULL_TYPE;\n}\n\nfunction printTypeNode(type) {\n  if (isListTypeNode(type)) {\n    return `[${printTypeNode(type.type)}]`;\n  }\n\n  if (isNonNullTypeNode(type)) {\n    return `${printTypeNode(type.type)}!`;\n  }\n\n  return type.name.value;\n}\n\n(function (CompareVal) {\n  CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n  CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n  CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(exports.CompareVal || (exports.CompareVal = {}));\n\nfunction defaultStringComparator(a, b) {\n  if (a == null && b == null) {\n    return exports.CompareVal.A_EQUALS_B;\n  }\n\n  if (a == null) {\n    return exports.CompareVal.A_SMALLER_THAN_B;\n  }\n\n  if (b == null) {\n    return exports.CompareVal.A_GREATER_THAN_B;\n  }\n\n  if (a < b) return exports.CompareVal.A_SMALLER_THAN_B;\n  if (a > b) return exports.CompareVal.A_GREATER_THAN_B;\n  return exports.CompareVal.A_EQUALS_B;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n  const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n\n  if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n    const t1 = extractType(result.type);\n    const t2 = extractType(otherField.type);\n\n    if (t1.name.value !== t2.name.value) {\n      throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n    }\n  }\n\n  return !!result;\n}\n\nfunction mergeFields(type, f1, f2, config) {\n  const result = [];\n\n  if (f2 != null) {\n    result.push(...f2);\n  }\n\n  if (f1 != null) {\n    for (const field of f1) {\n      if (fieldAlreadyExists(result, field, config)) {\n        const existing = result.find(f => f.name.value === field.name.value);\n\n        if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n          if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n            preventConflicts(type, existing, field, false);\n          } else {\n            preventConflicts(type, existing, field, true);\n          }\n\n          if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n            existing.type = field.type;\n          }\n        }\n\n        existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n        existing.directives = mergeDirectives(field.directives, existing.directives, config);\n        existing.description = field.description || existing.description;\n      } else {\n        result.push(field);\n      }\n    }\n  }\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  if (config && config.exclusions) {\n    const exclusions = config.exclusions;\n    return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n  }\n\n  return result;\n}\n\nfunction preventConflicts(type, a, b) {\n  let ignoreNullability = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const aType = printTypeNode(a.type);\n  const bType = printTypeNode(b.type);\n\n  if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n    throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n  }\n}\n\nfunction safeChangeForFieldType(oldType, newType) {\n  let ignoreNullability = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // both are named\n  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n    return oldType.toString() === newType.toString();\n  } // new is non-null\n\n\n  if (isNonNullTypeNode(newType)) {\n    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n    return safeChangeForFieldType(ofType, newType.type);\n  } // old is non-null\n\n\n  if (isNonNullTypeNode(oldType)) {\n    return safeChangeForFieldType(newType, oldType, ignoreNullability);\n  } // old is list\n\n\n  if (isListTypeNode(oldType)) {\n    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type']);\n  }\n\n  return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InputObjectTypeDefinition' || existingNode.kind === 'InputObjectTypeDefinition' ? 'InputObjectTypeDefinition' : 'InputObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InterfaceTypeDefinition' || existingNode.kind === 'InterfaceTypeDefinition' ? 'InterfaceTypeDefinition' : 'InterfaceTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.INTERFACE_TYPE_DEFINITION\n  } : node;\n}\n\nfunction alreadyExists(arr, other) {\n  return !!arr.find(i => i.name.value === other.name.value);\n}\n\nfunction mergeNamedTypeArray() {\n  let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ObjectTypeDefinition' || existingNode.kind === 'ObjectTypeDefinition' ? 'ObjectTypeDefinition' : 'ObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config),\n        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.OBJECT_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeScalar(node, existingNode, config) {\n  if (existingNode) {\n    return {\n      name: node.name,\n      description: node['description'] || existingNode['description'],\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ScalarTypeDefinition' || existingNode.kind === 'ScalarTypeDefinition' ? 'ScalarTypeDefinition' : 'ScalarTypeExtension',\n      loc: node.loc,\n      directives: mergeDirectives(node.directives, existingNode.directives, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.SCALAR_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeUnion(first, second, config) {\n  if (second) {\n    return {\n      name: first.name,\n      description: first['description'] || second['description'],\n      // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n      directives: mergeDirectives(first.directives, second.directives, config),\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition' ? graphql.Kind.UNION_TYPE_DEFINITION : graphql.Kind.UNION_TYPE_EXTENSION,\n      loc: first.loc,\n      types: mergeNamedTypeArray(first.types, second.types, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...first,\n    kind: graphql.Kind.UNION_TYPE_DEFINITION\n  } : first;\n}\n\nconst DEFAULT_OPERATION_TYPE_NAME_MAP = {\n  query: 'Query',\n  mutation: 'Mutation',\n  subscription: 'Subscription'\n};\n\nfunction mergeOperationTypes() {\n  let opNodeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let existingOpNodeList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const finalOpNodeList = [];\n\n  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n    const opNode = opNodeList.find(n => n.operation === opNodeType) || existingOpNodeList.find(n => n.operation === opNodeType);\n\n    if (opNode) {\n      finalOpNodeList.push(opNode);\n    }\n  }\n\n  return finalOpNodeList;\n}\n\nfunction mergeSchemaDefs(node, existingNode, config) {\n  if (existingNode) {\n    return {\n      kind: node.kind === graphql.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql.Kind.SCHEMA_DEFINITION ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,\n      description: node['description'] || existingNode['description'],\n      directives: mergeDirectives(node.directives, existingNode.directives, config),\n      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.SCHEMA_DEFINITION\n  } : node;\n}\n\nconst schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\n\nfunction isNamedDefinitionNode(definitionNode) {\n  return 'name' in definitionNode;\n}\n\nfunction mergeGraphQLNodes(nodes, config) {\n  var _a, _b, _c;\n\n  const mergedResultMap = {};\n\n  for (const nodeDefinition of nodes) {\n    if (isNamedDefinitionNode(nodeDefinition)) {\n      const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;\n\n      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        utils.collectComment(nodeDefinition);\n      }\n\n      if (name == null) {\n        continue;\n      }\n\n      if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {\n        delete mergedResultMap[name];\n      } else {\n        switch (nodeDefinition.kind) {\n          case graphql.Kind.OBJECT_TYPE_DEFINITION:\n          case graphql.Kind.OBJECT_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.ENUM_TYPE_DEFINITION:\n          case graphql.Kind.ENUM_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.UNION_TYPE_DEFINITION:\n          case graphql.Kind.UNION_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.SCALAR_TYPE_DEFINITION:\n          case graphql.Kind.SCALAR_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n          case graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.INTERFACE_TYPE_DEFINITION:\n          case graphql.Kind.INTERFACE_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.DIRECTIVE_DEFINITION:\n            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);\n            break;\n        }\n      }\n    } else if (nodeDefinition.kind === graphql.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql.Kind.SCHEMA_EXTENSION) {\n      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);\n    }\n  }\n\n  return mergedResultMap;\n}\n\nfunction mergeTypeDefs(typeSource, config) {\n  utils.resetComments();\n  const doc = {\n    kind: graphql.Kind.DOCUMENT,\n    definitions: mergeGraphQLTypes(typeSource, {\n      useSchemaDefinition: true,\n      forceSchemaDefinition: false,\n      throwOnConflict: false,\n      commentDescriptions: false,\n      ...config\n    })\n  };\n  let result;\n\n  if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n    result = utils.printWithComments(doc);\n  } else {\n    result = doc;\n  }\n\n  utils.resetComments();\n  return result;\n}\n\nfunction visitTypeSources(typeSource, options) {\n  let allNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let visitedTypeSources = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();\n\n  if (typeSource && !visitedTypeSources.has(typeSource)) {\n    visitedTypeSources.add(typeSource);\n\n    if (typeof typeSource === 'function') {\n      visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n    } else if (Array.isArray(typeSource)) {\n      for (const type of typeSource) {\n        visitTypeSources(type, options, allNodes, visitedTypeSources);\n      }\n    } else if (graphql.isSchema(typeSource)) {\n      const documentNode = utils.getDocumentNodeFromSchema(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {\n      const documentNode = graphql.parse(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if (typeof typeSource === 'object' && graphql.isDefinitionNode(typeSource)) {\n      allNodes.push(typeSource);\n    } else if (utils.isDocumentNode(typeSource)) {\n      visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n    } else {\n      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n    }\n  }\n\n  return allNodes;\n}\n\nfunction mergeGraphQLTypes(typeSource, config) {\n  var _a, _b, _c;\n\n  utils.resetComments();\n  const allNodes = visitTypeSources(typeSource, config);\n  const mergedNodes = mergeGraphQLNodes(allNodes, config);\n\n  if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n    // XXX: right now we don't handle multiple schema definitions\n    const schemaDef = mergedNodes[schemaDefSymbol] || {\n      kind: graphql.Kind.SCHEMA_DEFINITION,\n      operationTypes: []\n    };\n    const operationTypes = schemaDef.operationTypes;\n\n    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n      const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n\n      if (!opTypeDefNode) {\n        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n        const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n\n        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n          operationTypes.push({\n            kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n            type: {\n              kind: graphql.Kind.NAMED_TYPE,\n              name: existingPossibleRootType.name\n            },\n            operation: opTypeDefNodeType\n          });\n        }\n      }\n    }\n\n    if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n      mergedNodes[schemaDefSymbol] = schemaDef;\n    }\n  }\n\n  if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n    mergedNodes[schemaDefSymbol] = {\n      kind: graphql.Kind.SCHEMA_DEFINITION,\n      operationTypes: [{\n        kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n        operation: 'query',\n        type: {\n          kind: graphql.Kind.NAMED_TYPE,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: 'Query'\n          }\n        }\n      }]\n    };\n  }\n\n  const mergedNodeDefinitions = Object.values(mergedNodes);\n\n  if (config === null || config === void 0 ? void 0 : config.sort) {\n    const sortFn = typeof config.sort === 'function' ? config.sort : defaultStringComparator;\n    mergedNodeDefinitions.sort((a, b) => {\n      var _a, _b;\n\n      return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);\n    });\n  }\n\n  return mergedNodeDefinitions;\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n  hooks.onSchema(schema);\n  const typesMap = schema.getTypeMap();\n\n  for (const [, type] of Object.entries(typesMap)) {\n    const isPredefinedScalar = graphql.isScalarType(type) && graphql.isSpecifiedScalarType(type);\n    const isIntrospection = graphql.isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    }\n\n    if (graphql.isObjectType(type)) {\n      hooks.onObjectType(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onObjectField(type, field);\n        const args = field.args || [];\n\n        for (const arg of args) {\n          hooks.onObjectFieldArg(type, field, arg);\n        }\n      }\n    } else if (graphql.isInterfaceType(type)) {\n      hooks.onInterface(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onInterfaceField(type, field);\n        const args = field.args || [];\n\n        for (const arg of args) {\n          hooks.onInterfaceFieldArg(type, field, arg);\n        }\n      }\n    } else if (graphql.isInputObjectType(type)) {\n      hooks.onInputType(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onInputFieldType(type, field);\n      }\n    } else if (graphql.isUnionType(type)) {\n      hooks.onUnion(type);\n    } else if (graphql.isScalarType(type)) {\n      hooks.onScalar(type);\n    } else if (graphql.isEnumType(type)) {\n      hooks.onEnum(type);\n\n      for (const value of type.getValues()) {\n        hooks.onEnumValue(type, value);\n      }\n    }\n  }\n}\n\nfunction mergeExtensions(extensions) {\n  return utils.mergeDeep(extensions);\n}\n\nfunction applyExtensionObject(obj, extensions) {\n  if (!obj) {\n    return;\n  }\n\n  obj.extensions = utils.mergeDeep([obj.extensions || {}, extensions || {}]);\n}\n\nfunction applyExtensions(schema, extensions) {\n  applyExtensionObject(schema, extensions.schemaExtensions);\n\n  for (const [typeName, data] of Object.entries(extensions.types || {})) {\n    const type = schema.getType(typeName);\n\n    if (type) {\n      applyExtensionObject(type, data.extensions);\n\n      if (data.type === 'object' || data.type === 'interface') {\n        for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n          const field = type.getFields()[fieldName];\n\n          if (field) {\n            applyExtensionObject(field, fieldData.extensions);\n\n            for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n              applyExtensionObject(field.args.find(a => a.name === arg), argData);\n            }\n          }\n        }\n      } else if (data.type === 'input') {\n        for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n          const field = type.getFields()[fieldName];\n          applyExtensionObject(field, fieldData.extensions);\n        }\n      } else if (data.type === 'enum') {\n        for (const [valueName, valueData] of Object.entries(data.values)) {\n          const value = type.getValue(valueName);\n          applyExtensionObject(value, valueData);\n        }\n      }\n    }\n  }\n\n  return schema;\n}\n\nfunction extractExtensionsFromSchema(schema) {\n  const result = {\n    schemaExtensions: {},\n    types: {}\n  };\n  travelSchemaPossibleExtensions(schema, {\n    onSchema: schema => result.schemaExtensions = schema.extensions || {},\n    onObjectType: type => result.types[type.name] = {\n      fields: {},\n      type: 'object',\n      extensions: type.extensions || {}\n    },\n    onObjectField: (type, field) => result.types[type.name].fields[field.name] = {\n      arguments: {},\n      extensions: field.extensions || {}\n    },\n    onObjectFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},\n    onInterface: type => result.types[type.name] = {\n      fields: {},\n      type: 'interface',\n      extensions: type.extensions || {}\n    },\n    onInterfaceField: (type, field) => result.types[type.name].fields[field.name] = {\n      arguments: {},\n      extensions: field.extensions || {}\n    },\n    onInterfaceFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},\n    onEnum: type => result.types[type.name] = {\n      values: {},\n      type: 'enum',\n      extensions: type.extensions || {}\n    },\n    onEnumValue: (type, value) => result.types[type.name].values[value.name] = value.extensions || {},\n    onScalar: type => result.types[type.name] = {\n      type: 'scalar',\n      extensions: type.extensions || {}\n    },\n    onUnion: type => result.types[type.name] = {\n      type: 'union',\n      extensions: type.extensions || {}\n    },\n    onInputType: type => result.types[type.name] = {\n      fields: {},\n      type: 'input',\n      extensions: type.extensions || {}\n    },\n    onInputFieldType: (type, field) => result.types[type.name].fields[field.name] = {\n      extensions: field.extensions || {}\n    }\n  });\n  return result;\n}\n\nexports.applyExtensions = applyExtensions;\nexports.defaultStringComparator = defaultStringComparator;\nexports.extractExtensionsFromSchema = extractExtensionsFromSchema;\nexports.extractType = extractType;\nexports.isListTypeNode = isListTypeNode;\nexports.isNamedDefinitionNode = isNamedDefinitionNode;\nexports.isNonNullTypeNode = isNonNullTypeNode;\nexports.isSourceTypes = isSourceTypes;\nexports.isStringTypes = isStringTypes;\nexports.isWrappingTypeNode = isWrappingTypeNode;\nexports.mergeArguments = mergeArguments;\nexports.mergeDirective = mergeDirective;\nexports.mergeDirectives = mergeDirectives;\nexports.mergeEnum = mergeEnum;\nexports.mergeEnumValues = mergeEnumValues;\nexports.mergeExtensions = mergeExtensions;\nexports.mergeFields = mergeFields;\nexports.mergeGraphQLNodes = mergeGraphQLNodes;\nexports.mergeGraphQLTypes = mergeGraphQLTypes;\nexports.mergeInputType = mergeInputType;\nexports.mergeInterface = mergeInterface;\nexports.mergeNamedTypeArray = mergeNamedTypeArray;\nexports.mergeResolvers = mergeResolvers;\nexports.mergeScalar = mergeScalar;\nexports.mergeType = mergeType;\nexports.mergeTypeDefs = mergeTypeDefs;\nexports.mergeUnion = mergeUnion;\nexports.printTypeNode = printTypeNode;\nexports.schemaDefSymbol = schemaDefSymbol;\nexports.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/@graphql-tools/merge/index.js"],"names":["Object","defineProperty","exports","value","utils","require","graphql","mergeResolvers","resolversDefinitions","options","Array","isArray","length","resolvers","resolversDefinition","push","result","mergeDeep","exclusions","exclusion","typeName","fieldName","split","mergeArguments","args1","args2","config","deduplicateArguments","filter","isSome","sort","compareNodes","args","reduce","acc","current","dup","find","arg","name","concat","directiveAlreadyExists","directivesArr","otherDirective","directive","nameAlreadyExists","namesArr","some","mergeArguments$1","a1","a2","argument","existingIndex","findIndex","a","existingArg","kind","source","values","target","deduplicateLists","targetVal","sourceVal","deduplicateDirectives","directives","map","i","all","firstAt","d","arguments","mergeDirectives","d1","d2","reverseOrder","reverseDirectives","asNext","asFirst","existingDirectiveIndex","existingDirective","validateInputs","node","existingNode","printedNode","print","description","undefined","printedExistingNode","leaveInputs","RegExp","sameArguments","replace","Error","mergeDirective","locations","filterFn","val","mergeEnumValues","first","second","consistentEnumMerge","reversed","enumValueMap","Map","firstValue","set","secondValue","enumValue","has","get","mergeEnum","e1","e2","convertExtensions","loc","Kind","ENUM_TYPE_DEFINITION","isStringTypes","types","isSourceTypes","Source","extractType","type","visitedType","LIST_TYPE","isWrappingTypeNode","NAMED_TYPE","isListTypeNode","isNonNullTypeNode","NON_NULL_TYPE","printTypeNode","CompareVal","defaultStringComparator","b","A_EQUALS_B","A_SMALLER_THAN_B","A_GREATER_THAN_B","fieldAlreadyExists","fieldsArr","otherField","field","ignoreFieldConflicts","t1","t2","mergeFields","f1","f2","existing","f","throwOnConflict","preventConflicts","includes","ignoreNullability","aType","bType","safeChangeForFieldType","oldType","newType","toString","ofType","mergeInputType","fields","e","message","INPUT_OBJECT_TYPE_DEFINITION","mergeInterface","INTERFACE_TYPE_DEFINITION","alreadyExists","arr","other","mergeNamedTypeArray","mergeType","interfaces","OBJECT_TYPE_DEFINITION","mergeScalar","SCALAR_TYPE_DEFINITION","mergeUnion","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","DEFAULT_OPERATION_TYPE_NAME_MAP","query","mutation","subscription","mergeOperationTypes","opNodeList","existingOpNodeList","finalOpNodeList","opNodeType","opNode","n","operation","mergeSchemaDefs","SCHEMA_DEFINITION","SCHEMA_EXTENSION","operationTypes","schemaDefSymbol","isNamedDefinitionNode","definitionNode","mergeGraphQLNodes","nodes","_a","_b","_c","mergedResultMap","nodeDefinition","commentDescriptions","collectComment","OBJECT_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","SCALAR_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","DIRECTIVE_DEFINITION","mergeTypeDefs","typeSource","resetComments","doc","DOCUMENT","definitions","mergeGraphQLTypes","useSchemaDefinition","forceSchemaDefinition","printWithComments","visitTypeSources","allNodes","visitedTypeSources","Set","add","isSchema","documentNode","getDocumentNodeFromSchema","parse","isDefinitionNode","isDocumentNode","mergedNodes","schemaDef","opTypeDefNodeType","opTypeDefNode","operationType","possibleRootTypeName","existingPossibleRootType","OPERATION_TYPE_DEFINITION","NAME","mergedNodeDefinitions","sortFn","travelSchemaPossibleExtensions","schema","hooks","onSchema","typesMap","getTypeMap","entries","isPredefinedScalar","isScalarType","isSpecifiedScalarType","isIntrospection","isIntrospectionType","isObjectType","onObjectType","getFields","onObjectField","onObjectFieldArg","isInterfaceType","onInterface","onInterfaceField","onInterfaceFieldArg","isInputObjectType","onInputType","onInputFieldType","isUnionType","onUnion","onScalar","isEnumType","onEnum","getValues","onEnumValue","mergeExtensions","extensions","applyExtensionObject","obj","applyExtensions","schemaExtensions","data","getType","fieldData","argData","valueName","valueData","getValue","extractExtensionsFromSchema"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst utils = require('@graphql-tools/utils');\nconst graphql = require('graphql');\n\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\nfunction mergeResolvers(resolversDefinitions, options) {\n    if (!resolversDefinitions || (Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0)) {\n        return {};\n    }\n    if (!Array.isArray(resolversDefinitions)) {\n        return resolversDefinitions;\n    }\n    if (resolversDefinitions.length === 1) {\n        return resolversDefinitions[0] || {};\n    }\n    const resolvers = new Array();\n    for (let resolversDefinition of resolversDefinitions) {\n        if (Array.isArray(resolversDefinition)) {\n            resolversDefinition = mergeResolvers(resolversDefinition);\n        }\n        if (typeof resolversDefinition === 'object' && resolversDefinition) {\n            resolvers.push(resolversDefinition);\n        }\n    }\n    const result = utils.mergeDeep(resolvers, true);\n    if (options === null || options === void 0 ? void 0 : options.exclusions) {\n        for (const exclusion of options.exclusions) {\n            const [typeName, fieldName] = exclusion.split('.');\n            if (!fieldName || fieldName === '*') {\n                delete result[typeName];\n            }\n            else if (result[typeName]) {\n                delete result[typeName][fieldName];\n            }\n        }\n    }\n    return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n    const result = deduplicateArguments([...args2, ...args1].filter(utils.isSome));\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    return result;\n}\nfunction deduplicateArguments(args) {\n    return args.reduce((acc, current) => {\n        const dup = acc.find(arg => arg.name.value === current.name.value);\n        if (!dup) {\n            return acc.concat([current]);\n        }\n        return acc;\n    }, []);\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments$1(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(utils.isSome);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext]);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nfunction validateInputs(node, existingNode) {\n    const printedNode = graphql.print({\n        ...node,\n        description: undefined,\n    });\n    const printedExistingNode = graphql.print({\n        ...existingNode,\n        description: undefined,\n    });\n    // eslint-disable-next-line\n    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n    if (!sameArguments) {\n        throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n    }\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        validateInputs(node, existingNode);\n        return {\n            ...node,\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n    if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {\n        const reversed = [];\n        if (first) {\n            reversed.push(...first);\n        }\n        first = second;\n        second = reversed;\n    }\n    const enumValueMap = new Map();\n    if (first) {\n        for (const firstValue of first) {\n            enumValueMap.set(firstValue.name.value, firstValue);\n        }\n    }\n    if (second) {\n        for (const secondValue of second) {\n            const enumValue = secondValue.name.value;\n            if (enumValueMap.has(enumValue)) {\n                const firstValue = enumValueMap.get(enumValue);\n                firstValue.description = secondValue.description || firstValue.description;\n                firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n            }\n            else {\n                enumValueMap.set(enumValue, secondValue);\n            }\n        }\n    }\n    const result = [...enumValueMap.values()];\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n    if (e2) {\n        return {\n            name: e1.name,\n            description: e1['description'] || e2['description'],\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition'\n                ? 'EnumTypeDefinition'\n                : 'EnumTypeExtension',\n            loc: e1.loc,\n            directives: mergeDirectives(e1.directives, e2.directives, config),\n            values: mergeEnumValues(e1.values, e2.values, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...e1,\n            kind: graphql.Kind.ENUM_TYPE_DEFINITION,\n        }\n        : e1;\n}\n\nfunction isStringTypes(types) {\n    return typeof types === 'string';\n}\nfunction isSourceTypes(types) {\n    return types instanceof graphql.Source;\n}\nfunction extractType(type) {\n    let visitedType = type;\n    while (visitedType.kind === graphql.Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n        visitedType = visitedType.type;\n    }\n    return visitedType;\n}\nfunction isWrappingTypeNode(type) {\n    return type.kind !== graphql.Kind.NAMED_TYPE;\n}\nfunction isListTypeNode(type) {\n    return type.kind === graphql.Kind.LIST_TYPE;\n}\nfunction isNonNullTypeNode(type) {\n    return type.kind === graphql.Kind.NON_NULL_TYPE;\n}\nfunction printTypeNode(type) {\n    if (isListTypeNode(type)) {\n        return `[${printTypeNode(type.type)}]`;\n    }\n    if (isNonNullTypeNode(type)) {\n        return `${printTypeNode(type.type)}!`;\n    }\n    return type.name.value;\n}\n(function (CompareVal) {\n    CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n    CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n    CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(exports.CompareVal || (exports.CompareVal = {}));\nfunction defaultStringComparator(a, b) {\n    if (a == null && b == null) {\n        return exports.CompareVal.A_EQUALS_B;\n    }\n    if (a == null) {\n        return exports.CompareVal.A_SMALLER_THAN_B;\n    }\n    if (b == null) {\n        return exports.CompareVal.A_GREATER_THAN_B;\n    }\n    if (a < b)\n        return exports.CompareVal.A_SMALLER_THAN_B;\n    if (a > b)\n        return exports.CompareVal.A_GREATER_THAN_B;\n    return exports.CompareVal.A_EQUALS_B;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n    const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n    if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n        const t1 = extractType(result.type);\n        const t2 = extractType(otherField.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n    }\n    return !!result;\n}\nfunction mergeFields(type, f1, f2, config) {\n    const result = [];\n    if (f2 != null) {\n        result.push(...f2);\n    }\n    if (f1 != null) {\n        for (const field of f1) {\n            if (fieldAlreadyExists(result, field, config)) {\n                const existing = result.find((f) => f.name.value === field.name.value);\n                if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n                    if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n                        preventConflicts(type, existing, field, false);\n                    }\n                    else {\n                        preventConflicts(type, existing, field, true);\n                    }\n                    if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n                        existing.type = field.type;\n                    }\n                }\n                existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n                existing.directives = mergeDirectives(field.directives, existing.directives, config);\n                existing.description = field.description || existing.description;\n            }\n            else {\n                result.push(field);\n            }\n        }\n    }\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    if (config && config.exclusions) {\n        const exclusions = config.exclusions;\n        return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = printTypeNode(a.type);\n    const bType = printTypeNode(b.type);\n    if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n    }\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if (isNonNullTypeNode(newType)) {\n        const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if (isNonNullTypeNode(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if (isListTypeNode(oldType)) {\n        return ((isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            (isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'InputObjectTypeDefinition' ||\n                    existingNode.kind === 'InputObjectTypeDefinition'\n                    ? 'InputObjectTypeDefinition'\n                    : 'InputObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'InterfaceTypeDefinition' ||\n                    existingNode.kind === 'InterfaceTypeDefinition'\n                    ? 'InterfaceTypeDefinition'\n                    : 'InterfaceTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction alreadyExists(arr, other) {\n    return !!arr.find(i => i.name.value === other.name.value);\n}\nfunction mergeNamedTypeArray(first = [], second = [], config = {}) {\n    const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'ObjectTypeDefinition' ||\n                    existingNode.kind === 'ObjectTypeDefinition'\n                    ? 'ObjectTypeDefinition'\n                    : 'ObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n                interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeScalar(node, existingNode, config) {\n    if (existingNode) {\n        return {\n            name: node.name,\n            description: node['description'] || existingNode['description'],\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                node.kind === 'ScalarTypeDefinition' ||\n                existingNode.kind === 'ScalarTypeDefinition'\n                ? 'ScalarTypeDefinition'\n                : 'ScalarTypeExtension',\n            loc: node.loc,\n            directives: mergeDirectives(node.directives, existingNode.directives, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.SCALAR_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeUnion(first, second, config) {\n    if (second) {\n        return {\n            name: first.name,\n            description: first['description'] || second['description'],\n            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n            directives: mergeDirectives(first.directives, second.directives, config),\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition'\n                ? graphql.Kind.UNION_TYPE_DEFINITION\n                : graphql.Kind.UNION_TYPE_EXTENSION,\n            loc: first.loc,\n            types: mergeNamedTypeArray(first.types, second.types, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...first,\n            kind: graphql.Kind.UNION_TYPE_DEFINITION,\n        }\n        : first;\n}\n\nconst DEFAULT_OPERATION_TYPE_NAME_MAP = {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription',\n};\nfunction mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {\n    const finalOpNodeList = [];\n    for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n        const opNode = opNodeList.find(n => n.operation === opNodeType) || existingOpNodeList.find(n => n.operation === opNodeType);\n        if (opNode) {\n            finalOpNodeList.push(opNode);\n        }\n    }\n    return finalOpNodeList;\n}\nfunction mergeSchemaDefs(node, existingNode, config) {\n    if (existingNode) {\n        return {\n            kind: node.kind === graphql.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql.Kind.SCHEMA_DEFINITION\n                ? graphql.Kind.SCHEMA_DEFINITION\n                : graphql.Kind.SCHEMA_EXTENSION,\n            description: node['description'] || existingNode['description'],\n            directives: mergeDirectives(node.directives, existingNode.directives, config),\n            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes),\n        };\n    }\n    return ((config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.SCHEMA_DEFINITION,\n        }\n        : node);\n}\n\nconst schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\nfunction isNamedDefinitionNode(definitionNode) {\n    return 'name' in definitionNode;\n}\nfunction mergeGraphQLNodes(nodes, config) {\n    var _a, _b, _c;\n    const mergedResultMap = {};\n    for (const nodeDefinition of nodes) {\n        if (isNamedDefinitionNode(nodeDefinition)) {\n            const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;\n            if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n                utils.collectComment(nodeDefinition);\n            }\n            if (name == null) {\n                continue;\n            }\n            if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {\n                delete mergedResultMap[name];\n            }\n            else {\n                switch (nodeDefinition.kind) {\n                    case graphql.Kind.OBJECT_TYPE_DEFINITION:\n                    case graphql.Kind.OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.ENUM_TYPE_DEFINITION:\n                    case graphql.Kind.ENUM_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.UNION_TYPE_DEFINITION:\n                    case graphql.Kind.UNION_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.SCALAR_TYPE_DEFINITION:\n                    case graphql.Kind.SCALAR_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n                    case graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.INTERFACE_TYPE_DEFINITION:\n                    case graphql.Kind.INTERFACE_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.DIRECTIVE_DEFINITION:\n                        mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);\n                        break;\n                }\n            }\n        }\n        else if (nodeDefinition.kind === graphql.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql.Kind.SCHEMA_EXTENSION) {\n            mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);\n        }\n    }\n    return mergedResultMap;\n}\n\nfunction mergeTypeDefs(typeSource, config) {\n    utils.resetComments();\n    const doc = {\n        kind: graphql.Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(typeSource, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        result = utils.printWithComments(doc);\n    }\n    else {\n        result = doc;\n    }\n    utils.resetComments();\n    return result;\n}\nfunction visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set()) {\n    if (typeSource && !visitedTypeSources.has(typeSource)) {\n        visitedTypeSources.add(typeSource);\n        if (typeof typeSource === 'function') {\n            visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n        }\n        else if (Array.isArray(typeSource)) {\n            for (const type of typeSource) {\n                visitTypeSources(type, options, allNodes, visitedTypeSources);\n            }\n        }\n        else if (graphql.isSchema(typeSource)) {\n            const documentNode = utils.getDocumentNodeFromSchema(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {\n            const documentNode = graphql.parse(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if (typeof typeSource === 'object' && graphql.isDefinitionNode(typeSource)) {\n            allNodes.push(typeSource);\n        }\n        else if (utils.isDocumentNode(typeSource)) {\n            visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n        }\n        else {\n            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n        }\n    }\n    return allNodes;\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n    var _a, _b, _c;\n    utils.resetComments();\n    const allNodes = visitTypeSources(typeSource, config);\n    const mergedNodes = mergeGraphQLNodes(allNodes, config);\n    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n        // XXX: right now we don't handle multiple schema definitions\n        const schemaDef = mergedNodes[schemaDefSymbol] || {\n            kind: graphql.Kind.SCHEMA_DEFINITION,\n            operationTypes: [],\n        };\n        const operationTypes = schemaDef.operationTypes;\n        for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n            const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n            if (!opTypeDefNode) {\n                const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n                const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n                    operationTypes.push({\n                        kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n                        type: {\n                            kind: graphql.Kind.NAMED_TYPE,\n                            name: existingPossibleRootType.name,\n                        },\n                        operation: opTypeDefNodeType,\n                    });\n                }\n            }\n        }\n        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n            mergedNodes[schemaDefSymbol] = schemaDef;\n        }\n    }\n    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n        mergedNodes[schemaDefSymbol] = {\n            kind: graphql.Kind.SCHEMA_DEFINITION,\n            operationTypes: [\n                {\n                    kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n                    operation: 'query',\n                    type: {\n                        kind: graphql.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: 'Query',\n                        },\n                    },\n                },\n            ],\n        };\n    }\n    const mergedNodeDefinitions = Object.values(mergedNodes);\n    if (config === null || config === void 0 ? void 0 : config.sort) {\n        const sortFn = typeof config.sort === 'function' ? config.sort : defaultStringComparator;\n        mergedNodeDefinitions.sort((a, b) => { var _a, _b; return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value); });\n    }\n    return mergedNodeDefinitions;\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n    hooks.onSchema(schema);\n    const typesMap = schema.getTypeMap();\n    for (const [, type] of Object.entries(typesMap)) {\n        const isPredefinedScalar = graphql.isScalarType(type) && graphql.isSpecifiedScalarType(type);\n        const isIntrospection = graphql.isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (graphql.isObjectType(type)) {\n            hooks.onObjectType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onObjectField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onObjectFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (graphql.isInterfaceType(type)) {\n            hooks.onInterface(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInterfaceField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onInterfaceFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (graphql.isInputObjectType(type)) {\n            hooks.onInputType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInputFieldType(type, field);\n            }\n        }\n        else if (graphql.isUnionType(type)) {\n            hooks.onUnion(type);\n        }\n        else if (graphql.isScalarType(type)) {\n            hooks.onScalar(type);\n        }\n        else if (graphql.isEnumType(type)) {\n            hooks.onEnum(type);\n            for (const value of type.getValues()) {\n                hooks.onEnumValue(type, value);\n            }\n        }\n    }\n}\nfunction mergeExtensions(extensions) {\n    return utils.mergeDeep(extensions);\n}\nfunction applyExtensionObject(obj, extensions) {\n    if (!obj) {\n        return;\n    }\n    obj.extensions = utils.mergeDeep([obj.extensions || {}, extensions || {}]);\n}\nfunction applyExtensions(schema, extensions) {\n    applyExtensionObject(schema, extensions.schemaExtensions);\n    for (const [typeName, data] of Object.entries(extensions.types || {})) {\n        const type = schema.getType(typeName);\n        if (type) {\n            applyExtensionObject(type, data.extensions);\n            if (data.type === 'object' || data.type === 'interface') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    if (field) {\n                        applyExtensionObject(field, fieldData.extensions);\n                        for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n                            applyExtensionObject(field.args.find(a => a.name === arg), argData);\n                        }\n                    }\n                }\n            }\n            else if (data.type === 'input') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    applyExtensionObject(field, fieldData.extensions);\n                }\n            }\n            else if (data.type === 'enum') {\n                for (const [valueName, valueData] of Object.entries(data.values)) {\n                    const value = type.getValue(valueName);\n                    applyExtensionObject(value, valueData);\n                }\n            }\n        }\n    }\n    return schema;\n}\nfunction extractExtensionsFromSchema(schema) {\n    const result = {\n        schemaExtensions: {},\n        types: {},\n    };\n    travelSchemaPossibleExtensions(schema, {\n        onSchema: schema => (result.schemaExtensions = schema.extensions || {}),\n        onObjectType: type => (result.types[type.name] = { fields: {}, type: 'object', extensions: type.extensions || {} }),\n        onObjectField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onObjectFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {}),\n        onInterface: type => (result.types[type.name] = { fields: {}, type: 'interface', extensions: type.extensions || {} }),\n        onInterfaceField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onInterfaceFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] =\n            arg.extensions || {}),\n        onEnum: type => (result.types[type.name] = { values: {}, type: 'enum', extensions: type.extensions || {} }),\n        onEnumValue: (type, value) => (result.types[type.name].values[value.name] = value.extensions || {}),\n        onScalar: type => (result.types[type.name] = { type: 'scalar', extensions: type.extensions || {} }),\n        onUnion: type => (result.types[type.name] = { type: 'union', extensions: type.extensions || {} }),\n        onInputType: type => (result.types[type.name] = { fields: {}, type: 'input', extensions: type.extensions || {} }),\n        onInputFieldType: (type, field) => (result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }),\n    });\n    return result;\n}\n\nexports.applyExtensions = applyExtensions;\nexports.defaultStringComparator = defaultStringComparator;\nexports.extractExtensionsFromSchema = extractExtensionsFromSchema;\nexports.extractType = extractType;\nexports.isListTypeNode = isListTypeNode;\nexports.isNamedDefinitionNode = isNamedDefinitionNode;\nexports.isNonNullTypeNode = isNonNullTypeNode;\nexports.isSourceTypes = isSourceTypes;\nexports.isStringTypes = isStringTypes;\nexports.isWrappingTypeNode = isWrappingTypeNode;\nexports.mergeArguments = mergeArguments;\nexports.mergeDirective = mergeDirective;\nexports.mergeDirectives = mergeDirectives;\nexports.mergeEnum = mergeEnum;\nexports.mergeEnumValues = mergeEnumValues;\nexports.mergeExtensions = mergeExtensions;\nexports.mergeFields = mergeFields;\nexports.mergeGraphQLNodes = mergeGraphQLNodes;\nexports.mergeGraphQLTypes = mergeGraphQLTypes;\nexports.mergeInputType = mergeInputType;\nexports.mergeInterface = mergeInterface;\nexports.mergeNamedTypeArray = mergeNamedTypeArray;\nexports.mergeResolvers = mergeResolvers;\nexports.mergeScalar = mergeScalar;\nexports.mergeType = mergeType;\nexports.mergeTypeDefs = mergeTypeDefs;\nexports.mergeUnion = mergeUnion;\nexports.printTypeNode = printTypeNode;\nexports.schemaDefSymbol = schemaDefSymbol;\nexports.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;\n"]},"metadata":{},"sourceType":"script"}