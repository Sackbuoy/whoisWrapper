{"ast":null,"code":"'use strict';\n\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors');\n\nconst {\n  kClients,\n  kRunning\n} = require('./core/symbols');\n\nconst Dispatcher = require('./dispatcher');\n\nconst Pool = require('./pool');\n\nconst Client = require('./client');\n\nconst util = require('./core/util');\n\nconst RedirectHandler = require('./handler/redirect');\n\nconst {\n  WeakRef,\n  FinalizationRegistry\n} = require('./compat/dispatcher-weakref')();\n\nconst kDestroyed = Symbol('destroyed');\nconst kClosed = Symbol('closed');\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kMaxRedirections = Symbol('maxRedirections');\nconst kOnDrain = Symbol('onDrain');\nconst kFactory = Symbol('factory');\nconst kFinalizer = Symbol('finalizer');\nconst kOptions = Symbol('options');\n\nfunction defaultFactory(origin, opts) {\n  return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\n\nclass Agent extends Dispatcher {\n  constructor() {\n    let {\n      factory = defaultFactory,\n      maxRedirections = 0,\n      connect,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect\n      };\n    }\n\n    this[kOptions] = { ...util.deepClone(options),\n      connect\n    };\n    this[kMaxRedirections] = maxRedirections;\n    this[kFactory] = factory;\n    this[kClients] = new Map();\n    this[kFinalizer] = new FinalizationRegistry(\n    /* istanbul ignore next: gc is undeterministic */\n    key => {\n      const ref = this[kClients].get(key);\n\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key);\n      }\n    });\n    this[kClosed] = false;\n    this[kDestroyed] = false;\n    const agent = this;\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets]);\n    };\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets]);\n    };\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err);\n    };\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err);\n    };\n  }\n\n  get [kRunning]() {\n    let ret = 0;\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore next: gc is undeterministic */\n\n      if (client) {\n        ret += client[kRunning];\n      }\n    }\n\n    return ret;\n  }\n\n  dispatch(opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object.');\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.');\n      }\n\n      let key;\n\n      if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n        key = String(opts.origin);\n      } else {\n        throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError();\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError();\n      }\n\n      const ref = this[kClients].get(key);\n      let dispatcher = ref ? ref.deref() : null;\n\n      if (!dispatcher) {\n        dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n        this[kClients].set(key, new WeakRef(dispatcher));\n        this[kFinalizer].register(dispatcher, key);\n      }\n\n      const {\n        maxRedirections = this[kMaxRedirections]\n      } = opts;\n\n      if (maxRedirections != null && maxRedirections !== 0) {\n        opts = { ...opts,\n          maxRedirections: 0\n        }; // Stop sub dispatcher from also redirecting.\n\n        handler = new RedirectHandler(this, maxRedirections, opts, handler);\n      }\n\n      return dispatcher.dispatch(opts, handler);\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method');\n      }\n\n      handler.onError(err);\n    }\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get destroyed() {\n    return this[kDestroyed];\n  }\n\n  close(callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function');\n    }\n\n    this[kClosed] = true;\n    const closePromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        closePromises.push(client.close());\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(closePromises);\n    } // Should never error.\n\n\n    Promise.all(closePromises).then(() => process.nextTick(callback));\n  }\n\n  destroy(err, callback) {\n    if (typeof err === 'function') {\n      callback = err;\n      err = null;\n    }\n\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function');\n    }\n\n    this[kClosed] = true;\n    this[kDestroyed] = true;\n    const destroyPromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        destroyPromises.push(client.destroy(err));\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(destroyPromises);\n    } // Should never error.\n\n\n    Promise.all(destroyPromises).then(() => process.nextTick(callback));\n  }\n\n}\n\nmodule.exports = Agent;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/agent.js"],"names":["ClientClosedError","InvalidArgumentError","ClientDestroyedError","require","kClients","kRunning","Dispatcher","Pool","Client","util","RedirectHandler","WeakRef","FinalizationRegistry","kDestroyed","Symbol","kClosed","kOnConnect","kOnDisconnect","kOnConnectionError","kMaxRedirections","kOnDrain","kFactory","kFinalizer","kOptions","defaultFactory","origin","opts","connections","Agent","constructor","factory","maxRedirections","connect","options","Number","isInteger","deepClone","Map","key","ref","get","undefined","deref","delete","agent","targets","emit","err","ret","values","client","dispatch","handler","URL","String","dispatcher","on","set","register","onError","closed","destroyed","close","callback","closePromises","push","Promise","all","then","process","nextTick","destroy","destroyPromises","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst { kClients, kRunning } = require('./core/symbols')\nconst Dispatcher = require('./dispatcher')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('./core/util')\nconst RedirectHandler = require('./handler/redirect')\nconst { WeakRef, FinalizationRegistry } = require('./compat/dispatcher-weakref')()\n\nconst kDestroyed = Symbol('destroyed')\nconst kClosed = Symbol('closed')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends Dispatcher {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n    this[kClosed] = false\n    this[kDestroyed] = false\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object.')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      let key\n      if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n        key = String(opts.origin)\n      } else {\n        throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      const ref = this[kClients].get(key)\n\n      let dispatcher = ref ? ref.deref() : null\n      if (!dispatcher) {\n        dispatcher = this[kFactory](opts.origin, this[kOptions])\n          .on('drain', this[kOnDrain])\n          .on('connect', this[kOnConnect])\n          .on('disconnect', this[kOnDisconnect])\n          .on('connectionError', this[kOnConnectionError])\n\n        this[kClients].set(key, new WeakRef(dispatcher))\n        this[kFinalizer].register(dispatcher, key)\n      }\n\n      const { maxRedirections = this[kMaxRedirections] } = opts\n      if (maxRedirections != null && maxRedirections !== 0) {\n        opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n        handler = new RedirectHandler(this, maxRedirections, opts, handler)\n      }\n\n      return dispatcher.dispatch(opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  close (callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(closePromises)\n    }\n\n    // Should never error.\n    Promise.all(closePromises).then(() => process.nextTick(callback))\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n    this[kDestroyed] = true\n\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(destroyPromises)\n    }\n\n    // Should never error.\n    Promise.all(destroyPromises).then(() => process.nextTick(callback))\n  }\n}\n\nmodule.exports = Agent\n"]},"metadata":{},"sourceType":"script"}