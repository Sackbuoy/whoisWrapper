{"ast":null,"code":"// Ported from https://github.com/nodejs/undici/pull/907\n'use strict';\n\nconst assert = require('assert');\n\nconst {\n  Readable\n} = require('stream');\n\nconst {\n  RequestAbortedError,\n  NotSupportedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  ReadableStreamFrom,\n  toUSVString\n} = require('../fetch/util');\n\nlet Blob;\nconst kConsume = Symbol('kConsume');\nconst kReading = Symbol('kReading');\nconst kBody = Symbol('kBody');\nconst kAbort = Symbol('abort');\nconst kContentType = Symbol('kContentType');\nmodule.exports = class BodyReadable extends Readable {\n  constructor(resume, abort) {\n    let contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n\n    });\n    this._readableState.dataEmitted = false;\n    this[kAbort] = abort;\n    this[kConsume] = null;\n    this[kBody] = null;\n    this[kContentType] = contentType; // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n\n    this[kReading] = false;\n  }\n\n  destroy(err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this;\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError();\n    }\n\n    if (err) {\n      this[kAbort]();\n    }\n\n    return super.destroy(err);\n  }\n\n  emit(ev) {\n    // Waiting for: https://github.com/nodejs/node/pull/39589\n    if (ev === 'data') {\n      this._readableState.dataEmitted = true;\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return super.emit(ev, ...args);\n  }\n\n  on(ev) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true;\n    }\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    return super.on(ev, ...args);\n  }\n\n  addListener(ev) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return this.on(ev, ...args);\n  }\n\n  off(ev) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    const ret = super.off(ev, ...args);\n\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;\n    }\n\n    return ret;\n  }\n\n  removeListener(ev) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n\n    return this.off(ev, ...args);\n  }\n\n  push(chunk) {\n    if (this[kConsume] && chunk !== null && !this[kReading]) {\n      consumePush(this[kConsume], chunk);\n      return true;\n    } else {\n      return super.push(chunk);\n    }\n  } // https://fetch.spec.whatwg.org/#dom-body-text\n\n\n  async text() {\n    return toUSVString(await consume(this, 'text'));\n  } // https://fetch.spec.whatwg.org/#dom-body-json\n\n\n  async json() {\n    return consume(this, 'json');\n  } // https://fetch.spec.whatwg.org/#dom-body-blob\n\n\n  async blob() {\n    return consume(this, 'blob');\n  } // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n\n\n  async arrayBuffer() {\n    return consume(this, 'arrayBuffer');\n  } // https://fetch.spec.whatwg.org/#dom-body-formdata\n\n\n  async formData() {\n    // TODO: Implement.\n    throw new NotSupportedError();\n  } // https://fetch.spec.whatwg.org/#dom-body-bodyused\n\n\n  get bodyUsed() {\n    return util.isDisturbed(this);\n  } // https://fetch.spec.whatwg.org/#dom-body-body\n\n\n  get body() {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this);\n\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader(); // Ensure stream is locked.\n\n        assert(this[kBody].locked);\n      }\n    }\n\n    return this[kBody];\n  }\n\n}; // https://streams.spec.whatwg.org/#readablestream-locked\n\nfunction isLocked(self) {\n  // Consume is an implicit lock.\n  return self[kBody] && self[kBody].locked === true || self[kConsume];\n} // https://fetch.spec.whatwg.org/#body-unusable\n\n\nfunction isUnusable(self) {\n  return util.isDisturbed(self) || isLocked(self);\n}\n\nasync function consume(stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable');\n  }\n\n  assert(!stream[kConsume]);\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    };\n    stream.on('error', function (err) {\n      consumeFinish(this[kConsume], err);\n    }).on('close', function () {\n      if (this[kConsume].body !== null) {\n        consumeFinish(this[kConsume], new RequestAbortedError());\n      }\n    });\n    process.nextTick(consumeStart, stream[kConsume]);\n  });\n}\n\nfunction consumeStart(consume) {\n  if (consume.body === null) {\n    return;\n  }\n\n  const {\n    _readableState: state\n  } = consume.stream;\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk);\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume]);\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume]);\n    });\n  }\n\n  consume.stream.resume();\n\n  while (consume.stream.read() != null) {// Loop\n  }\n}\n\nfunction consumeEnd(consume) {\n  const {\n    type,\n    body,\n    resolve,\n    stream,\n    length\n  } = consume;\n\n  try {\n    if (type === 'text') {\n      resolve(body.join(''));\n    } else if (type === 'json') {\n      resolve(JSON.parse(body.join('')));\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length);\n      let pos = 0;\n\n      for (const buf of body) {\n        dst.set(buf, pos);\n        pos += buf.byteLength;\n      }\n\n      resolve(dst);\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob;\n      }\n\n      resolve(new Blob(body, {\n        type: stream[kContentType]\n      }));\n    }\n\n    consumeFinish(consume);\n  } catch (err) {\n    stream.destroy(err);\n  }\n}\n\nfunction consumePush(consume, chunk) {\n  consume.length += chunk.length;\n  consume.body.push(chunk);\n}\n\nfunction consumeFinish(consume, err) {\n  if (consume.body === null) {\n    return;\n  }\n\n  if (err) {\n    consume.reject(err);\n  } else {\n    consume.resolve();\n  }\n\n  consume.reject = null;\n  consume.resolve = null;\n  consume.decoder = null;\n  consume.body = null;\n}","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/api/readable.js"],"names":["assert","require","Readable","RequestAbortedError","NotSupportedError","util","ReadableStreamFrom","toUSVString","Blob","kConsume","Symbol","kReading","kBody","kAbort","kContentType","module","exports","BodyReadable","constructor","resume","abort","contentType","autoDestroy","read","highWaterMark","_readableState","dataEmitted","destroy","err","destroyed","endEmitted","emit","ev","errorEmitted","args","on","addListener","off","ret","listenerCount","removeListener","push","chunk","consumePush","text","consume","json","blob","arrayBuffer","formData","bodyUsed","isDisturbed","body","getReader","locked","isLocked","self","isUnusable","stream","type","TypeError","Promise","resolve","reject","length","consumeFinish","process","nextTick","consumeStart","state","buffer","consumeEnd","join","JSON","parse","dst","Uint8Array","pos","buf","set","byteLength","decoder"],"mappings":"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","sourcesContent":["// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('assert')\nconst { Readable } = require('stream')\nconst { RequestAbortedError, NotSupportedError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString } = require('../fetch/util')\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor (resume, abort, contentType = '') {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    // Waiting for: https://github.com/nodejs/node/pull/39589\n    if (ev === 'data') {\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null && !this[kReading]) {\n      consumePush(this[kConsume], chunk)\n      return true\n    } else {\n      return super.push(chunk)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return toUSVString(await consume(this, 'text'))\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(body.join(''))\n    } else if (type === 'json') {\n      resolve(JSON.parse(body.join('')))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.reject = null\n  consume.resolve = null\n  consume.decoder = null\n  consume.body = null\n}\n"]},"metadata":{},"sourceType":"script"}