{"ast":null,"code":"'use strict';\n\nconst Dispatcher = require('./dispatcher');\n\nconst Client = require('./client');\n\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors');\n\nconst FixedQueue = require('./node/fixed-queue');\n\nconst util = require('./core/util');\n\nconst {\n  kSize,\n  kRunning,\n  kUrl,\n  kPending,\n  kBusy\n} = require('./core/symbols');\n\nconst assert = require('assert');\n\nconst buildConnector = require('./core/connect');\n\nconst kClients = Symbol('clients');\nconst kNeedDrain = Symbol('needDrain');\nconst kQueue = Symbol('queue');\nconst kDestroyed = Symbol('destroyed');\nconst kClosedPromise = Symbol('closed promise');\nconst kClosedResolve = Symbol('closed resolve');\nconst kOptions = Symbol('options');\nconst kOnDrain = Symbol('onDrain');\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kConnections = Symbol('connections');\nconst kFactory = Symbol('factory');\nconst kQueued = Symbol('queued');\n\nfunction defaultFactory(origin, opts) {\n  return new Client(origin, opts);\n}\n\nclass Pool extends Dispatcher {\n  constructor(origin) {\n    let {\n      connections,\n      factory = defaultFactory,\n      connect,\n      connectTimeout,\n      tls,\n      maxCachedSessions,\n      socketPath,\n      ...options\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections');\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({ ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout == null ? 10e3 : connectTimeout,\n        ...connect\n      });\n    }\n\n    this[kConnections] = connections || null;\n    this[kUrl] = util.parseOrigin(origin);\n    this[kOptions] = { ...util.deepClone(options),\n      connect\n    };\n    this[kQueue] = new FixedQueue();\n    this[kClosedPromise] = null;\n    this[kClosedResolve] = null;\n    this[kDestroyed] = false;\n    this[kClients] = [];\n    this[kNeedDrain] = false;\n    this[kQueued] = 0;\n    this[kFactory] = factory;\n    const pool = this;\n\n    this[kOnDrain] = function onDrain(url, targets) {\n      assert(pool[kUrl].origin === url.origin);\n      const queue = pool[kQueue];\n      let needDrain = false;\n\n      while (!needDrain) {\n        const item = queue.shift();\n\n        if (!item) {\n          break;\n        }\n\n        pool[kQueued]--;\n        needDrain = !this.dispatch(item.opts, item.handler);\n      }\n\n      this[kNeedDrain] = needDrain;\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false;\n        pool.emit('drain', origin, [pool, ...targets]);\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise.all(pool[kClients].map(c => c.close())).then(pool[kClosedResolve]);\n      }\n    };\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets]);\n    };\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err);\n    };\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err);\n    };\n  }\n\n  get [kBusy]() {\n    return this[kNeedDrain];\n  }\n\n  get [kPending]() {\n    let ret = this[kQueued];\n\n    for (const {\n      [kPending]: pending\n    } of this[kClients]) {\n      ret += pending;\n    }\n\n    return ret;\n  }\n\n  get [kRunning]() {\n    let ret = 0;\n\n    for (const {\n      [kRunning]: running\n    } of this[kClients]) {\n      ret += running;\n    }\n\n    return ret;\n  }\n\n  get [kSize]() {\n    let ret = this[kQueued];\n\n    for (const {\n      [kSize]: size\n    } of this[kClients]) {\n      ret += size;\n    }\n\n    return ret;\n  }\n\n  get destroyed() {\n    return this[kDestroyed];\n  }\n\n  get closed() {\n    return this[kClosedPromise] != null;\n  }\n\n  dispatch(opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object');\n    }\n\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError();\n      }\n\n      if (this[kClosedPromise]) {\n        throw new ClientClosedError();\n      }\n\n      let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain]);\n\n      if (!dispatcher) {\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n          dispatcher = this[kFactory](this[kUrl], this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n          this[kClients].push(dispatcher);\n        }\n      }\n\n      if (!dispatcher) {\n        this[kNeedDrain] = true;\n        this[kQueue].push({\n          opts,\n          handler\n        });\n        this[kQueued]++;\n      } else if (!dispatcher.dispatch(opts, handler)) {\n        dispatcher[kNeedDrain] = true;\n        this[kNeedDrain] = this[kConnections] && this[kClients].length === this[kConnections];\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method');\n      }\n\n      handler.onError(err);\n    }\n\n    return !this[kNeedDrain];\n  }\n\n  close(cb) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError();\n      }\n\n      if (!this[kClosedPromise]) {\n        if (this[kQueue].isEmpty()) {\n          this[kClosedPromise] = Promise.all(this[kClients].map(c => c.close()));\n        } else {\n          this[kClosedPromise] = new Promise(resolve => {\n            this[kClosedResolve] = resolve;\n          });\n        }\n\n        this[kClosedPromise] = this[kClosedPromise].then(() => {\n          this[kDestroyed] = true;\n        });\n      }\n\n      if (cb) {\n        this[kClosedPromise].then(() => cb(null, null));\n      } else {\n        return this[kClosedPromise];\n      }\n    } catch (err) {\n      if (cb) {\n        cb(err);\n      } else {\n        return Promise.reject(err);\n      }\n    }\n  }\n\n  destroy(err, cb) {\n    this[kDestroyed] = true;\n\n    if (typeof err === 'function') {\n      cb = err;\n      err = null;\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError();\n    }\n\n    while (true) {\n      const item = this[kQueue].shift();\n\n      if (!item) {\n        break;\n      }\n\n      item.handler.onError(err);\n    }\n\n    const promise = Promise.all(this[kClients].map(c => c.destroy(err)));\n\n    if (cb) {\n      promise.then(() => cb(null, null));\n    } else {\n      return promise;\n    }\n  }\n\n}\n\nmodule.exports = Pool;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/pool.js"],"names":["Dispatcher","require","Client","ClientClosedError","InvalidArgumentError","ClientDestroyedError","FixedQueue","util","kSize","kRunning","kUrl","kPending","kBusy","assert","buildConnector","kClients","Symbol","kNeedDrain","kQueue","kDestroyed","kClosedPromise","kClosedResolve","kOptions","kOnDrain","kOnConnect","kOnDisconnect","kOnConnectionError","kConnections","kFactory","kQueued","defaultFactory","origin","opts","Pool","constructor","connections","factory","connect","connectTimeout","tls","maxCachedSessions","socketPath","options","Number","isFinite","timeout","parseOrigin","deepClone","pool","onDrain","url","targets","queue","needDrain","item","shift","dispatch","handler","emit","isEmpty","Promise","all","map","c","close","then","err","ret","pending","running","size","destroyed","closed","dispatcher","find","length","on","push","onError","cb","resolve","reject","destroy","promise","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Dispatcher = require('./dispatcher')\nconst Client = require('./client')\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst FixedQueue = require('./node/fixed-queue')\nconst util = require('./core/util')\nconst { kSize, kRunning, kUrl, kPending, kBusy } = require('./core/symbols')\nconst assert = require('assert')\nconst buildConnector = require('./core/connect')\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kDestroyed = Symbol('destroyed')\nconst kClosedPromise = Symbol('closed promise')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOptions = Symbol('options')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\nconst kQueued = Symbol('queued')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends Dispatcher {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    ...options\n  } = {}) {\n    super()\n\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout == null ? 10e3 : connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kQueue] = new FixedQueue()\n    this[kClosedPromise] = null\n    this[kClosedResolve] = null\n    this[kDestroyed] = false\n    this[kClients] = []\n    this[kNeedDrain] = false\n    this[kQueued] = 0\n    this[kFactory] = factory\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (url, targets) {\n      assert(pool[kUrl].origin === url.origin)\n\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosedPromise] != null\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosedPromise]) {\n        throw new ClientClosedError()\n      }\n\n      let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain])\n\n      if (!dispatcher) {\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n          dispatcher = this[kFactory](this[kUrl], this[kOptions])\n            .on('drain', this[kOnDrain])\n            .on('connect', this[kOnConnect])\n            .on('disconnect', this[kOnDisconnect])\n            .on('connectionError', this[kOnConnectionError])\n          this[kClients].push(dispatcher)\n        }\n      }\n\n      if (!dispatcher) {\n        this[kNeedDrain] = true\n        this[kQueue].push({ opts, handler })\n        this[kQueued]++\n      } else if (!dispatcher.dispatch(opts, handler)) {\n        dispatcher[kNeedDrain] = true\n        this[kNeedDrain] = this[kConnections] && this[kClients].length === this[kConnections]\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  close (cb) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (!this[kClosedPromise]) {\n        if (this[kQueue].isEmpty()) {\n          this[kClosedPromise] = Promise.all(this[kClients].map(c => c.close()))\n        } else {\n          this[kClosedPromise] = new Promise((resolve) => {\n            this[kClosedResolve] = resolve\n          })\n        }\n        this[kClosedPromise] = this[kClosedPromise].then(() => {\n          this[kDestroyed] = true\n        })\n      }\n\n      if (cb) {\n        this[kClosedPromise].then(() => cb(null, null))\n      } else {\n        return this[kClosedPromise]\n      }\n    } catch (err) {\n      if (cb) {\n        cb(err)\n      } else {\n        return Promise.reject(err)\n      }\n    }\n  }\n\n  destroy (err, cb) {\n    this[kDestroyed] = true\n\n    if (typeof err === 'function') {\n      cb = err\n      err = null\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    const promise = Promise.all(this[kClients].map(c => c.destroy(err)))\n    if (cb) {\n      promise.then(() => cb(null, null))\n    } else {\n      return promise\n    }\n  }\n}\n\nmodule.exports = Pool\n"]},"metadata":{},"sourceType":"script"}