{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst graphql = require('graphql');\n\nconst utils = require('@graphql-tools/utils');\n\nconst merge = require('@graphql-tools/merge');\n\nfunction assertResolversPresent(schema) {\n  let resolverValidationOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    requireResolversForArgs,\n    requireResolversForNonScalar,\n    requireResolversForAllFields\n  } = resolverValidationOptions;\n\n  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n    throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');\n  }\n\n  utils.forEachField(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n    } // requires a resolver on every field that has arguments\n\n\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n    } // requires a resolver on every field that returns a non-scalar type\n\n\n    if (requireResolversForNonScalar !== 'ignore' && !graphql.isScalarType(graphql.getNamedType(field.type))) {\n      expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n  if (!field.resolve) {\n    const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n\n    if (behavior === 'error') {\n      throw new Error(message);\n    }\n\n    if (behavior === 'warn') {\n      // eslint-disable-next-line no-console\n      console.warn(message);\n    }\n\n    return;\n  }\n\n  if (typeof field.resolve !== 'function') {\n    throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n  }\n}\n\nfunction chainResolvers(resolvers) {\n  return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n    if (curResolver != null) {\n      return curResolver(prev, args, ctx, info);\n    }\n\n    return graphql.defaultFieldResolver(prev, args, ctx, info);\n  }, root);\n} // If we have any union or interface types throw if no there is no resolveType resolver\n\n\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n  utils.mapSchema(schema, {\n    [utils.MapperKind.ABSTRACT_TYPE]: type => {\n      if (!type.resolveType) {\n        const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` + '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n\n        if (requireResolversForResolveType === 'error') {\n          throw new Error(message);\n        }\n\n        if (requireResolversForResolveType === 'warn') {\n          // eslint-disable-next-line no-console\n          console.warn(message);\n        }\n      }\n\n      return undefined;\n    }\n  });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n  const extendedResolvers = {};\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName];\n\n    if ('getInterfaces' in type) {\n      extendedResolvers[typeName] = {};\n\n      for (const iFace of type.getInterfaces()) {\n        if (resolvers[iFace.name]) {\n          for (const fieldName in resolvers[iFace.name]) {\n            if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n            }\n          }\n        }\n      }\n\n      const typeResolvers = resolvers[typeName];\n      extendedResolvers[typeName] = { ...extendedResolvers[typeName],\n        ...typeResolvers\n      };\n    } else {\n      const typeResolvers = resolvers[typeName];\n\n      if (typeResolvers != null) {\n        extendedResolvers[typeName] = typeResolvers;\n      }\n    }\n  }\n\n  return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n  const options = graphql.isSchema(schemaOrOptions) ? {\n    schema: schemaOrOptions,\n    resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},\n    resolverValidationOptions: legacyInputValidationOptions\n  } : schemaOrOptions;\n  let {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n    updateResolversInPlace = false\n  } = options;\n  const {\n    requireResolversToMatchSchema = 'error',\n    requireResolversForResolveType\n  } = resolverValidationOptions;\n  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;\n\n  for (const typeName in resolvers) {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object') {\n      throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n    }\n\n    const type = schema.getType(typeName);\n\n    if (type == null) {\n      if (requireResolversToMatchSchema === 'ignore') {\n        break;\n      }\n\n      throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n    } else if (graphql.isSpecifiedScalarType(type)) {\n      // allow -- without recommending -- overriding of specified scalar types\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if (graphql.isEnumType(type)) {\n      const values = type.getValues();\n\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && !values.some(value => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n        }\n      }\n    } else if (graphql.isUnionType(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n        }\n      }\n    } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__')) {\n          const fields = type.getFields();\n          const field = fields[fieldName];\n\n          if (field == null) {\n            // Field present in resolver but not in schema\n            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n            }\n          } else {\n            // Field present in both the resolver and schema\n            const fieldResolve = resolverValue[fieldName];\n\n            if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n\n  if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n    checkForResolveTypeResolver(schema, requireResolversForResolveType);\n  }\n\n  return schema;\n}\n\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in resolvers) {\n    const type = schema.getType(typeName);\n    const resolverValue = resolvers[typeName];\n\n    if (graphql.isScalarType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && type.astNode != null) {\n          type.astNode = { ...type.astNode,\n            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.astNode.description,\n            directives: ((_d = type.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n          type.extensionASTNodes = type.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if (graphql.isEnumType(type)) {\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          config[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && config.astNode != null) {\n          config.astNode = { ...config.astNode,\n            description: (_m = (_l = (_k = resolverValue) === null || _k === void 0 ? void 0 : _k.astNode) === null || _l === void 0 ? void 0 : _l.description) !== null && _m !== void 0 ? _m : config.astNode.description,\n            directives: ((_o = config.astNode.directives) !== null && _o !== void 0 ? _o : []).concat((_r = (_q = (_p = resolverValue) === null || _p === void 0 ? void 0 : _p.astNode) === null || _q === void 0 ? void 0 : _q.directives) !== null && _r !== void 0 ? _r : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n          config.extensionASTNodes = config.extensionASTNodes.concat((_t = (_s = resolverValue) === null || _s === void 0 ? void 0 : _s.extensionASTNodes) !== null && _t !== void 0 ? _t : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else if (enumValueConfigMap[fieldName]) {\n          enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n        }\n      }\n\n      typeMap[typeName] = new graphql.GraphQLEnumType(config);\n    } else if (graphql.isUnionType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        }\n      }\n    } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          break;\n        }\n\n        const fields = type.getFields();\n        const field = fields[fieldName];\n\n        if (field != null) {\n          const fieldResolve = resolverValue[fieldName];\n\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            field.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(field, fieldResolve);\n          }\n        }\n      }\n    }\n  } // serialize all default values prior to healing fields with new scalar/enum types.\n\n\n  utils.forEachDefaultValue(schema, utils.serializeInputValue); // schema may have new scalar/enum types that require healing\n\n  utils.healSchema(schema); // reparse all default values with new parsing functions.\n\n  utils.forEachDefaultValue(schema, utils.parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    utils.forEachField(schema, field => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n  schema = utils.mapSchema(schema, {\n    [utils.MapperKind.SCALAR_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n      const config = type.toConfig();\n      const resolverValue = resolvers[type.name];\n\n      if (!graphql.isSpecifiedScalarType(type) && resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n              directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else {\n            config[fieldName] = resolverValue[fieldName];\n          }\n        }\n\n        return new graphql.GraphQLScalarType(config);\n      }\n    },\n    [utils.MapperKind.ENUM_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n      const resolverValue = resolvers[type.name];\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      if (resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n              directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        }\n\n        return new graphql.GraphQLEnumType(config);\n      }\n    },\n    [utils.MapperKind.UNION_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n\n        return new graphql.GraphQLUnionType(config);\n      }\n    },\n    [utils.MapperKind.OBJECT_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__isTypeOf']) {\n          config.isTypeOf = resolverValue['__isTypeOf'];\n        }\n\n        return new graphql.GraphQLObjectType(config);\n      }\n    },\n    [utils.MapperKind.INTERFACE_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n\n        return new graphql.GraphQLInterfaceType(config);\n      }\n    },\n    [utils.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n      const resolverValue = resolvers[typeName];\n\n      if (resolverValue != null) {\n        const fieldResolve = resolverValue[fieldName];\n\n        if (fieldResolve != null) {\n          const newFieldConfig = { ...fieldConfig\n          };\n\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(newFieldConfig, fieldResolve);\n          }\n\n          return newFieldConfig;\n        }\n      }\n    }\n  });\n\n  if (defaultFieldResolver != null) {\n    schema = utils.mapSchema(schema, {\n      [utils.MapperKind.OBJECT_FIELD]: fieldConfig => ({ ...fieldConfig,\n        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver\n      })\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(field, propertiesObj) {\n  for (const propertyName in propertiesObj) {\n    field[propertyName] = propertiesObj[propertyName];\n  }\n}\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\n\n\nfunction makeExecutableSchema(_ref) {\n  let {\n    typeDefs,\n    resolvers = {},\n    resolverValidationOptions = {},\n    parseOptions = {},\n    inheritResolversFromInterfaces = false,\n    pruningOptions,\n    updateResolversInPlace = false,\n    schemaExtensions\n  } = _ref;\n\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  }\n\n  let schema;\n\n  if (graphql.isSchema(typeDefs)) {\n    schema = typeDefs;\n  } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n    const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, { ...parseOptions,\n      commentDescriptions: true\n    });\n    schema = graphql.buildSchema(mergedTypeDefs, parseOptions);\n  } else {\n    const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, parseOptions);\n    schema = graphql.buildASTSchema(mergedTypeDefs, parseOptions);\n  }\n\n  if (pruningOptions) {\n    schema = utils.pruneSchema(schema);\n  } // We allow passing in an array of resolver maps, in which case we merge them\n\n\n  schema = addResolversToSchema({\n    schema,\n    resolvers: merge.mergeResolvers(resolvers),\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n    updateResolversInPlace\n  });\n\n  if (Object.keys(resolverValidationOptions).length > 0) {\n    assertResolversPresent(schema, resolverValidationOptions);\n  }\n\n  if (schemaExtensions) {\n    schemaExtensions = merge.mergeExtensions(utils.asArray(schemaExtensions));\n    merge.applyExtensions(schema, schemaExtensions);\n  }\n\n  return schema;\n}\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\n\n\nfunction mergeSchemas(config) {\n  const extractedTypeDefs = utils.asArray(config.typeDefs || []);\n  const extractedResolvers = utils.asArray(config.resolvers || []);\n  const extractedSchemaExtensions = utils.asArray(config.schemaExtensions || []);\n  const schemas = config.schemas || [];\n\n  for (const schema of schemas) {\n    extractedTypeDefs.push(schema);\n    extractedResolvers.push(utils.getResolversFromSchema(schema));\n    extractedSchemaExtensions.push(merge.extractExtensionsFromSchema(schema));\n  }\n\n  return makeExecutableSchema({\n    parseOptions: config,\n    ...config,\n    typeDefs: extractedTypeDefs,\n    resolvers: extractedResolvers,\n    schemaExtensions: extractedSchemaExtensions\n  });\n}\n\nexports.addResolversToSchema = addResolversToSchema;\nexports.assertResolversPresent = assertResolversPresent;\nexports.chainResolvers = chainResolvers;\nexports.checkForResolveTypeResolver = checkForResolveTypeResolver;\nexports.extendResolversFromInterfaces = extendResolversFromInterfaces;\nexports.makeExecutableSchema = makeExecutableSchema;\nexports.mergeSchemas = mergeSchemas;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/@graphql-tools/schema/index.js"],"names":["Object","defineProperty","exports","value","graphql","require","utils","merge","assertResolversPresent","schema","resolverValidationOptions","requireResolversForArgs","requireResolversForNonScalar","requireResolversForAllFields","TypeError","forEachField","field","typeName","fieldName","expectResolver","args","length","isScalarType","getNamedType","type","validator","behavior","resolve","message","Error","console","warn","chainResolvers","resolvers","root","ctx","info","reduce","prev","curResolver","defaultFieldResolver","checkForResolveTypeResolver","requireResolversForResolveType","mapSchema","MapperKind","ABSTRACT_TYPE","resolveType","name","undefined","extendResolversFromInterfaces","extendedResolvers","typeMap","getTypeMap","iFace","getInterfaces","startsWith","typeResolvers","addResolversToSchema","schemaOrOptions","legacyInputResolvers","legacyInputValidationOptions","options","isSchema","inputResolvers","inheritResolversFromInterfaces","updateResolversInPlace","requireResolversToMatchSchema","resolverValue","resolverType","getType","isSpecifiedScalarType","substring","isEnumType","values","getValues","some","isUnionType","isObjectType","isInterfaceType","fields","getFields","fieldResolve","addResolversToExistingSchema","createNewSchemaWithResolvers","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","astNode","description","directives","concat","extensionASTNodes","extensions","assign","create","config","toConfig","enumValueConfigMap","GraphQLEnumType","bind","setFieldProperties","forEachDefaultValue","serializeInputValue","healSchema","parseInputValue","SCALAR_TYPE","GraphQLScalarType","ENUM_TYPE","UNION_TYPE","GraphQLUnionType","OBJECT_TYPE","isTypeOf","GraphQLObjectType","INTERFACE_TYPE","GraphQLInterfaceType","COMPOSITE_FIELD","fieldConfig","newFieldConfig","OBJECT_FIELD","propertiesObj","propertyName","makeExecutableSchema","typeDefs","parseOptions","pruningOptions","schemaExtensions","commentDescriptions","mergedTypeDefs","mergeTypeDefs","buildSchema","buildASTSchema","pruneSchema","mergeResolvers","keys","mergeExtensions","asArray","applyExtensions","mergeSchemas","extractedTypeDefs","extractedResolvers","extractedSchemaExtensions","schemas","push","getResolversFromSchema","extractExtensionsFromSchema"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst graphql = require('graphql');\nconst utils = require('@graphql-tools/utils');\nconst merge = require('@graphql-tools/merge');\n\nfunction assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    utils.forEachField(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar !== 'ignore' && !graphql.isScalarType(graphql.getNamedType(field.type))) {\n            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n    if (!field.resolve) {\n        const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n        if (behavior === 'error') {\n            throw new Error(message);\n        }\n        if (behavior === 'warn') {\n            // eslint-disable-next-line no-console\n            console.warn(message);\n        }\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n\nfunction chainResolvers(resolvers) {\n    return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n        if (curResolver != null) {\n            return curResolver(prev, args, ctx, info);\n        }\n        return graphql.defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n\n// If we have any union or interface types throw if no there is no resolveType resolver\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    utils.mapSchema(schema, {\n        [utils.MapperKind.ABSTRACT_TYPE]: type => {\n            if (!type.resolveType) {\n                const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` +\n                    '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n                if (requireResolversForResolveType === 'error') {\n                    throw new Error(message);\n                }\n                if (requireResolversForResolveType === 'warn') {\n                    // eslint-disable-next-line no-console\n                    console.warn(message);\n                }\n            }\n            return undefined;\n        },\n    });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n    const extendedResolvers = {};\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if ('getInterfaces' in type) {\n            extendedResolvers[typeName] = {};\n            for (const iFace of type.getInterfaces()) {\n                if (resolvers[iFace.name]) {\n                    for (const fieldName in resolvers[iFace.name]) {\n                        if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n                        }\n                    }\n                }\n            }\n            const typeResolvers = resolvers[typeName];\n            extendedResolvers[typeName] = {\n                ...extendedResolvers[typeName],\n                ...typeResolvers,\n            };\n        }\n        else {\n            const typeResolvers = resolvers[typeName];\n            if (typeResolvers != null) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    }\n    return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n    const options = graphql.isSchema(schemaOrOptions)\n        ? {\n            schema: schemaOrOptions,\n            resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},\n            resolverValidationOptions: legacyInputValidationOptions,\n        }\n        : schemaOrOptions;\n    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, } = options;\n    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    for (const typeName in resolvers) {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (resolverType !== 'object') {\n            throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n        }\n        const type = schema.getType(typeName);\n        if (type == null) {\n            if (requireResolversToMatchSchema === 'ignore') {\n                break;\n            }\n            throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n        }\n        else if (graphql.isSpecifiedScalarType(type)) {\n            // allow -- without recommending -- overriding of specified scalar types\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (graphql.isEnumType(type)) {\n            const values = type.getValues();\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    !values.some(value => value.name === fieldName) &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n                }\n            }\n        }\n        else if (graphql.isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n                }\n            }\n        }\n        else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__')) {\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field == null) {\n                        // Field present in resolver but not in schema\n                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n                        }\n                    }\n                    else {\n                        // Field present in both the resolver and schema\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n        checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    }\n    return schema;\n}\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n    const typeMap = schema.getTypeMap();\n    for (const typeName in resolvers) {\n        const type = schema.getType(typeName);\n        const resolverValue = resolvers[typeName];\n        if (graphql.isScalarType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && type.astNode != null) {\n                    type.astNode = {\n                        ...type.astNode,\n                        description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.astNode.description,\n                        directives: ((_d = type.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                    type.extensionASTNodes = type.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (graphql.isEnumType(type)) {\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    config[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && config.astNode != null) {\n                    config.astNode = {\n                        ...config.astNode,\n                        description: (_m = (_l = (_k = resolverValue) === null || _k === void 0 ? void 0 : _k.astNode) === null || _l === void 0 ? void 0 : _l.description) !== null && _m !== void 0 ? _m : config.astNode.description,\n                        directives: ((_o = config.astNode.directives) !== null && _o !== void 0 ? _o : []).concat((_r = (_q = (_p = resolverValue) === null || _p === void 0 ? void 0 : _p.astNode) === null || _q === void 0 ? void 0 : _q.directives) !== null && _r !== void 0 ? _r : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                    config.extensionASTNodes = config.extensionASTNodes.concat((_t = (_s = resolverValue) === null || _s === void 0 ? void 0 : _s.extensionASTNodes) !== null && _t !== void 0 ? _t : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else if (enumValueConfigMap[fieldName]) {\n                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                }\n            }\n            typeMap[typeName] = new graphql.GraphQLEnumType(config);\n        }\n        else if (graphql.isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    // this is for isTypeOf and resolveType and all the other stuff.\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                    break;\n                }\n                const fields = type.getFields();\n                const field = fields[fieldName];\n                if (field != null) {\n                    const fieldResolve = resolverValue[fieldName];\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        field.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(field, fieldResolve);\n                    }\n                }\n            }\n        }\n    }\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    utils.forEachDefaultValue(schema, utils.serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    utils.healSchema(schema);\n    // reparse all default values with new parsing functions.\n    utils.forEachDefaultValue(schema, utils.parseInputValue);\n    if (defaultFieldResolver != null) {\n        utils.forEachField(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = utils.mapSchema(schema, {\n        [utils.MapperKind.SCALAR_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!graphql.isSpecifiedScalarType(type) && resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                }\n                return new graphql.GraphQLScalarType(config);\n            }\n        },\n        [utils.MapperKind.ENUM_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                }\n                return new graphql.GraphQLEnumType(config);\n            }\n        },\n        [utils.MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql.GraphQLUnionType(config);\n            }\n        },\n        [utils.MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__isTypeOf']) {\n                    config.isTypeOf = resolverValue['__isTypeOf'];\n                }\n                return new graphql.GraphQLObjectType(config);\n            }\n        },\n        [utils.MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql.GraphQLInterfaceType(config);\n            }\n        },\n        [utils.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = utils.mapSchema(schema, {\n            [utils.MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    for (const propertyName in propertiesObj) {\n        field[propertyName] = propertiesObj[propertyName];\n    }\n}\n\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions, }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    let schema;\n    if (graphql.isSchema(typeDefs)) {\n        schema = typeDefs;\n    }\n    else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n        const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, {\n            ...parseOptions,\n            commentDescriptions: true,\n        });\n        schema = graphql.buildSchema(mergedTypeDefs, parseOptions);\n    }\n    else {\n        const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, parseOptions);\n        schema = graphql.buildASTSchema(mergedTypeDefs, parseOptions);\n    }\n    if (pruningOptions) {\n        schema = utils.pruneSchema(schema);\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    schema = addResolversToSchema({\n        schema,\n        resolvers: merge.mergeResolvers(resolvers),\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n    });\n    if (Object.keys(resolverValidationOptions).length > 0) {\n        assertResolversPresent(schema, resolverValidationOptions);\n    }\n    if (schemaExtensions) {\n        schemaExtensions = merge.mergeExtensions(utils.asArray(schemaExtensions));\n        merge.applyExtensions(schema, schemaExtensions);\n    }\n    return schema;\n}\n\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nfunction mergeSchemas(config) {\n    const extractedTypeDefs = utils.asArray(config.typeDefs || []);\n    const extractedResolvers = utils.asArray(config.resolvers || []);\n    const extractedSchemaExtensions = utils.asArray(config.schemaExtensions || []);\n    const schemas = config.schemas || [];\n    for (const schema of schemas) {\n        extractedTypeDefs.push(schema);\n        extractedResolvers.push(utils.getResolversFromSchema(schema));\n        extractedSchemaExtensions.push(merge.extractExtensionsFromSchema(schema));\n    }\n    return makeExecutableSchema({\n        parseOptions: config,\n        ...config,\n        typeDefs: extractedTypeDefs,\n        resolvers: extractedResolvers,\n        schemaExtensions: extractedSchemaExtensions,\n    });\n}\n\nexports.addResolversToSchema = addResolversToSchema;\nexports.assertResolversPresent = assertResolversPresent;\nexports.chainResolvers = chainResolvers;\nexports.checkForResolveTypeResolver = checkForResolveTypeResolver;\nexports.extendResolversFromInterfaces = extendResolversFromInterfaces;\nexports.makeExecutableSchema = makeExecutableSchema;\nexports.mergeSchemas = mergeSchemas;\n"]},"metadata":{},"sourceType":"script"}