{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cloneObject = exports.processHTTPRequest = exports.runHttpQuery = exports.throwHttpGraphQLError = exports.isHttpQueryError = exports.HttpQueryError = void 0;\n\nconst apollo_server_env_1 = require(\"apollo-server-env\");\n\nconst graphqlOptions_1 = require(\"./graphqlOptions\");\n\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\n\nconst requestPipeline_1 = require(\"./requestPipeline\");\n\nconst cachePolicy_1 = require(\"./cachePolicy\");\n\nclass HttpQueryError extends Error {\n  constructor(statusCode, message) {\n    let isGraphQLError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let headers = arguments.length > 3 ? arguments[3] : undefined;\n    super(message);\n    this.name = 'HttpQueryError';\n    this.statusCode = statusCode;\n    this.isGraphQLError = isGraphQLError;\n    this.headers = headers;\n  }\n\n}\n\nexports.HttpQueryError = HttpQueryError;\n\nfunction isHttpQueryError(e) {\n  var _a;\n\n  return ((_a = e) === null || _a === void 0 ? void 0 : _a.name) === 'HttpQueryError';\n}\n\nexports.isHttpQueryError = isHttpQueryError;\n\nfunction throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {\n  const allHeaders = {\n    'Content-Type': 'application/json'\n  };\n\n  if (headers) {\n    for (const [name, value] of headers) {\n      allHeaders[name] = value;\n    }\n  }\n\n  const result = {\n    errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {\n      debug: options.debug,\n      formatter: options.formatError\n    }) : errors\n  };\n\n  if (extensions) {\n    result.extensions = extensions;\n  }\n\n  throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);\n}\n\nexports.throwHttpGraphQLError = throwHttpGraphQLError;\nconst NODE_ENV = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : '';\n\nasync function runHttpQuery(handlerArguments, request) {\n  function debugFromNodeEnv() {\n    let nodeEnv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NODE_ENV;\n    return nodeEnv !== 'production' && nodeEnv !== 'test';\n  }\n\n  let options;\n\n  try {\n    options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);\n  } catch (e) {\n    return throwHttpGraphQLError(500, [e], {\n      debug: debugFromNodeEnv()\n    });\n  }\n\n  if (options.debug === undefined) {\n    options.debug = debugFromNodeEnv(options.nodeEnv);\n  }\n\n  if (typeof options.context === 'function') {\n    try {\n      options.context();\n    } catch (e) {\n      e.message = `Context creation failed: ${e.message}`;\n\n      if (e.extensions && e.extensions.code && e.extensions.code !== 'INTERNAL_SERVER_ERROR') {\n        return throwHttpGraphQLError(400, [e], options);\n      } else {\n        return throwHttpGraphQLError(500, [e], options);\n      }\n    }\n  }\n\n  const config = {\n    schema: options.schema,\n    schemaHash: options.schemaHash,\n    logger: options.logger,\n    rootValue: options.rootValue,\n    context: options.context || {},\n    validationRules: options.validationRules,\n    executor: options.executor,\n    fieldResolver: options.fieldResolver,\n    cache: options.cache,\n    dataSources: options.dataSources,\n    documentStore: options.documentStore,\n    persistedQueries: options.persistedQueries,\n    formatError: options.formatError,\n    formatResponse: options.formatResponse,\n    debug: options.debug,\n    plugins: options.plugins || [],\n    allowBatchedHttpRequests: options.allowBatchedHttpRequests\n  };\n  return processHTTPRequest(config, request);\n}\n\nexports.runHttpQuery = runHttpQuery;\n\nasync function processHTTPRequest(options, httpRequest) {\n  var _a, _b;\n\n  let requestPayload;\n\n  switch (httpRequest.method) {\n    case 'POST':\n      if (!httpRequest.query || typeof httpRequest.query === 'string' || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'POST body missing, invalid Content-Type, or JSON object has no keys.');\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n\n    case 'GET':\n      if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'GET query missing.');\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n\n    default:\n      throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {\n        Allow: 'GET, POST'\n      });\n  }\n\n  options = { ...options,\n    plugins: [checkOperationPlugin, ...options.plugins]\n  };\n\n  function buildRequestContext(request) {\n    const context = cloneObject(options.context);\n    return {\n      logger: options.logger || console,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request,\n      response: {\n        http: {\n          headers: new apollo_server_env_1.Headers()\n        }\n      },\n      context,\n      cache: options.cache,\n      debug: options.debug,\n      metrics: {},\n      overallCachePolicy: (0, cachePolicy_1.newCachePolicy)()\n    };\n  }\n\n  const responseInit = {\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n  let body;\n\n  try {\n    if (Array.isArray(requestPayload)) {\n      if (options.allowBatchedHttpRequests === false) {\n        return throwHttpGraphQLError(400, [new Error('Operation batching disabled.')], options);\n      }\n\n      const requests = requestPayload.map(requestParams => parseGraphQLRequest(httpRequest.request, requestParams));\n      const responses = await Promise.all(requests.map(async request => {\n        try {\n          const requestContext = buildRequestContext(request);\n          const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n\n          if (response.http) {\n            for (const [name, value] of response.http.headers) {\n              responseInit.headers[name] = value;\n            }\n\n            if (response.http.status) {\n              responseInit.status = response.http.status;\n            }\n          }\n\n          return response;\n        } catch (error) {\n          return {\n            errors: (0, apollo_server_errors_1.formatApolloErrors)([error], options)\n          };\n        }\n      }));\n      body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n    } else {\n      const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n      const requestContext = buildRequestContext(request);\n      const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n\n      if (response.errors && typeof response.data === 'undefined') {\n        return throwHttpGraphQLError(((_a = response.http) === null || _a === void 0 ? void 0 : _a.status) || 400, response.errors, undefined, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);\n      }\n\n      if (response.http) {\n        for (const [name, value] of response.http.headers) {\n          responseInit.headers[name] = value;\n        }\n\n        if (response.http.status) {\n          responseInit.status = response.http.status;\n        }\n      }\n\n      body = prettyJSONStringify(serializeGraphQLResponse(response));\n    }\n  } catch (error) {\n    if (error instanceof HttpQueryError) {\n      throw error;\n    }\n\n    return throwHttpGraphQLError(500, [error], options);\n  }\n\n  responseInit.headers['Content-Length'] = Buffer.byteLength(body, 'utf8').toString();\n  return {\n    graphqlResponse: body,\n    responseInit\n  };\n}\n\nexports.processHTTPRequest = processHTTPRequest;\n\nfunction parseGraphQLRequest(httpRequest, requestParams) {\n  let queryString = requestParams.query;\n  let extensions = requestParams.extensions;\n\n  if (typeof extensions === 'string' && extensions !== '') {\n    try {\n      extensions = JSON.parse(extensions);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n    }\n  }\n\n  if (queryString && typeof queryString !== 'string') {\n    if (queryString.kind === 'Document') {\n      throw new HttpQueryError(400, \"GraphQL queries must be strings. It looks like you're sending the \" + 'internal graphql-js representation of a parsed query in your ' + 'request instead of a request in the GraphQL query language. You ' + 'can convert an AST to a string using the `print` function from ' + '`graphql`, or use a client like `apollo-client` which converts ' + 'the internal representation to a string for you.');\n    } else {\n      throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n    }\n  }\n\n  const operationName = requestParams.operationName;\n  let variables = requestParams.variables;\n\n  if (typeof variables === 'string' && variables !== '') {\n    try {\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Variables are invalid JSON.');\n    }\n  }\n\n  return {\n    query: queryString,\n    operationName,\n    variables,\n    extensions,\n    http: httpRequest\n  };\n}\n\nconst checkOperationPlugin = {\n  async requestDidStart() {\n    return {\n      async didResolveOperation(_ref) {\n        let {\n          request,\n          operation\n        } = _ref;\n        if (!request.http) return;\n\n        if (request.http.method === 'GET' && operation.operation !== 'query') {\n          throw new HttpQueryError(405, `GET supports only query operation`, false, {\n            Allow: 'POST'\n          });\n        }\n      }\n\n    };\n  }\n\n};\n\nfunction serializeGraphQLResponse(response) {\n  return {\n    errors: response.errors,\n    data: response.data,\n    extensions: response.extensions\n  };\n}\n\nfunction prettyJSONStringify(value) {\n  return JSON.stringify(value) + '\\n';\n}\n\nfunction cloneObject(object) {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n\nexports.cloneObject = cloneObject;","map":{"version":3,"sources":["../src/runHttpQuery.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cloneObject = exports.processHTTPRequest = exports.runHttpQuery = exports.throwHttpGraphQLError = exports.isHttpQueryError = exports.HttpQueryError = void 0;\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst graphqlOptions_1 = require(\"./graphqlOptions\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst requestPipeline_1 = require(\"./requestPipeline\");\nconst cachePolicy_1 = require(\"./cachePolicy\");\nclass HttpQueryError extends Error {\n    constructor(statusCode, message, isGraphQLError = false, headers) {\n        super(message);\n        this.name = 'HttpQueryError';\n        this.statusCode = statusCode;\n        this.isGraphQLError = isGraphQLError;\n        this.headers = headers;\n    }\n}\nexports.HttpQueryError = HttpQueryError;\nfunction isHttpQueryError(e) {\n    var _a;\n    return ((_a = e) === null || _a === void 0 ? void 0 : _a.name) === 'HttpQueryError';\n}\nexports.isHttpQueryError = isHttpQueryError;\nfunction throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {\n    const allHeaders = {\n        'Content-Type': 'application/json',\n    };\n    if (headers) {\n        for (const [name, value] of headers) {\n            allHeaders[name] = value;\n        }\n    }\n    const result = {\n        errors: options\n            ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {\n                debug: options.debug,\n                formatter: options.formatError,\n            })\n            : errors,\n    };\n    if (extensions) {\n        result.extensions = extensions;\n    }\n    throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);\n}\nexports.throwHttpGraphQLError = throwHttpGraphQLError;\nconst NODE_ENV = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : '';\nasync function runHttpQuery(handlerArguments, request) {\n    function debugFromNodeEnv(nodeEnv = NODE_ENV) {\n        return nodeEnv !== 'production' && nodeEnv !== 'test';\n    }\n    let options;\n    try {\n        options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);\n    }\n    catch (e) {\n        return throwHttpGraphQLError(500, [e], {\n            debug: debugFromNodeEnv(),\n        });\n    }\n    if (options.debug === undefined) {\n        options.debug = debugFromNodeEnv(options.nodeEnv);\n    }\n    if (typeof options.context === 'function') {\n        try {\n            options.context();\n        }\n        catch (e) {\n            e.message = `Context creation failed: ${e.message}`;\n            if (e.extensions &&\n                e.extensions.code &&\n                e.extensions.code !== 'INTERNAL_SERVER_ERROR') {\n                return throwHttpGraphQLError(400, [e], options);\n            }\n            else {\n                return throwHttpGraphQLError(500, [e], options);\n            }\n        }\n    }\n    const config = {\n        schema: options.schema,\n        schemaHash: options.schemaHash,\n        logger: options.logger,\n        rootValue: options.rootValue,\n        context: options.context || {},\n        validationRules: options.validationRules,\n        executor: options.executor,\n        fieldResolver: options.fieldResolver,\n        cache: options.cache,\n        dataSources: options.dataSources,\n        documentStore: options.documentStore,\n        persistedQueries: options.persistedQueries,\n        formatError: options.formatError,\n        formatResponse: options.formatResponse,\n        debug: options.debug,\n        plugins: options.plugins || [],\n        allowBatchedHttpRequests: options.allowBatchedHttpRequests,\n    };\n    return processHTTPRequest(config, request);\n}\nexports.runHttpQuery = runHttpQuery;\nasync function processHTTPRequest(options, httpRequest) {\n    var _a, _b;\n    let requestPayload;\n    switch (httpRequest.method) {\n        case 'POST':\n            if (!httpRequest.query ||\n                typeof httpRequest.query === 'string' ||\n                Buffer.isBuffer(httpRequest.query) ||\n                Object.keys(httpRequest.query).length === 0) {\n                throw new HttpQueryError(400, 'POST body missing, invalid Content-Type, or JSON object has no keys.');\n            }\n            requestPayload = httpRequest.query;\n            break;\n        case 'GET':\n            if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n                throw new HttpQueryError(400, 'GET query missing.');\n            }\n            requestPayload = httpRequest.query;\n            break;\n        default:\n            throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {\n                Allow: 'GET, POST',\n            });\n    }\n    options = {\n        ...options,\n        plugins: [checkOperationPlugin, ...options.plugins],\n    };\n    function buildRequestContext(request) {\n        const context = cloneObject(options.context);\n        return {\n            logger: options.logger || console,\n            schema: options.schema,\n            schemaHash: options.schemaHash,\n            request,\n            response: {\n                http: {\n                    headers: new apollo_server_env_1.Headers(),\n                },\n            },\n            context,\n            cache: options.cache,\n            debug: options.debug,\n            metrics: {},\n            overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),\n        };\n    }\n    const responseInit = {\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    };\n    let body;\n    try {\n        if (Array.isArray(requestPayload)) {\n            if (options.allowBatchedHttpRequests === false) {\n                return throwHttpGraphQLError(400, [new Error('Operation batching disabled.')], options);\n            }\n            const requests = requestPayload.map((requestParams) => parseGraphQLRequest(httpRequest.request, requestParams));\n            const responses = await Promise.all(requests.map(async (request) => {\n                try {\n                    const requestContext = buildRequestContext(request);\n                    const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n                    if (response.http) {\n                        for (const [name, value] of response.http.headers) {\n                            responseInit.headers[name] = value;\n                        }\n                        if (response.http.status) {\n                            responseInit.status = response.http.status;\n                        }\n                    }\n                    return response;\n                }\n                catch (error) {\n                    return {\n                        errors: (0, apollo_server_errors_1.formatApolloErrors)([error], options),\n                    };\n                }\n            }));\n            body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n        }\n        else {\n            const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n            const requestContext = buildRequestContext(request);\n            const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n            if (response.errors && typeof response.data === 'undefined') {\n                return throwHttpGraphQLError(((_a = response.http) === null || _a === void 0 ? void 0 : _a.status) || 400, response.errors, undefined, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);\n            }\n            if (response.http) {\n                for (const [name, value] of response.http.headers) {\n                    responseInit.headers[name] = value;\n                }\n                if (response.http.status) {\n                    responseInit.status = response.http.status;\n                }\n            }\n            body = prettyJSONStringify(serializeGraphQLResponse(response));\n        }\n    }\n    catch (error) {\n        if (error instanceof HttpQueryError) {\n            throw error;\n        }\n        return throwHttpGraphQLError(500, [error], options);\n    }\n    responseInit.headers['Content-Length'] = Buffer.byteLength(body, 'utf8').toString();\n    return {\n        graphqlResponse: body,\n        responseInit,\n    };\n}\nexports.processHTTPRequest = processHTTPRequest;\nfunction parseGraphQLRequest(httpRequest, requestParams) {\n    let queryString = requestParams.query;\n    let extensions = requestParams.extensions;\n    if (typeof extensions === 'string' && extensions !== '') {\n        try {\n            extensions = JSON.parse(extensions);\n        }\n        catch (error) {\n            throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n        }\n    }\n    if (queryString && typeof queryString !== 'string') {\n        if (queryString.kind === 'Document') {\n            throw new HttpQueryError(400, \"GraphQL queries must be strings. It looks like you're sending the \" +\n                'internal graphql-js representation of a parsed query in your ' +\n                'request instead of a request in the GraphQL query language. You ' +\n                'can convert an AST to a string using the `print` function from ' +\n                '`graphql`, or use a client like `apollo-client` which converts ' +\n                'the internal representation to a string for you.');\n        }\n        else {\n            throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n        }\n    }\n    const operationName = requestParams.operationName;\n    let variables = requestParams.variables;\n    if (typeof variables === 'string' && variables !== '') {\n        try {\n            variables = JSON.parse(variables);\n        }\n        catch (error) {\n            throw new HttpQueryError(400, 'Variables are invalid JSON.');\n        }\n    }\n    return {\n        query: queryString,\n        operationName,\n        variables,\n        extensions,\n        http: httpRequest,\n    };\n}\nconst checkOperationPlugin = {\n    async requestDidStart() {\n        return {\n            async didResolveOperation({ request, operation }) {\n                if (!request.http)\n                    return;\n                if (request.http.method === 'GET' && operation.operation !== 'query') {\n                    throw new HttpQueryError(405, `GET supports only query operation`, false, {\n                        Allow: 'POST',\n                    });\n                }\n            },\n        };\n    },\n};\nfunction serializeGraphQLResponse(response) {\n    return {\n        errors: response.errors,\n        data: response.data,\n        extensions: response.extensions,\n    };\n}\nfunction prettyJSONStringify(value) {\n    return JSON.stringify(value) + '\\n';\n}\nfunction cloneObject(object) {\n    return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\nexports.cloneObject = cloneObject;\n//# sourceMappingURL=runHttpQuery.js.map"]},"metadata":{},"sourceType":"script"}