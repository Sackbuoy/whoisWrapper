{"ast":null,"code":"'use strict';\n\nconst {\n  Headers,\n  HeadersList,\n  fill\n} = require('./headers');\n\nconst {\n  extractBody,\n  cloneBody,\n  mixinBody\n} = require('./body');\n\nconst util = require('../core/util');\n\nconst {\n  kEnumerableProperty\n} = util;\n\nconst {\n  responseURL,\n  isValidReasonPhrase,\n  toUSVString\n} = require('./util');\n\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  forbiddenHeaderNames\n} = require('./constants');\n\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst assert = require('assert'); // https://fetch.spec.whatwg.org/#response-class\n\n\nclass Response {\n  // Creates network error Response.\n  static error() {\n    // TODO\n    const relevantRealm = {\n      settingsObject: {}\n    }; // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n\n    const responseObject = new Response();\n    responseObject[kState] = makeNetworkError();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n    return responseObject;\n  } // Creates a redirect Response that redirects to url with status status.\n\n\n  static redirect() {\n    const relevantRealm = {\n      settingsObject: {}\n    };\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    const status = arguments.length >= 2 ? arguments.length <= 1 ? undefined : arguments[1] : 302;\n    const url = toUSVString(arguments.length <= 0 ? undefined : arguments[0]); // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n\n    let parsedURL;\n\n    try {\n      parsedURL = new URL(url);\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      });\n    } // 3. If status is not a redirect status, then throw a RangeError.\n\n\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code');\n    } // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n\n\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm; // 5. Set responseObject’s response’s status to status.\n\n    responseObject[kState].status = status; // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n\n    const value = parsedURL.toString(); // 7. Append `Location`/value to responseObject’s response’s header list.\n\n    responseObject[kState].headersList.push('location', value); // 8. Return responseObject.\n\n    return responseObject;\n  } // https://fetch.spec.whatwg.org/#dom-response\n\n\n  constructor() {\n    if (arguments.length >= 1 && typeof (arguments.length <= 1 ? undefined : arguments[1]) !== 'object' && (arguments.length <= 1 ? undefined : arguments[1]) !== undefined) {\n      throw new TypeError(\"Failed to construct 'Request': cannot convert to dictionary.\");\n    }\n\n    const body = arguments.length >= 1 ? arguments.length <= 0 ? undefined : arguments[0] : null;\n    const init = arguments.length >= 2 ? (arguments.length <= 1 ? undefined : arguments[1]) ?? {} : {}; // TODO\n\n    this[kRealm] = {\n      settingsObject: {}\n    }; // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    // throw a RangeError.\n\n    if ('status' in init && init.status !== undefined) {\n      if (!Number.isFinite(init.status)) {\n        throw new TypeError();\n      }\n\n      if (init.status < 200 || init.status > 599) {\n        throw new RangeError(`Failed to construct 'Response': The status provided (${init.status}) is outside the range [200, 599].`);\n      }\n    }\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      // 2. If init[\"statusText\"] does not match the reason-phrase token\n      // production, then throw a TypeError.\n      // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n      //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n      if (!isValidReasonPhrase(String(init.statusText))) {\n        throw new TypeError('Invalid statusText');\n      }\n    } // 3. Set this’s response to a new response.\n\n\n    this[kState] = makeResponse({}); // 4. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'response';\n    this[kHeaders][kHeadersList] = this[kState].headersList;\n    this[kHeaders][kRealm] = this[kRealm]; // 5. Set this’s response’s status to init[\"status\"].\n\n    if ('status' in init && init.status !== undefined) {\n      this[kState].status = init.status;\n    } // 6. Set this’s response’s status message to init[\"statusText\"].\n\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      this[kState].statusText = String(init.statusText);\n    } // 7. If init[\"headers\"] exists, then fill this’s headers with init[\"headers\"].\n\n\n    if ('headers' in init) {\n      fill(this[kState].headersList, init.headers);\n    } // 8. If body is non-null, then:\n\n\n    if (body != null) {\n      // 1. If init[\"status\"] is a null body status, then throw a TypeError.\n      if (nullBodyStatus.includes(init.status)) {\n        throw new TypeError('Response with null body status cannot have body');\n      } // 2. Let Content-Type be null.\n      // 3. Set this’s response’s body and Content-Type to the result of\n      // extracting body.\n\n\n      const [extractedBody, contentType] = extractBody(body);\n      this[kState].body = extractedBody; // 4. If Content-Type is non-null and this’s response’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type\n      // to this’s response’s header list.\n\n      if (contentType && !this.headers.has('content-type')) {\n        this.headers.set('content-type', contentType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this.constructor.name;\n  } // Returns response’s type, e.g., \"cors\".\n\n\n  get type() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The type getter steps are to return this’s response’s type.\n\n\n    return this[kState].type;\n  } // Returns response’s URL, if it has one; otherwise the empty string.\n\n\n  get url() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n\n\n    let url = responseURL(this[kState]);\n\n    if (url == null) {\n      return '';\n    }\n\n    if (url.hash) {\n      url = new URL(url);\n      url.hash = '';\n    }\n\n    return url.toString();\n  } // Returns whether response was obtained through a redirect.\n\n\n  get redirected() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n\n\n    return this[kState].urlList.length > 1;\n  } // Returns response’s status.\n\n\n  get status() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The status getter steps are to return this’s response’s status.\n\n\n    return this[kState].status;\n  } // Returns whether response’s status is an ok status.\n\n\n  get ok() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n\n\n    return this[kState].status >= 200 && this[kState].status <= 299;\n  } // Returns response’s status message.\n\n\n  get statusText() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The statusText getter steps are to return this’s response’s status\n    // message.\n\n\n    return this[kState].statusText;\n  } // Returns response’s headers as Headers.\n\n\n  get headers() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The headers getter steps are to return this’s headers.\n\n\n    return this[kHeaders];\n  } // Returns a clone of response.\n\n\n  clone() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // 1. If this is unusable, then throw a TypeError.\n\n\n    if (this.bodyUsed || this.body && this.body.locked) {\n      throw new TypeError();\n    } // 2. Let clonedResponse be the result of cloning this’s response.\n\n\n    const clonedResponse = cloneResponse(this[kState]); // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n\n    const clonedResponseObject = new Response();\n    clonedResponseObject[kState] = clonedResponse;\n    clonedResponseObject[kRealm] = this[kRealm];\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n    return clonedResponseObject;\n  }\n\n}\n\nmixinBody(Response.prototype);\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n}); // https://fetch.spec.whatwg.org/#concept-response-clone\n\nfunction cloneResponse(response) {\n  // To clone a response response, run these steps:\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(cloneResponse(response.internalResponse), response.type);\n  } // 2. Let newResponse be a copy of response, except for its body.\n\n\n  const newResponse = makeResponse({ ...response,\n    body: null\n  }); // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n\n  if (response.body !== null) {\n    newResponse.body = cloneBody(response.body);\n  } // 4. Return newResponse.\n\n\n  return newResponse;\n}\n\nfunction makeResponse(init) {\n  return {\n    internalResponse: null,\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList ? new HeadersList(...init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  };\n}\n\nfunction makeNetworkError(reason) {\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: reason instanceof Error ? reason : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  });\n}\n\nfunction filterResponse(response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n    const headers = [];\n\n    for (let n = 0; n < response.headersList.length; n += 2) {\n      if (!forbiddenHeaderNames.includes(response.headersList[n])) {\n        headers.push(response.headersList[n + 0], response.headersList[n + 1]);\n      }\n    }\n\n    return makeResponse({ ...response,\n      internalResponse: response,\n      headersList: new HeadersList(...headers),\n      type: 'basic'\n    });\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n    // TODO: This is not correct...\n    return makeResponse({ ...response,\n      internalResponse: response,\n      type: 'cors'\n    });\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n    return makeResponse({ ...response,\n      internalResponse: response,\n      type: 'opaque',\n      urlList: [],\n      status: 0,\n      statusText: '',\n      body: null\n    });\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n    return makeResponse({ ...response,\n      internalResponse: response,\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: new HeadersList(),\n      body: null\n    });\n  } else {\n    assert(false);\n  }\n}\n\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  filterResponse,\n  Response\n};","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/fetch/response.js"],"names":["Headers","HeadersList","fill","require","extractBody","cloneBody","mixinBody","util","kEnumerableProperty","responseURL","isValidReasonPhrase","toUSVString","redirectStatus","nullBodyStatus","forbiddenHeaderNames","kState","kHeaders","kGuard","kRealm","kHeadersList","assert","Response","error","relevantRealm","settingsObject","responseObject","makeNetworkError","headersList","redirect","length","TypeError","status","url","parsedURL","URL","err","Object","assign","cause","includes","RangeError","value","toString","push","constructor","undefined","body","init","Number","isFinite","statusText","String","makeResponse","headers","extractedBody","contentType","has","set","Symbol","toStringTag","name","type","hash","redirected","urlList","ok","clone","bodyUsed","locked","clonedResponse","cloneResponse","clonedResponseObject","prototype","defineProperties","response","internalResponse","filterResponse","newResponse","aborted","rangeRequested","timingAllowPassed","timingInfo","cacheState","reason","Error","n","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill } = require('./headers')\nconst { extractBody, cloneBody, mixinBody } = require('./body')\nconst util = require('../core/util')\nconst { kEnumerableProperty } = util\nconst { responseURL, isValidReasonPhrase, toUSVString } = require('./util')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  forbiddenHeaderNames\n} = require('./constants')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (...args) {\n    const relevantRealm = { settingsObject: {} }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const status = args.length >= 2 ? args[1] : 302\n    const url = toUSVString(args[0])\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url)\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code')\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n    const value = parsedURL.toString()\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.push('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (...args) {\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n\n    const body = args.length >= 1 ? args[0] : null\n    const init = args.length >= 2 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    // throw a RangeError.\n    if ('status' in init && init.status !== undefined) {\n      if (!Number.isFinite(init.status)) {\n        throw new TypeError()\n      }\n\n      if (init.status < 200 || init.status > 599) {\n        throw new RangeError(\n          `Failed to construct 'Response': The status provided (${init.status}) is outside the range [200, 599].`\n        )\n      }\n    }\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      // 2. If init[\"statusText\"] does not match the reason-phrase token\n      // production, then throw a TypeError.\n      // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n      //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n      if (!isValidReasonPhrase(String(init.statusText))) {\n        throw new TypeError('Invalid statusText')\n      }\n    }\n\n    // 3. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 4. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 5. Set this’s response’s status to init[\"status\"].\n    if ('status' in init && init.status !== undefined) {\n      this[kState].status = init.status\n    }\n\n    // 6. Set this’s response’s status message to init[\"statusText\"].\n    if ('statusText' in init && init.statusText !== undefined) {\n      this[kState].statusText = String(init.statusText)\n    }\n\n    // 7. If init[\"headers\"] exists, then fill this’s headers with init[\"headers\"].\n    if ('headers' in init) {\n      fill(this[kState].headersList, init.headers)\n    }\n\n    // 8. If body is non-null, then:\n    if (body != null) {\n      // 1. If init[\"status\"] is a null body status, then throw a TypeError.\n      if (nullBodyStatus.includes(init.status)) {\n        throw new TypeError('Response with null body status cannot have body')\n      }\n\n      // 2. Let Content-Type be null.\n      // 3. Set this’s response’s body and Content-Type to the result of\n      // extracting body.\n      const [extractedBody, contentType] = extractBody(body)\n      this[kState].body = extractedBody\n\n      // 4. If Content-Type is non-null and this’s response’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type\n      // to this’s response’s header list.\n      if (contentType && !this.headers.has('content-type')) {\n        this.headers.set('content-type', contentType)\n      }\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    let url = responseURL(this[kState])\n\n    if (url == null) {\n      return ''\n    }\n\n    if (url.hash) {\n      url = new URL(url)\n      url.hash = ''\n    }\n\n    return url.toString()\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns a clone of response.\n  clone () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError()\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\nmixinBody(Response.prototype)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body !== null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    internalResponse: null,\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error:\n      reason instanceof Error\n        ? reason\n        : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    const headers = []\n    for (let n = 0; n < response.headersList.length; n += 2) {\n      if (!forbiddenHeaderNames.includes(response.headersList[n])) {\n        headers.push(response.headersList[n + 0], response.headersList[n + 1])\n      }\n    }\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      headersList: new HeadersList(...headers),\n      type: 'basic'\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // TODO: This is not correct...\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'cors'\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaque',\n      urlList: [],\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: new HeadersList(),\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\nmodule.exports = { makeNetworkError, makeResponse, filterResponse, Response }\n"]},"metadata":{},"sourceType":"script"}