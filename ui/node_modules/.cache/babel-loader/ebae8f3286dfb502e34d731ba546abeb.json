{"ast":null,"code":"'use strict';\n\nconst {\n  promisify\n} = require('util');\n\nconst Pool = require('../pool');\n\nconst {\n  buildMockDispatch\n} = require('./mock-utils');\n\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = require('./mock-symbols');\n\nconst {\n  MockInterceptor\n} = require('./mock-interceptor');\n\nconst Symbols = require('../core/symbols');\n\nconst {\n  InvalidArgumentError\n} = require('../core/errors');\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\n\n\nclass MockPool extends Pool {\n  constructor(origin, opts) {\n    super(origin, opts);\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent');\n    }\n\n    this[kMockAgent] = opts.agent;\n    this[kOrigin] = origin;\n    this[kDispatches] = [];\n    this[kConnected] = 1;\n    this[kOriginalDispatch] = this.dispatch;\n    this[kOriginalClose] = this.close.bind(this);\n    this.dispatch = buildMockDispatch.call(this);\n    this.close = this[kClose];\n  }\n\n  get [Symbols.kConnected]() {\n    return this[kConnected];\n  }\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n\n\n  intercept(opts) {\n    return new MockInterceptor(opts, this[kDispatches]);\n  }\n\n  async [kClose]() {\n    await promisify(this[kOriginalClose])();\n    this[kConnected] = 0;\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n  }\n\n}\n\nmodule.exports = MockPool;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/mock/mock-pool.js"],"names":["promisify","require","Pool","buildMockDispatch","kDispatches","kMockAgent","kClose","kOriginalClose","kOrigin","kOriginalDispatch","kConnected","MockInterceptor","Symbols","InvalidArgumentError","MockPool","constructor","origin","opts","agent","dispatch","close","bind","call","intercept","kClients","delete","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,MAAD,CAA7B;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,SAAD,CAApB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAwBF,OAAO,CAAC,cAAD,CAArC;;AACA,MAAM;AACJG,EAAAA,WADI;AAEJC,EAAAA,UAFI;AAGJC,EAAAA,MAHI;AAIJC,EAAAA,cAJI;AAKJC,EAAAA,OALI;AAMJC,EAAAA,iBANI;AAOJC,EAAAA;AAPI,IAQFT,OAAO,CAAC,gBAAD,CARX;;AASA,MAAM;AAAEU,EAAAA;AAAF,IAAsBV,OAAO,CAAC,oBAAD,CAAnC;;AACA,MAAMW,OAAO,GAAGX,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAM;AAAEY,EAAAA;AAAF,IAA2BZ,OAAO,CAAC,gBAAD,CAAxC;AAEA;AACA;AACA;;;AACA,MAAMa,QAAN,SAAuBZ,IAAvB,CAA4B;AAC1Ba,EAAAA,WAAW,CAAEC,MAAF,EAAUC,IAAV,EAAgB;AACzB,UAAMD,MAAN,EAAcC,IAAd;;AAEA,QAAI,CAACA,IAAD,IAAS,CAACA,IAAI,CAACC,KAAf,IAAwB,OAAOD,IAAI,CAACC,KAAL,CAAWC,QAAlB,KAA+B,UAA3D,EAAuE;AACrE,YAAM,IAAIN,oBAAJ,CAAyB,0CAAzB,CAAN;AACD;;AAED,SAAKR,UAAL,IAAmBY,IAAI,CAACC,KAAxB;AACA,SAAKV,OAAL,IAAgBQ,MAAhB;AACA,SAAKZ,WAAL,IAAoB,EAApB;AACA,SAAKM,UAAL,IAAmB,CAAnB;AACA,SAAKD,iBAAL,IAA0B,KAAKU,QAA/B;AACA,SAAKZ,cAAL,IAAuB,KAAKa,KAAL,CAAWC,IAAX,CAAgB,IAAhB,CAAvB;AAEA,SAAKF,QAAL,GAAgBhB,iBAAiB,CAACmB,IAAlB,CAAuB,IAAvB,CAAhB;AACA,SAAKF,KAAL,GAAa,KAAKd,MAAL,CAAb;AACD;;AAEsB,OAAlBM,OAAO,CAACF,UAAU,IAAK;AAC1B,WAAO,KAAKA,UAAL,CAAP;AACD;AAED;AACF;AACA;;;AACEa,EAAAA,SAAS,CAAEN,IAAF,EAAQ;AACf,WAAO,IAAIN,eAAJ,CAAoBM,IAApB,EAA0B,KAAKb,WAAL,CAA1B,CAAP;AACD;;AAEY,SAANE,MAAM,IAAK;AAChB,UAAMN,SAAS,CAAC,KAAKO,cAAL,CAAD,CAAT,EAAN;AACA,SAAKG,UAAL,IAAmB,CAAnB;AACA,SAAKL,UAAL,EAAiBO,OAAO,CAACY,QAAzB,EAAmCC,MAAnC,CAA0C,KAAKjB,OAAL,CAA1C;AACD;;AAlCyB;;AAqC5BkB,MAAM,CAACC,OAAP,GAAiBb,QAAjB","sourcesContent":["'use strict'\n\nconst { promisify } = require('util')\nconst Pool = require('../pool')\nconst { buildMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = require('./mock-symbols')\nconst { MockInterceptor } = require('./mock-interceptor')\nconst Symbols = require('../core/symbols')\nconst { InvalidArgumentError } = require('../core/errors')\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n"]},"metadata":{},"sourceType":"script"}