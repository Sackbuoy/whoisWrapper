{"ast":null,"code":"// https://github.com/Ethan-Arrowood/undici-fetch\n'use strict';\n\nconst {\n  validateHeaderName,\n  validateHeaderValue\n} = require('http');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst {\n  kGuard\n} = require('./symbols');\n\nconst {\n  kEnumerableProperty\n} = require('../core/util');\n\nconst {\n  forbiddenHeaderNames,\n  forbiddenResponseHeaderNames\n} = require('./constants');\n\nfunction binarySearch(arr, val) {\n  let low = 0;\n  let high = Math.floor(arr.length / 2);\n\n  while (high > low) {\n    const mid = high + low >>> 1;\n\n    if (val.localeCompare(arr[mid * 2]) > 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return low * 2;\n}\n\nfunction normalizeAndValidateHeaderName(name) {\n  if (name === undefined) {\n    throw new TypeError(`Header name ${name}`);\n  }\n\n  const normalizedHeaderName = name.toLocaleLowerCase();\n  validateHeaderName(normalizedHeaderName);\n  return normalizedHeaderName;\n}\n\nfunction normalizeAndValidateHeaderValue(name, value) {\n  if (value === undefined) {\n    throw new TypeError(value, name);\n  }\n\n  const normalizedHeaderValue = `${value}`.replace(/^[\\n\\t\\r\\x20]+|[\\n\\t\\r\\x20]+$/g, '');\n  validateHeaderValue(name, normalizedHeaderValue);\n  return normalizedHeaderValue;\n}\n\nfunction fill(headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n  if (object[Symbol.iterator]) {\n    // 1. If object is a sequence, then for each header in object:\n    // TODO: How to check if sequence?\n    for (let header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (!header[Symbol.iterator]) {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError();\n      }\n\n      if (typeof header === 'string') {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError();\n      }\n\n      if (!Array.isArray(header)) {\n        header = [...header];\n      }\n\n      if (header.length !== 2) {\n        throw new TypeError();\n      } // 2. Append header’s first item/header’s second item to headers.\n\n\n      headers.append(header[0], header[1]);\n    }\n  } else if (object && typeof object === 'object') {\n    // Otherwise, object is a record, then for each key → value in object,\n    // append key/value to headers.\n    // TODO: How to check if record?\n    for (const header of Object.entries(object)) {\n      headers.append(header[0], header[1]);\n    }\n  } else {\n    // TODO: Spec doesn't define what to do here?\n    throw TypeError();\n  }\n} // TODO: Composition over inheritence? Or helper methods?\n\n\nclass HeadersList extends Array {\n  append(name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      this[index + 1] += `, ${normalizedValue}`;\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue);\n    }\n  }\n\n  delete(name) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      this.splice(index, 2);\n    }\n  }\n\n  get(name) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      return this[index + 1];\n    }\n\n    return null;\n  }\n\n  has(name) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const index = binarySearch(this, normalizedName);\n    return this[index] === normalizedName;\n  }\n\n  set(name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      this[index + 1] = normalizedValue;\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue);\n    }\n  }\n\n}\n\nclass Headers {\n  constructor() {\n    if ((arguments.length <= 0 ? undefined : arguments[0]) !== undefined && !(typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object' && (arguments.length <= 0 ? undefined : arguments[0]) !== null) && !Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {\n      throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>\");\n    }\n\n    const init = arguments.length >= 1 ? (arguments.length <= 0 ? undefined : arguments[0]) ?? {} : {};\n    this[kHeadersList] = new HeadersList(); // The new Headers(init) constructor steps are:\n    // 1. Set this’s guard to \"none\".\n\n    this[kGuard] = 'none'; // 2. If init is given, then fill this with init.\n\n    fill(this, init);\n  }\n\n  get [Symbol.toStringTag]() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this.constructor.name;\n  }\n\n  toString() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return Object.prototype.toString.call(this);\n  }\n\n  append() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(arguments.length <= 0 ? undefined : arguments[0]));\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request' && forbiddenHeaderNames.includes(normalizedName)) {\n      return;\n    } else if (this[kGuard] === 'request-no-cors') {// TODO\n    } else if (this[kGuard] === 'response' && forbiddenResponseHeaderNames.includes(normalizedName)) {\n      return;\n    }\n\n    return this[kHeadersList].append(String(arguments.length <= 0 ? undefined : arguments[0]), String(arguments.length <= 1 ? undefined : arguments[1]));\n  }\n\n  delete() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(arguments.length <= 0 ? undefined : arguments[0]));\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request' && forbiddenHeaderNames.includes(normalizedName)) {\n      return;\n    } else if (this[kGuard] === 'request-no-cors') {// TODO\n    } else if (this[kGuard] === 'response' && forbiddenResponseHeaderNames.includes(normalizedName)) {\n      return;\n    }\n\n    return this[kHeadersList].delete(String(arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n  get() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    return this[kHeadersList].get(String(arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n  has() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    return this[kHeadersList].has(String(arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n  set() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(arguments.length <= 0 ? undefined : arguments[0]));\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request' && forbiddenHeaderNames.includes(normalizedName)) {\n      return;\n    } else if (this[kGuard] === 'request-no-cors') {// TODO\n    } else if (this[kGuard] === 'response' && forbiddenResponseHeaderNames.includes(normalizedName)) {\n      return;\n    }\n\n    return this[kHeadersList].set(String(arguments.length <= 0 ? undefined : arguments[0]), String(arguments.length <= 1 ? undefined : arguments[1]));\n  }\n\n  *keys() {\n    const clone = this[kHeadersList].slice();\n\n    for (let index = 0; index < clone.length; index += 2) {\n      yield clone[index];\n    }\n  }\n\n  *values() {\n    const clone = this[kHeadersList].slice();\n\n    for (let index = 1; index < clone.length; index += 2) {\n      yield clone[index];\n    }\n  }\n\n  *entries() {\n    const clone = this[kHeadersList].slice();\n\n    for (let index = 0; index < clone.length; index += 2) {\n      yield [clone[index], clone[index + 1]];\n    }\n  }\n\n  forEach() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) !== 'function') {\n      throw new TypeError(\"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\");\n    }\n\n    const callback = arguments.length <= 0 ? undefined : arguments[0];\n    const thisArg = arguments.length <= 1 ? undefined : arguments[1];\n\n    for (let index = 0; index < this[kHeadersList].length; index += 2) {\n      callback.call(thisArg, this[kHeadersList][index + 1], this[kHeadersList][index], this);\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this[kHeadersList];\n  }\n\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries;\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty\n});\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList,\n  binarySearch,\n  normalizeAndValidateHeaderName,\n  normalizeAndValidateHeaderValue\n};","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/fetch/headers.js"],"names":["validateHeaderName","validateHeaderValue","require","kHeadersList","kGuard","kEnumerableProperty","forbiddenHeaderNames","forbiddenResponseHeaderNames","binarySearch","arr","val","low","high","Math","floor","length","mid","localeCompare","normalizeAndValidateHeaderName","name","undefined","TypeError","normalizedHeaderName","toLocaleLowerCase","normalizeAndValidateHeaderValue","value","normalizedHeaderValue","replace","fill","headers","object","Symbol","iterator","header","Array","isArray","append","Object","entries","HeadersList","normalizedName","normalizedValue","index","splice","delete","get","has","set","Headers","constructor","init","toStringTag","toString","prototype","call","String","includes","keys","clone","slice","values","forEach","callback","thisArg","for","defineProperties","module","exports"],"mappings":"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","sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { validateHeaderName, validateHeaderValue } = require('http')\nconst { kHeadersList } = require('../core/symbols')\nconst { kGuard } = require('./symbols')\nconst { kEnumerableProperty } = require('../core/util')\nconst {\n  forbiddenHeaderNames,\n  forbiddenResponseHeaderNames\n} = require('./constants')\n\nfunction binarySearch (arr, val) {\n  let low = 0\n  let high = Math.floor(arr.length / 2)\n\n  while (high > low) {\n    const mid = (high + low) >>> 1\n\n    if (val.localeCompare(arr[mid * 2]) > 0) {\n      low = mid + 1\n    } else {\n      high = mid\n    }\n  }\n\n  return low * 2\n}\n\nfunction normalizeAndValidateHeaderName (name) {\n  if (name === undefined) {\n    throw new TypeError(`Header name ${name}`)\n  }\n  const normalizedHeaderName = name.toLocaleLowerCase()\n  validateHeaderName(normalizedHeaderName)\n  return normalizedHeaderName\n}\n\nfunction normalizeAndValidateHeaderValue (name, value) {\n  if (value === undefined) {\n    throw new TypeError(value, name)\n  }\n  const normalizedHeaderValue = `${value}`.replace(\n    /^[\\n\\t\\r\\x20]+|[\\n\\t\\r\\x20]+$/g,\n    ''\n  )\n  validateHeaderValue(name, normalizedHeaderValue)\n  return normalizedHeaderValue\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  if (object[Symbol.iterator]) {\n    // 1. If object is a sequence, then for each header in object:\n    // TODO: How to check if sequence?\n    for (let header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (!header[Symbol.iterator]) {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (typeof header === 'string') {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (!Array.isArray(header)) {\n        header = [...header]\n      }\n\n      if (header.length !== 2) {\n        throw new TypeError()\n      }\n\n      // 2. Append header’s first item/header’s second item to headers.\n      headers.append(header[0], header[1])\n    }\n  } else if (object && typeof object === 'object') {\n    // Otherwise, object is a record, then for each key → value in object,\n    // append key/value to headers.\n    // TODO: How to check if record?\n    for (const header of Object.entries(object)) {\n      headers.append(header[0], header[1])\n    }\n  } else {\n    // TODO: Spec doesn't define what to do here?\n    throw TypeError()\n  }\n}\n\n// TODO: Composition over inheritence? Or helper methods?\nclass HeadersList extends Array {\n  append (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this[index + 1] += `, ${normalizedValue}`\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n\n  delete (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this.splice(index, 2)\n    }\n  }\n\n  get (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      return this[index + 1]\n    }\n\n    return null\n  }\n\n  has (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    return this[index] === normalizedName\n  }\n\n  set (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n    if (this[index] === normalizedName) {\n      this[index + 1] = normalizedValue\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n}\n\nclass Headers {\n  constructor (...args) {\n    if (\n      args[0] !== undefined &&\n      !(typeof args[0] === 'object' && args[0] !== null) &&\n      !Array.isArray(args[0])\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>\"\n      )\n    }\n    const init = args.length >= 1 ? args[0] ?? {} : {}\n\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    fill(this, init)\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  toString () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return Object.prototype.toString.call(this)\n  }\n\n  append (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].append(String(args[0]), String(args[1]))\n  }\n\n  delete (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].delete(String(args[0]))\n  }\n\n  get (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'get' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].get(String(args[0]))\n  }\n\n  has (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'has' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].has(String(args[0]))\n  }\n\n  set (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].set(String(args[0]), String(args[1]))\n  }\n\n  * keys () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * values () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 1; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * entries () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield [clone[index], clone[index + 1]]\n    }\n  }\n\n  forEach (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (typeof args[0] !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n    const callback = args[0]\n    const thisArg = args[1]\n\n    for (let index = 0; index < this[kHeadersList].length; index += 2) {\n      callback.call(\n        thisArg,\n        this[kHeadersList][index + 1],\n        this[kHeadersList][index],\n        this\n      )\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty\n})\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList,\n  binarySearch,\n  normalizeAndValidateHeaderName,\n  normalizeAndValidateHeaderValue\n}\n"]},"metadata":{},"sourceType":"script"}