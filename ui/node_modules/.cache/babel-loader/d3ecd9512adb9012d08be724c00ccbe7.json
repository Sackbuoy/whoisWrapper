{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTTPCache = void 0;\n\nconst apollo_server_env_1 = require(\"apollo-server-env\");\n\nconst CachePolicy = require(\"http-cache-semantics\");\n\nconst apollo_server_caching_1 = require(\"apollo-server-caching\");\n\nclass HTTPCache {\n  constructor() {\n    let keyValueCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new apollo_server_caching_1.InMemoryLRUCache();\n    let httpFetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : apollo_server_env_1.fetch;\n    this.keyValueCache = new apollo_server_caching_1.PrefixingKeyValueCache(keyValueCache, 'httpcache:');\n    this.httpFetch = httpFetch;\n  }\n\n  async fetch(request) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const cacheKey = options.cacheKey ? options.cacheKey : request.url;\n    const entry = await this.keyValueCache.get(cacheKey);\n\n    if (!entry) {\n      const response = await this.httpFetch(request);\n      const policy = new CachePolicy(policyRequestFrom(request), policyResponseFrom(response));\n      return this.storeResponseAndReturnClone(response, request, policy, cacheKey, options.cacheOptions);\n    }\n\n    const {\n      policy: policyRaw,\n      ttlOverride,\n      body\n    } = JSON.parse(entry);\n    const policy = CachePolicy.fromObject(policyRaw);\n    policy._url = undefined;\n\n    if (ttlOverride && policy.age() < ttlOverride || !ttlOverride && policy.satisfiesWithoutRevalidation(policyRequestFrom(request))) {\n      const headers = policy.responseHeaders();\n      return new apollo_server_env_1.Response(body, {\n        url: policy._url,\n        status: policy._status,\n        headers\n      });\n    } else {\n      const revalidationHeaders = policy.revalidationHeaders(policyRequestFrom(request));\n      const revalidationRequest = new apollo_server_env_1.Request(request, {\n        headers: revalidationHeaders\n      });\n      const revalidationResponse = await this.httpFetch(revalidationRequest);\n      const {\n        policy: revalidatedPolicy,\n        modified\n      } = policy.revalidatedPolicy(policyRequestFrom(revalidationRequest), policyResponseFrom(revalidationResponse));\n      return this.storeResponseAndReturnClone(new apollo_server_env_1.Response(modified ? await revalidationResponse.text() : body, {\n        url: revalidatedPolicy._url,\n        status: revalidatedPolicy._status,\n        headers: revalidatedPolicy.responseHeaders()\n      }), request, revalidatedPolicy, cacheKey, options.cacheOptions);\n    }\n  }\n\n  async storeResponseAndReturnClone(response, request, policy, cacheKey, cacheOptions) {\n    if (typeof cacheOptions === 'function') {\n      cacheOptions = cacheOptions(response, request);\n    }\n\n    let ttlOverride = cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.ttl;\n\n    if (!(ttlOverride && policy._status >= 200 && policy._status <= 299) && !(request.method === 'GET' && policy.storable())) {\n      return response;\n    }\n\n    let ttl = ttlOverride === undefined ? Math.round(policy.timeToLive() / 1000) : ttlOverride;\n    if (ttl <= 0) return response;\n\n    if (canBeRevalidated(response)) {\n      ttl *= 2;\n    }\n\n    const body = await response.text();\n    const entry = JSON.stringify({\n      policy: policy.toObject(),\n      ttlOverride,\n      body\n    });\n    await this.keyValueCache.set(cacheKey, entry, {\n      ttl\n    });\n    return new apollo_server_env_1.Response(body, {\n      url: response.url,\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers\n    });\n  }\n\n}\n\nexports.HTTPCache = HTTPCache;\n\nfunction canBeRevalidated(response) {\n  return response.headers.has('ETag');\n}\n\nfunction policyRequestFrom(request) {\n  return {\n    url: request.url,\n    method: request.method,\n    headers: headersToObject(request.headers)\n  };\n}\n\nfunction policyResponseFrom(response) {\n  return {\n    status: response.status,\n    headers: headersToObject(response.headers)\n  };\n}\n\nfunction headersToObject(headers) {\n  const object = Object.create(null);\n\n  for (const [name, value] of headers) {\n    object[name] = value;\n  }\n\n  return object;\n}","map":{"version":3,"sources":["../src/HTTPCache.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTTPCache = void 0;\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst CachePolicy = require(\"http-cache-semantics\");\nconst apollo_server_caching_1 = require(\"apollo-server-caching\");\nclass HTTPCache {\n    constructor(keyValueCache = new apollo_server_caching_1.InMemoryLRUCache(), httpFetch = apollo_server_env_1.fetch) {\n        this.keyValueCache = new apollo_server_caching_1.PrefixingKeyValueCache(keyValueCache, 'httpcache:');\n        this.httpFetch = httpFetch;\n    }\n    async fetch(request, options = {}) {\n        const cacheKey = options.cacheKey ? options.cacheKey : request.url;\n        const entry = await this.keyValueCache.get(cacheKey);\n        if (!entry) {\n            const response = await this.httpFetch(request);\n            const policy = new CachePolicy(policyRequestFrom(request), policyResponseFrom(response));\n            return this.storeResponseAndReturnClone(response, request, policy, cacheKey, options.cacheOptions);\n        }\n        const { policy: policyRaw, ttlOverride, body } = JSON.parse(entry);\n        const policy = CachePolicy.fromObject(policyRaw);\n        policy._url = undefined;\n        if ((ttlOverride && policy.age() < ttlOverride) ||\n            (!ttlOverride &&\n                policy.satisfiesWithoutRevalidation(policyRequestFrom(request)))) {\n            const headers = policy.responseHeaders();\n            return new apollo_server_env_1.Response(body, {\n                url: policy._url,\n                status: policy._status,\n                headers,\n            });\n        }\n        else {\n            const revalidationHeaders = policy.revalidationHeaders(policyRequestFrom(request));\n            const revalidationRequest = new apollo_server_env_1.Request(request, {\n                headers: revalidationHeaders,\n            });\n            const revalidationResponse = await this.httpFetch(revalidationRequest);\n            const { policy: revalidatedPolicy, modified } = policy.revalidatedPolicy(policyRequestFrom(revalidationRequest), policyResponseFrom(revalidationResponse));\n            return this.storeResponseAndReturnClone(new apollo_server_env_1.Response(modified ? await revalidationResponse.text() : body, {\n                url: revalidatedPolicy._url,\n                status: revalidatedPolicy._status,\n                headers: revalidatedPolicy.responseHeaders(),\n            }), request, revalidatedPolicy, cacheKey, options.cacheOptions);\n        }\n    }\n    async storeResponseAndReturnClone(response, request, policy, cacheKey, cacheOptions) {\n        if (typeof cacheOptions === 'function') {\n            cacheOptions = cacheOptions(response, request);\n        }\n        let ttlOverride = cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.ttl;\n        if (!(ttlOverride && policy._status >= 200 && policy._status <= 299) &&\n            !(request.method === 'GET' && policy.storable())) {\n            return response;\n        }\n        let ttl = ttlOverride === undefined\n            ? Math.round(policy.timeToLive() / 1000)\n            : ttlOverride;\n        if (ttl <= 0)\n            return response;\n        if (canBeRevalidated(response)) {\n            ttl *= 2;\n        }\n        const body = await response.text();\n        const entry = JSON.stringify({\n            policy: policy.toObject(),\n            ttlOverride,\n            body,\n        });\n        await this.keyValueCache.set(cacheKey, entry, {\n            ttl,\n        });\n        return new apollo_server_env_1.Response(body, {\n            url: response.url,\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers,\n        });\n    }\n}\nexports.HTTPCache = HTTPCache;\nfunction canBeRevalidated(response) {\n    return response.headers.has('ETag');\n}\nfunction policyRequestFrom(request) {\n    return {\n        url: request.url,\n        method: request.method,\n        headers: headersToObject(request.headers),\n    };\n}\nfunction policyResponseFrom(response) {\n    return {\n        status: response.status,\n        headers: headersToObject(response.headers),\n    };\n}\nfunction headersToObject(headers) {\n    const object = Object.create(null);\n    for (const [name, value] of headers) {\n        object[name] = value;\n    }\n    return object;\n}\n//# sourceMappingURL=HTTPCache.js.map"]},"metadata":{},"sourceType":"script"}