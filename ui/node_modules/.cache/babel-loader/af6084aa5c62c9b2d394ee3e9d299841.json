{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError,\n  SocketError\n} = require('../core/errors');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst util = require('../core/util');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass ConnectHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback');\n    }\n\n    const {\n      signal,\n      opaque\n    } = opts;\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n    }\n\n    super('UNDICI_CONNECT');\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.abort = null;\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders() {\n    throw new SocketError('bad connect', null);\n  }\n\n  onUpgrade(statusCode, headers, socket) {\n    const {\n      callback,\n      opaque,\n      context\n    } = this;\n    removeSignal(this);\n    this.callback = null;\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque,\n      context\n    });\n  }\n\n  onError(err) {\n    const {\n      callback,\n      opaque\n    } = this;\n    removeSignal(this);\n\n    if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n  }\n\n}\n\nfunction connect(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback);\n    this.dispatch({ ...opts,\n      method: 'CONNECT'\n    }, connectHandler);\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = connect;","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/undici/lib/api/api-connect.js"],"names":["InvalidArgumentError","RequestAbortedError","SocketError","require","AsyncResource","util","addSignal","removeSignal","ConnectHandler","constructor","opts","callback","signal","opaque","on","addEventListener","abort","onConnect","context","onHeaders","onUpgrade","statusCode","headers","socket","runInAsyncScope","parseHeaders","onError","err","queueMicrotask","connect","undefined","Promise","resolve","reject","call","data","connectHandler","dispatch","method","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = require('../core/errors')\nconst { AsyncResource } = require('async_hooks')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n"]},"metadata":{},"sourceType":"script"}