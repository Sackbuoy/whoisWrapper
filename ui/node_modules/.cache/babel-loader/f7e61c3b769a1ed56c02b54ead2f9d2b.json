{"ast":null,"code":"import { isNullableType, getNullableType, isCompositeType, isAbstractType, isListType, isScalarType, isEnumType, isObjectType, GraphQLString, isInterfaceType, isSchema, isUnionType, GraphQLUnionType, GraphQLInterfaceType, defaultFieldResolver, graphql } from 'graphql';\nimport stringify from 'fast-json-stable-stringify';\nimport { mapSchema, MapperKind, getRootTypeNames } from '@graphql-tools/utils';\nimport { addResolversToSchema, makeExecutableSchema } from '@graphql-tools/schema';\n\nfunction isRef(maybeRef) {\n  return !!(maybeRef && typeof maybeRef === 'object' && '$ref' in maybeRef);\n}\n\nfunction assertIsRef(maybeRef, message) {\n  if (!isRef(maybeRef)) {\n    throw new Error(message || `Expected ${maybeRef} to be a valid Ref.`);\n  }\n}\n\nfunction isRecord(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0; // eslint-disable-next-line eqeqeq\n\n    const v = c == 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\nconst randomListLength = () => {\n  // Mocking has always returned list of length 2 by default\n  // return 1 + Math.round(Math.random() * 10)\n  return 2;\n};\n\nconst takeRandom = arr => arr[Math.floor(Math.random() * arr.length)];\n\nfunction makeRef(typeName, key) {\n  return {\n    $ref: {\n      key,\n      typeName\n    }\n  };\n}\n\nfunction isObject(thing) {\n  return thing === Object(thing) && !Array.isArray(thing);\n}\n\nfunction copyOwnPropsIfNotPresent(target, source) {\n  for (const prop of Object.getOwnPropertyNames(source)) {\n    if (!Object.getOwnPropertyDescriptor(target, prop)) {\n      const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n      Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\n    }\n  }\n}\n\nfunction copyOwnProps(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n    sources[_key2 - 1] = arguments[_key2];\n  }\n\n  for (const source of sources) {\n    let chain = source;\n\n    while (chain != null) {\n      copyOwnPropsIfNotPresent(target, chain);\n      chain = Object.getPrototypeOf(chain);\n    }\n  }\n\n  return target;\n}\n/**\n * @internal\n */\n\n\nfunction isMockList(obj) {\n  if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === 'number' || Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === 'number') {\n    if (typeof obj.wrappedFunction === 'undefined' || typeof obj.wrappedFunction === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * This is an object you can return from your mock resolvers which calls the\n * provided `mockFunction` once for each list item.\n */\n\n\nclass MockList {\n  /**\n   * @param length Either the exact length of items to return or an inclusive\n   * range of possible lengths.\n   * @param mockFunction The function to call for each item in the list to\n   * resolve it. It can return another MockList or a value.\n   */\n  constructor(length, mockFunction) {\n    this.len = length;\n\n    if (typeof mockFunction !== 'undefined') {\n      if (typeof mockFunction !== 'function') {\n        throw new Error('Second argument to MockList must be a function or undefined');\n      }\n\n      this.wrappedFunction = mockFunction;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  mock() {\n    let arr;\n\n    if (Array.isArray(this.len)) {\n      arr = new Array(this.randint(this.len[0], this.len[1]));\n    } else {\n      arr = new Array(this.len);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n      if (typeof this.wrappedFunction === 'function') {\n        const res = this.wrappedFunction();\n\n        if (isMockList(res)) {\n          arr[i] = res.mock();\n        } else {\n          arr[i] = res;\n        }\n      } else {\n        arr[i] = undefined;\n      }\n    }\n\n    return arr;\n  }\n\n  randint(low, high) {\n    return Math.floor(Math.random() * (high - low + 1) + low);\n  }\n\n}\n\nfunction deepResolveMockList(mockList) {\n  return mockList.mock().map(v => {\n    if (isMockList(v)) return deepResolveMockList(v);\n    return v;\n  });\n}\n\nconst defaultMocks = {\n  Int: () => Math.round(Math.random() * 200) - 100,\n  Float: () => Math.random() * 200 - 100,\n  String: () => 'Hello World',\n  Boolean: () => Math.random() > 0.5,\n  ID: () => uuidv4()\n};\nconst defaultKeyFieldNames = ['id', '_id'];\n\nclass MockStore {\n  constructor(_ref) {\n    let {\n      schema,\n      mocks,\n      typePolicies\n    } = _ref;\n    this.store = {};\n    this.schema = schema;\n    this.mocks = { ...defaultMocks,\n      ...mocks\n    };\n    this.typePolicies = typePolicies || {};\n  }\n\n  has(typeName, key) {\n    return !!this.store[typeName] && !!this.store[typeName][key];\n  }\n\n  get(_typeName, _key, _fieldName, _fieldArgs) {\n    if (typeof _typeName !== 'string') {\n      if (_key === undefined) {\n        if (isRef(_typeName)) {\n          throw new Error(\"Can't provide a ref as first argument and no other argument\");\n        } // get({...})\n\n\n        return this.getImpl(_typeName);\n      } else {\n        assertIsRef(_typeName);\n        const {\n          $ref\n        } = _typeName; // arguments shift\n\n        _fieldArgs = _fieldName;\n        _fieldName = _key;\n        _key = $ref.key;\n        _typeName = $ref.typeName;\n      }\n    }\n\n    const args = {\n      typeName: _typeName\n    };\n\n    if (isRecord(_key) || _key === undefined) {\n      // get('User', { name: 'Alex'})\n      args.defaultValue = _key;\n      return this.getImpl(args);\n    }\n\n    args.key = _key;\n\n    if (Array.isArray(_fieldName) && _fieldName.length === 1) {\n      _fieldName = _fieldName[0];\n    }\n\n    if (typeof _fieldName !== 'string' && !Array.isArray(_fieldName)) {\n      // get('User', 'me', { name: 'Alex'})\n      args.defaultValue = _fieldName;\n      return this.getImpl(args);\n    }\n\n    if (Array.isArray(_fieldName)) {\n      // get('User', 'me', ['father', 'name'])\n      const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);\n      assertIsRef(ref);\n      return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));\n    } // get('User', 'me', 'name'...);\n\n\n    args.fieldName = _fieldName;\n    args.fieldArgs = _fieldArgs;\n    return this.getImpl(args);\n  }\n\n  set(_typeName, _key, _fieldName, _value) {\n    if (typeof _typeName !== 'string') {\n      if (_key === undefined) {\n        if (isRef(_typeName)) {\n          throw new Error(\"Can't provide a ref as first argument and no other argument\");\n        } // set({...})\n\n\n        return this.setImpl(_typeName);\n      } else {\n        assertIsRef(_typeName);\n        const {\n          $ref\n        } = _typeName; // arguments shift\n\n        _value = _fieldName;\n        _fieldName = _key;\n        _key = $ref.key;\n        _typeName = $ref.typeName;\n      }\n    }\n\n    assertIsDefined(_key, 'key was not provided');\n    const args = {\n      typeName: _typeName,\n      key: _key\n    };\n\n    if (typeof _fieldName !== 'string') {\n      // set('User', 1, { name: 'Foo' })\n      if (!isRecord(_fieldName)) throw new Error('Expected value to be a record');\n      args.value = _fieldName;\n      return this.setImpl(args);\n    }\n\n    args.fieldName = _fieldName;\n    args.value = _value;\n    return this.setImpl(args);\n  }\n\n  reset() {\n    this.store = {};\n  }\n\n  filter(key, predicate) {\n    const entity = this.store[key];\n    return Object.values(entity).filter(predicate);\n  }\n\n  find(key, predicate) {\n    const entity = this.store[key];\n    return Object.values(entity).find(predicate);\n  }\n\n  getImpl(args) {\n    const {\n      typeName,\n      key,\n      fieldName,\n      fieldArgs,\n      defaultValue\n    } = args;\n\n    if (!fieldName) {\n      if (defaultValue !== undefined && !isRecord(defaultValue)) {\n        throw new Error('`defaultValue` should be an object');\n      }\n\n      let valuesToInsert = defaultValue || {};\n\n      if (key) {\n        valuesToInsert = { ...valuesToInsert,\n          ...makeRef(typeName, key)\n        };\n      }\n\n      return this.insert(typeName, valuesToInsert, true);\n    }\n\n    assertIsDefined(key, 'key argument should be given when fieldName is given');\n    const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n\n    if (this.store[typeName] === undefined || this.store[typeName][key] === undefined || this.store[typeName][key][fieldNameInStore] === undefined) {\n      let value;\n\n      if (defaultValue !== undefined) {\n        value = defaultValue;\n      } else if (this.isKeyField(typeName, fieldName)) {\n        value = key;\n      } else {\n        value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {\n          // if we get a key field in the mix we don't care\n          if (this.isKeyField(typeName, otherFieldName)) return;\n          this.set({\n            typeName,\n            key,\n            fieldName: otherFieldName,\n            value: otherValue,\n            noOverride: true\n          });\n        });\n      }\n\n      this.set({\n        typeName,\n        key,\n        fieldName,\n        fieldArgs,\n        value,\n        noOverride: true\n      });\n    }\n\n    return this.store[typeName][key][fieldNameInStore];\n  }\n\n  setImpl(args) {\n    const {\n      typeName,\n      key,\n      fieldName,\n      fieldArgs,\n      noOverride\n    } = args;\n    let {\n      value\n    } = args;\n\n    if (isMockList(value)) {\n      value = deepResolveMockList(value);\n    }\n\n    if (this.store[typeName] === undefined) {\n      this.store[typeName] = {};\n    }\n\n    if (this.store[typeName][key] === undefined) {\n      this.store[typeName][key] = {};\n    }\n\n    if (!fieldName) {\n      if (!isRecord(value)) {\n        throw new Error('When no `fieldName` is provided, `value` should be a record.');\n      }\n\n      for (const fieldName in value) {\n        this.setImpl({\n          typeName,\n          key,\n          fieldName,\n          value: value[fieldName],\n          noOverride\n        });\n      }\n\n      return;\n    }\n\n    const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n\n    if (this.isKeyField(typeName, fieldName) && value !== key) {\n      throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);\n    } // if already set and we don't override\n\n\n    if (this.store[typeName][key][fieldNameInStore] !== undefined && noOverride) {\n      return;\n    }\n\n    const fieldType = this.getFieldType(typeName, fieldName);\n    const currentValue = this.store[typeName][key][fieldNameInStore];\n    let valueToStore;\n\n    try {\n      valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName, values) => this.insert(typeName, values, noOverride));\n    } catch (e) {\n      throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);\n    }\n\n    this.store[typeName][key] = { ...this.store[typeName][key],\n      [fieldNameInStore]: valueToStore\n    };\n  }\n\n  normalizeValueToStore(fieldType, value, currentValue, onInsertType) {\n    const fieldTypeName = fieldType.toString();\n\n    if (value === null) {\n      if (!isNullableType(fieldType)) {\n        throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);\n      }\n\n      return null;\n    }\n\n    const nullableFieldType = getNullableType(fieldType);\n    if (value === undefined) return this.generateValueFromType(nullableFieldType); // deal with nesting insert\n\n    if (isCompositeType(nullableFieldType)) {\n      if (!isRecord(value)) throw new Error(`should be an object or null or undefined. Received ${value}`);\n      let joinedTypeName;\n\n      if (isAbstractType(nullableFieldType)) {\n        if (isRef(value)) {\n          joinedTypeName = value.$ref.typeName;\n        } else {\n          if (typeof value['__typename'] !== 'string') {\n            throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);\n          }\n\n          joinedTypeName = value['__typename'];\n        }\n      } else {\n        joinedTypeName = nullableFieldType.name;\n      }\n\n      return onInsertType(joinedTypeName, isRef(currentValue) ? { ...currentValue,\n        ...value\n      } : value);\n    }\n\n    if (isListType(nullableFieldType)) {\n      if (!Array.isArray(value)) throw new Error(`should be an array or null or undefined. Received ${value}`);\n      return value.map((v, index) => {\n        return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === 'object' && currentValue != null && currentValue[index] ? currentValue : undefined, onInsertType);\n      });\n    }\n\n    return value;\n  }\n\n  insert(typeName, values, noOverride) {\n    const keyFieldName = this.getKeyFieldName(typeName);\n    let key; // when we generate a key for the type, we might produce\n    // other associated values with it\n    // We keep track of them and we'll insert them, with propririty\n    // for the ones that we areasked to insert\n\n    const otherValues = {};\n\n    if (isRef(values)) {\n      key = values.$ref.key;\n    } else if (keyFieldName && keyFieldName in values) {\n      key = values[keyFieldName];\n    } else {\n      key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {\n        otherValues[otherFieldName] = otherFieldValue;\n      });\n    }\n\n    const toInsert = { ...otherValues,\n      ...values\n    };\n\n    for (const fieldName in toInsert) {\n      if (fieldName === '$ref') continue;\n      if (fieldName === '__typename') continue;\n      this.set({\n        typeName,\n        key,\n        fieldName,\n        value: toInsert[fieldName],\n        noOverride\n      });\n    }\n\n    if (this.store[typeName] === undefined) {\n      this.store[typeName] = {};\n    }\n\n    if (this.store[typeName][key] === undefined) {\n      this.store[typeName][key] = {};\n    }\n\n    return makeRef(typeName, key);\n  }\n\n  generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {\n    const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);\n    if (mockedValue !== undefined) return mockedValue;\n    const fieldType = this.getFieldType(typeName, fieldName);\n    return this.generateValueFromType(fieldType);\n  }\n\n  generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {\n    let value;\n    const mock = this.mocks ? this.mocks[typeName] : undefined;\n\n    if (mock) {\n      if (typeof mock === 'function') {\n        const values = mock();\n\n        if (typeof values !== 'object' || values == null) {\n          throw new Error(`Value returned by the mock for ${typeName} is not an object`);\n        }\n\n        for (const otherFieldName in values) {\n          if (otherFieldName === fieldName) continue;\n          if (typeof values[otherFieldName] === 'function') continue;\n          onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);\n        }\n\n        value = values[fieldName];\n        if (typeof value === 'function') value = value();\n      } else if (typeof mock === 'object' && mock != null && typeof mock[fieldName] === 'function') {\n        value = mock[fieldName]();\n      }\n    }\n\n    if (value !== undefined) return value;\n    const type = this.getType(typeName); // GraphQL 14 Compatibility\n\n    const interfaces = 'getInterfaces' in type ? type.getInterfaces() : [];\n\n    if (interfaces.length > 0) {\n      for (const interface_ of interfaces) {\n        if (value) break;\n        value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);\n      }\n    }\n\n    return value;\n  }\n\n  generateKeyForType(typeName, onOtherFieldsGenerated) {\n    const keyFieldName = this.getKeyFieldName(typeName);\n    if (!keyFieldName) return uuidv4();\n    return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);\n  }\n\n  generateValueFromType(fieldType) {\n    const nullableType = getNullableType(fieldType);\n\n    if (isScalarType(nullableType)) {\n      const mockFn = this.mocks[nullableType.name];\n      if (typeof mockFn !== 'function') throw new Error(`No mock defined for type \"${nullableType.name}\"`);\n      return mockFn();\n    } else if (isEnumType(nullableType)) {\n      const mockFn = this.mocks[nullableType.name];\n      if (typeof mockFn === 'function') return mockFn();\n      const values = nullableType.getValues().map(v => v.value);\n      return takeRandom(values);\n    } else if (isObjectType(nullableType)) {\n      // this will create a new random ref\n      return this.insert(nullableType.name, {});\n    } else if (isListType(nullableType)) {\n      return [...new Array(randomListLength())].map(() => this.generateValueFromType(nullableType.ofType));\n    } else if (isAbstractType(nullableType)) {\n      const mock = this.mocks[nullableType.name];\n      let typeName;\n      let values = {};\n\n      if (!mock) {\n        typeName = takeRandom(this.schema.getPossibleTypes(nullableType).map(t => t.name));\n      } else if (typeof mock === 'function') {\n        const mockRes = mock();\n        if (mockRes === null) return null;\n\n        if (!isRecord(mockRes)) {\n          throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);\n        }\n\n        values = mockRes;\n\n        if (typeof values['__typename'] !== 'string') {\n          throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n        }\n\n        typeName = values['__typename'];\n      } else if (typeof mock === 'object' && mock != null && typeof mock['__typename'] === 'function') {\n        const mockRes = mock['__typename']();\n        if (typeof mockRes !== 'string') throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);\n        typeName = mockRes;\n      } else {\n        throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n      }\n\n      const toInsert = {};\n\n      for (const fieldName in values) {\n        if (fieldName === '__typename') continue;\n        const fieldValue = values[fieldName];\n        toInsert[fieldName] = typeof fieldValue === 'function' ? fieldValue() : fieldValue;\n      }\n\n      return this.insert(typeName, toInsert);\n    } else {\n      throw new Error(`${nullableType} not implemented`);\n    }\n  }\n\n  getFieldType(typeName, fieldName) {\n    if (fieldName === '__typename') {\n      return GraphQLString;\n    }\n\n    const type = this.getType(typeName);\n    const field = type.getFields()[fieldName];\n\n    if (!field) {\n      throw new Error(`${fieldName} does not exist on type ${typeName}`);\n    }\n\n    return field.type;\n  }\n\n  getType(typeName) {\n    const type = this.schema.getType(typeName);\n\n    if (!type || !(isObjectType(type) || isInterfaceType(type))) {\n      throw new Error(`${typeName} does not exist on schema or is not an object or interface`);\n    }\n\n    return type;\n  }\n\n  isKeyField(typeName, fieldName) {\n    return this.getKeyFieldName(typeName) === fieldName;\n  }\n\n  getKeyFieldName(typeName) {\n    var _a;\n\n    const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;\n\n    if (typePolicyKeyField !== undefined) {\n      if (typePolicyKeyField === false) return null;\n      return typePolicyKeyField;\n    } // How about common key field names?\n\n\n    const gqlType = this.getType(typeName);\n\n    for (const fieldName in gqlType.getFields()) {\n      if (defaultKeyFieldNames.includes(fieldName)) {\n        return fieldName;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nconst getFieldNameInStore = (fieldName, fieldArgs) => {\n  if (!fieldArgs) return fieldName;\n\n  if (typeof fieldArgs === 'string') {\n    return `${fieldName}:${fieldArgs}`;\n  } // empty args\n\n\n  if (Object.keys(fieldArgs).length === 0) {\n    return fieldName;\n  }\n\n  return `${fieldName}:${stringify(fieldArgs)}`;\n};\n\nfunction assertIsDefined(value, message) {\n  if (value !== undefined && value !== null) {\n    return;\n  }\n\n  throw new Error(process.env['NODE_ENV'] === 'production' ? 'Invariant failed:' : `Invariant failed: ${message || ''}`);\n}\n/**\n * Will create `MockStore` for the given `schema`.\n *\n * A `MockStore` will generate mock values for the given schem when queried.\n *\n * It will stores generated mocks, so that, provided with same arguments\n * the returned values will be the same.\n *\n * Its API also allows to modify the stored values.\n *\n * Basic example:\n * ```ts\n * store.get('User', 1, 'name');\n * // > \"Hello World\"\n * store.set('User', 1, 'name', 'Alexandre');\n * store.get('User', 1, 'name');\n * // > \"Alexandre\"\n * ```\n *\n * The storage key will correspond to the \"key field\"\n * of the type. Field with name `id` or `_id` will be\n * by default considered as the key field for the type.\n * However, use `typePolicies` to precise the field to use\n * as key.\n */\n\n\nfunction createMockStore(options) {\n  return new MockStore(options);\n} // todo: add option to preserve resolver\n\n/**\n * Given a `schema` and a `MockStore`, returns an executable schema that\n * will use the provided `MockStore` to execute queries.\n *\n * ```ts\n * const schema = buildSchema(`\n *  type User {\n *    id: ID!\n *    name: String!\n *  }\n *  type Query {\n *    me: User!\n *  }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({ schema, store });\n * ```\n *\n *\n * If a `resolvers` parameter is passed, the query execution will use\n * the provided `resolvers` if, one exists, instead of the default mock\n * resolver.\n *\n *\n * ```ts\n * const schema = buildSchema(`\n *   type User {\n *     id: ID!\n *     name: String!\n *   }\n *   type Query {\n *     me: User!\n *   }\n *   type Mutation {\n *     setMyName(newName: String!): User!\n *   }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({\n *   schema,\n *   store,\n *   resolvers: {\n *     Mutation: {\n *       setMyName: (_, { newName }) => {\n *          const ref = store.get('Query', 'ROOT', 'viewer');\n *          store.set(ref, 'name', newName);\n *          return ref;\n *       }\n *     }\n *   }\n *  });\n * ```\n *\n *\n * `Query` and `Mutation` type will use `key` `'ROOT'`.\n */\n\n\nfunction addMocksToSchema(_ref2) {\n  let {\n    schema,\n    store: maybeStore,\n    mocks,\n    typePolicies,\n    resolvers: resolversOrFnResolvers,\n    preserveResolvers = false\n  } = _ref2;\n\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n\n  if (!isSchema(schema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n\n  if (mocks && !isObject(mocks)) {\n    throw new Error('mocks must be of type Object');\n  }\n\n  const store = maybeStore || createMockStore({\n    schema,\n    mocks,\n    typePolicies\n  });\n  const resolvers = typeof resolversOrFnResolvers === 'function' ? resolversOrFnResolvers(store) : resolversOrFnResolvers;\n\n  const mockResolver = (source, args, contex, info) => {\n    const defaultResolvedValue = defaultFieldResolver(source, args, contex, info); // priority to default resolved value\n\n    if (defaultResolvedValue !== undefined) return defaultResolvedValue;\n\n    if (isRef(source)) {\n      return store.get({\n        typeName: source.$ref.typeName,\n        key: source.$ref.key,\n        fieldName: info.fieldName,\n        fieldArgs: args\n      });\n    } // we have to handle the root mutation, root query and root subscription types\n    // differently, because no resolver is called at the root\n\n\n    if (isRootType(info.parentType, info.schema)) {\n      return store.get({\n        typeName: info.parentType.name,\n        key: 'ROOT',\n        fieldName: info.fieldName,\n        fieldArgs: args\n      });\n    }\n\n    if (defaultResolvedValue === undefined) {\n      const mockFn = mocks === null || mocks === void 0 ? void 0 : mocks[info.returnType.toString()];\n\n      if (typeof mockFn === 'function') {\n        return mockFn(source, args, contex, info);\n      }\n    }\n\n    return undefined;\n  };\n\n  const typeResolver = data => {\n    if (isRef(data)) {\n      return data.$ref.typeName;\n    }\n  };\n\n  const mockSubscriber = () => ({\n    [Symbol.asyncIterator]() {\n      return {\n        async next() {\n          return {\n            done: true,\n            value: {}\n          };\n        }\n\n      };\n    }\n\n  });\n\n  const schemaWithMocks = mapSchema(schema, {\n    [MapperKind.OBJECT_FIELD]: fieldConfig => {\n      const newFieldConfig = { ...fieldConfig\n      };\n      const oldResolver = fieldConfig.resolve;\n\n      if (!preserveResolvers || !oldResolver) {\n        newFieldConfig.resolve = mockResolver;\n      } else {\n        newFieldConfig.resolve = async (rootObject, args, context, info) => {\n          const [mockedValue, resolvedValue] = await Promise.all([mockResolver(rootObject, args, context, info), oldResolver(rootObject, args, context, info)]); // In case we couldn't mock\n\n          if (mockedValue instanceof Error) {\n            // only if value was not resolved, populate the error.\n            if (undefined === resolvedValue) {\n              throw mockedValue;\n            }\n\n            return resolvedValue;\n          }\n\n          if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          }\n\n          if (isObject(mockedValue) && isObject(resolvedValue)) {\n            // Object.assign() won't do here, as we need to all properties, including\n            // the non-enumerable ones and defined using Object.defineProperty\n            const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n            return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n          }\n\n          return undefined !== resolvedValue ? resolvedValue : mockedValue;\n        };\n      }\n\n      const fieldSubscriber = fieldConfig.subscribe;\n\n      if (!preserveResolvers || !fieldSubscriber) {\n        newFieldConfig.subscribe = mockSubscriber;\n      } else {\n        newFieldConfig.subscribe = async (rootObject, args, context, info) => {\n          const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([mockSubscriber(), fieldSubscriber(rootObject, args, context, info)]);\n          return oldAsyncIterable || mockAsyncIterable;\n        };\n      }\n\n      return newFieldConfig;\n    },\n    [MapperKind.ABSTRACT_TYPE]: type => {\n      if (preserveResolvers && type.resolveType != null && type.resolveType.length) {\n        return;\n      }\n\n      if (isUnionType(type)) {\n        return new GraphQLUnionType({ ...type.toConfig(),\n          resolveType: typeResolver\n        });\n      } else {\n        return new GraphQLInterfaceType({ ...type.toConfig(),\n          resolveType: typeResolver\n        });\n      }\n    }\n  });\n  return resolvers ? addResolversToSchema(schemaWithMocks, resolvers) : schemaWithMocks;\n}\n\nconst isRootType = (type, schema) => {\n  const rootTypeNames = getRootTypeNames(schema);\n  return rootTypeNames.has(type.name);\n};\n/**\n * A convenience wrapper on top of addMocksToSchema. It adds your mock resolvers\n * to your schema and returns a client that will correctly execute your query with\n * variables. Note: when executing queries from the returned server, context and\n * root will both equal `{}`.\n * @param schema The schema to which to add mocks. This can also be a set of type\n * definitions instead.\n * @param mocks The mocks to add to the schema.\n * @param preserveResolvers Set to `true` to prevent existing resolvers from being\n * overwritten to provide mock data. This can be used to mock some parts of the\n * server and not others.\n */\n\n\nfunction mockServer(schema, mocks) {\n  let preserveResolvers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const mockedSchema = addMocksToSchema({\n    schema: isSchema(schema) ? schema : makeExecutableSchema({\n      typeDefs: schema\n    }),\n    mocks,\n    preserveResolvers\n  });\n  return {\n    query: (query, vars) => graphql({\n      schema: mockedSchema,\n      source: query,\n      rootValue: {},\n      contextValue: {},\n      variableValues: vars\n    })\n  };\n}\n\nexport { MockList, MockStore, addMocksToSchema, assertIsRef, createMockStore, deepResolveMockList, defaultMocks, isMockList, isRecord, isRef, mockServer };","map":{"version":3,"sources":["/home/cameron/Dev/whoisWrapper/ui/node_modules/@graphql-tools/mock/index.mjs"],"names":["isNullableType","getNullableType","isCompositeType","isAbstractType","isListType","isScalarType","isEnumType","isObjectType","GraphQLString","isInterfaceType","isSchema","isUnionType","GraphQLUnionType","GraphQLInterfaceType","defaultFieldResolver","graphql","stringify","mapSchema","MapperKind","getRootTypeNames","addResolversToSchema","makeExecutableSchema","isRef","maybeRef","assertIsRef","message","Error","isRecord","obj","uuidv4","replace","c","r","Math","random","v","toString","randomListLength","takeRandom","arr","floor","length","makeRef","typeName","key","$ref","isObject","thing","Object","Array","isArray","copyOwnPropsIfNotPresent","target","source","prop","getOwnPropertyNames","getOwnPropertyDescriptor","propertyDescriptor","defineProperty","copyOwnProps","sources","chain","getPrototypeOf","isMockList","len","wrappedFunction","MockList","constructor","mockFunction","mock","randint","i","res","undefined","low","high","deepResolveMockList","mockList","map","defaultMocks","Int","round","Float","String","Boolean","ID","defaultKeyFieldNames","MockStore","schema","mocks","typePolicies","store","has","get","_typeName","_key","_fieldName","_fieldArgs","getImpl","args","defaultValue","ref","slice","fieldName","fieldArgs","set","_value","setImpl","assertIsDefined","value","reset","filter","predicate","entity","values","find","valuesToInsert","insert","fieldNameInStore","getFieldNameInStore","isKeyField","generateFieldValue","otherFieldName","otherValue","noOverride","fieldType","getFieldType","currentValue","valueToStore","normalizeValueToStore","e","onInsertType","fieldTypeName","nullableFieldType","generateValueFromType","joinedTypeName","name","index","ofType","keyFieldName","getKeyFieldName","otherValues","generateKeyForType","otherFieldValue","toInsert","onOtherFieldsGenerated","mockedValue","generateFieldValueFromMocks","type","getType","interfaces","getInterfaces","interface_","nullableType","mockFn","getValues","getPossibleTypes","t","mockRes","fieldValue","field","getFields","_a","typePolicyKeyField","gqlType","includes","keys","process","env","createMockStore","options","addMocksToSchema","maybeStore","resolvers","resolversOrFnResolvers","preserveResolvers","mockResolver","contex","info","defaultResolvedValue","isRootType","parentType","returnType","typeResolver","data","mockSubscriber","Symbol","asyncIterator","next","done","schemaWithMocks","OBJECT_FIELD","fieldConfig","newFieldConfig","oldResolver","resolve","rootObject","context","resolvedValue","Promise","all","Date","emptyObject","create","fieldSubscriber","subscribe","mockAsyncIterable","oldAsyncIterable","ABSTRACT_TYPE","resolveType","toConfig","rootTypeNames","mockServer","mockedSchema","typeDefs","query","vars","rootValue","contextValue","variableValues"],"mappings":"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","sourcesContent":["import { isNullableType, getNullableType, isCompositeType, isAbstractType, isListType, isScalarType, isEnumType, isObjectType, GraphQLString, isInterfaceType, isSchema, isUnionType, GraphQLUnionType, GraphQLInterfaceType, defaultFieldResolver, graphql } from 'graphql';\nimport stringify from 'fast-json-stable-stringify';\nimport { mapSchema, MapperKind, getRootTypeNames } from '@graphql-tools/utils';\nimport { addResolversToSchema, makeExecutableSchema } from '@graphql-tools/schema';\n\nfunction isRef(maybeRef) {\n    return !!(maybeRef && typeof maybeRef === 'object' && '$ref' in maybeRef);\n}\nfunction assertIsRef(maybeRef, message) {\n    if (!isRef(maybeRef)) {\n        throw new Error(message || `Expected ${maybeRef} to be a valid Ref.`);\n    }\n}\nfunction isRecord(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\n\nfunction uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0;\n        // eslint-disable-next-line eqeqeq\n        const v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nconst randomListLength = () => {\n    // Mocking has always returned list of length 2 by default\n    // return 1 + Math.round(Math.random() * 10)\n    return 2;\n};\nconst takeRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];\nfunction makeRef(typeName, key) {\n    return { $ref: { key, typeName } };\n}\nfunction isObject(thing) {\n    return thing === Object(thing) && !Array.isArray(thing);\n}\nfunction copyOwnPropsIfNotPresent(target, source) {\n    for (const prop of Object.getOwnPropertyNames(source)) {\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\n            const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\n        }\n    }\n}\nfunction copyOwnProps(target, ...sources) {\n    for (const source of sources) {\n        let chain = source;\n        while (chain != null) {\n            copyOwnPropsIfNotPresent(target, chain);\n            chain = Object.getPrototypeOf(chain);\n        }\n    }\n    return target;\n}\n\n/**\n * @internal\n */\nfunction isMockList(obj) {\n    if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === 'number' || (Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === 'number')) {\n        if (typeof obj.wrappedFunction === 'undefined' || typeof obj.wrappedFunction === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * This is an object you can return from your mock resolvers which calls the\n * provided `mockFunction` once for each list item.\n */\nclass MockList {\n    /**\n     * @param length Either the exact length of items to return or an inclusive\n     * range of possible lengths.\n     * @param mockFunction The function to call for each item in the list to\n     * resolve it. It can return another MockList or a value.\n     */\n    constructor(length, mockFunction) {\n        this.len = length;\n        if (typeof mockFunction !== 'undefined') {\n            if (typeof mockFunction !== 'function') {\n                throw new Error('Second argument to MockList must be a function or undefined');\n            }\n            this.wrappedFunction = mockFunction;\n        }\n    }\n    /**\n     * @internal\n     */\n    mock() {\n        let arr;\n        if (Array.isArray(this.len)) {\n            arr = new Array(this.randint(this.len[0], this.len[1]));\n        }\n        else {\n            arr = new Array(this.len);\n        }\n        for (let i = 0; i < arr.length; i++) {\n            if (typeof this.wrappedFunction === 'function') {\n                const res = this.wrappedFunction();\n                if (isMockList(res)) {\n                    arr[i] = res.mock();\n                }\n                else {\n                    arr[i] = res;\n                }\n            }\n            else {\n                arr[i] = undefined;\n            }\n        }\n        return arr;\n    }\n    randint(low, high) {\n        return Math.floor(Math.random() * (high - low + 1) + low);\n    }\n}\nfunction deepResolveMockList(mockList) {\n    return mockList.mock().map(v => {\n        if (isMockList(v))\n            return deepResolveMockList(v);\n        return v;\n    });\n}\n\nconst defaultMocks = {\n    Int: () => Math.round(Math.random() * 200) - 100,\n    Float: () => Math.random() * 200 - 100,\n    String: () => 'Hello World',\n    Boolean: () => Math.random() > 0.5,\n    ID: () => uuidv4(),\n};\nconst defaultKeyFieldNames = ['id', '_id'];\nclass MockStore {\n    constructor({ schema, mocks, typePolicies, }) {\n        this.store = {};\n        this.schema = schema;\n        this.mocks = { ...defaultMocks, ...mocks };\n        this.typePolicies = typePolicies || {};\n    }\n    has(typeName, key) {\n        return !!this.store[typeName] && !!this.store[typeName][key];\n    }\n    get(_typeName, _key, _fieldName, _fieldArgs) {\n        if (typeof _typeName !== 'string') {\n            if (_key === undefined) {\n                if (isRef(_typeName)) {\n                    throw new Error(\"Can't provide a ref as first argument and no other argument\");\n                }\n                // get({...})\n                return this.getImpl(_typeName);\n            }\n            else {\n                assertIsRef(_typeName);\n                const { $ref } = _typeName;\n                // arguments shift\n                _fieldArgs = _fieldName;\n                _fieldName = _key;\n                _key = $ref.key;\n                _typeName = $ref.typeName;\n            }\n        }\n        const args = {\n            typeName: _typeName,\n        };\n        if (isRecord(_key) || _key === undefined) {\n            // get('User', { name: 'Alex'})\n            args.defaultValue = _key;\n            return this.getImpl(args);\n        }\n        args.key = _key;\n        if (Array.isArray(_fieldName) && _fieldName.length === 1) {\n            _fieldName = _fieldName[0];\n        }\n        if (typeof _fieldName !== 'string' && !Array.isArray(_fieldName)) {\n            // get('User', 'me', { name: 'Alex'})\n            args.defaultValue = _fieldName;\n            return this.getImpl(args);\n        }\n        if (Array.isArray(_fieldName)) {\n            // get('User', 'me', ['father', 'name'])\n            const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);\n            assertIsRef(ref);\n            return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));\n        }\n        // get('User', 'me', 'name'...);\n        args.fieldName = _fieldName;\n        args.fieldArgs = _fieldArgs;\n        return this.getImpl(args);\n    }\n    set(_typeName, _key, _fieldName, _value) {\n        if (typeof _typeName !== 'string') {\n            if (_key === undefined) {\n                if (isRef(_typeName)) {\n                    throw new Error(\"Can't provide a ref as first argument and no other argument\");\n                }\n                // set({...})\n                return this.setImpl(_typeName);\n            }\n            else {\n                assertIsRef(_typeName);\n                const { $ref } = _typeName;\n                // arguments shift\n                _value = _fieldName;\n                _fieldName = _key;\n                _key = $ref.key;\n                _typeName = $ref.typeName;\n            }\n        }\n        assertIsDefined(_key, 'key was not provided');\n        const args = {\n            typeName: _typeName,\n            key: _key,\n        };\n        if (typeof _fieldName !== 'string') {\n            // set('User', 1, { name: 'Foo' })\n            if (!isRecord(_fieldName))\n                throw new Error('Expected value to be a record');\n            args.value = _fieldName;\n            return this.setImpl(args);\n        }\n        args.fieldName = _fieldName;\n        args.value = _value;\n        return this.setImpl(args);\n    }\n    reset() {\n        this.store = {};\n    }\n    filter(key, predicate) {\n        const entity = this.store[key];\n        return Object.values(entity).filter(predicate);\n    }\n    find(key, predicate) {\n        const entity = this.store[key];\n        return Object.values(entity).find(predicate);\n    }\n    getImpl(args) {\n        const { typeName, key, fieldName, fieldArgs, defaultValue } = args;\n        if (!fieldName) {\n            if (defaultValue !== undefined && !isRecord(defaultValue)) {\n                throw new Error('`defaultValue` should be an object');\n            }\n            let valuesToInsert = defaultValue || {};\n            if (key) {\n                valuesToInsert = { ...valuesToInsert, ...makeRef(typeName, key) };\n            }\n            return this.insert(typeName, valuesToInsert, true);\n        }\n        assertIsDefined(key, 'key argument should be given when fieldName is given');\n        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n        if (this.store[typeName] === undefined ||\n            this.store[typeName][key] === undefined ||\n            this.store[typeName][key][fieldNameInStore] === undefined) {\n            let value;\n            if (defaultValue !== undefined) {\n                value = defaultValue;\n            }\n            else if (this.isKeyField(typeName, fieldName)) {\n                value = key;\n            }\n            else {\n                value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {\n                    // if we get a key field in the mix we don't care\n                    if (this.isKeyField(typeName, otherFieldName))\n                        return;\n                    this.set({ typeName, key, fieldName: otherFieldName, value: otherValue, noOverride: true });\n                });\n            }\n            this.set({ typeName, key, fieldName, fieldArgs, value, noOverride: true });\n        }\n        return this.store[typeName][key][fieldNameInStore];\n    }\n    setImpl(args) {\n        const { typeName, key, fieldName, fieldArgs, noOverride } = args;\n        let { value } = args;\n        if (isMockList(value)) {\n            value = deepResolveMockList(value);\n        }\n        if (this.store[typeName] === undefined) {\n            this.store[typeName] = {};\n        }\n        if (this.store[typeName][key] === undefined) {\n            this.store[typeName][key] = {};\n        }\n        if (!fieldName) {\n            if (!isRecord(value)) {\n                throw new Error('When no `fieldName` is provided, `value` should be a record.');\n            }\n            for (const fieldName in value) {\n                this.setImpl({\n                    typeName,\n                    key,\n                    fieldName,\n                    value: value[fieldName],\n                    noOverride,\n                });\n            }\n            return;\n        }\n        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n        if (this.isKeyField(typeName, fieldName) && value !== key) {\n            throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);\n        }\n        // if already set and we don't override\n        if (this.store[typeName][key][fieldNameInStore] !== undefined && noOverride) {\n            return;\n        }\n        const fieldType = this.getFieldType(typeName, fieldName);\n        const currentValue = this.store[typeName][key][fieldNameInStore];\n        let valueToStore;\n        try {\n            valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName, values) => this.insert(typeName, values, noOverride));\n        }\n        catch (e) {\n            throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);\n        }\n        this.store[typeName][key] = {\n            ...this.store[typeName][key],\n            [fieldNameInStore]: valueToStore,\n        };\n    }\n    normalizeValueToStore(fieldType, value, currentValue, onInsertType) {\n        const fieldTypeName = fieldType.toString();\n        if (value === null) {\n            if (!isNullableType(fieldType)) {\n                throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);\n            }\n            return null;\n        }\n        const nullableFieldType = getNullableType(fieldType);\n        if (value === undefined)\n            return this.generateValueFromType(nullableFieldType);\n        // deal with nesting insert\n        if (isCompositeType(nullableFieldType)) {\n            if (!isRecord(value))\n                throw new Error(`should be an object or null or undefined. Received ${value}`);\n            let joinedTypeName;\n            if (isAbstractType(nullableFieldType)) {\n                if (isRef(value)) {\n                    joinedTypeName = value.$ref.typeName;\n                }\n                else {\n                    if (typeof value['__typename'] !== 'string') {\n                        throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);\n                    }\n                    joinedTypeName = value['__typename'];\n                }\n            }\n            else {\n                joinedTypeName = nullableFieldType.name;\n            }\n            return onInsertType(joinedTypeName, isRef(currentValue) ? { ...currentValue, ...value } : value);\n        }\n        if (isListType(nullableFieldType)) {\n            if (!Array.isArray(value))\n                throw new Error(`should be an array or null or undefined. Received ${value}`);\n            return value.map((v, index) => {\n                return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === 'object' && currentValue != null && currentValue[index] ? currentValue : undefined, onInsertType);\n            });\n        }\n        return value;\n    }\n    insert(typeName, values, noOverride) {\n        const keyFieldName = this.getKeyFieldName(typeName);\n        let key;\n        // when we generate a key for the type, we might produce\n        // other associated values with it\n        // We keep track of them and we'll insert them, with propririty\n        // for the ones that we areasked to insert\n        const otherValues = {};\n        if (isRef(values)) {\n            key = values.$ref.key;\n        }\n        else if (keyFieldName && keyFieldName in values) {\n            key = values[keyFieldName];\n        }\n        else {\n            key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {\n                otherValues[otherFieldName] = otherFieldValue;\n            });\n        }\n        const toInsert = { ...otherValues, ...values };\n        for (const fieldName in toInsert) {\n            if (fieldName === '$ref')\n                continue;\n            if (fieldName === '__typename')\n                continue;\n            this.set({\n                typeName,\n                key,\n                fieldName,\n                value: toInsert[fieldName],\n                noOverride,\n            });\n        }\n        if (this.store[typeName] === undefined) {\n            this.store[typeName] = {};\n        }\n        if (this.store[typeName][key] === undefined) {\n            this.store[typeName][key] = {};\n        }\n        return makeRef(typeName, key);\n    }\n    generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {\n        const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);\n        if (mockedValue !== undefined)\n            return mockedValue;\n        const fieldType = this.getFieldType(typeName, fieldName);\n        return this.generateValueFromType(fieldType);\n    }\n    generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {\n        let value;\n        const mock = this.mocks ? this.mocks[typeName] : undefined;\n        if (mock) {\n            if (typeof mock === 'function') {\n                const values = mock();\n                if (typeof values !== 'object' || values == null) {\n                    throw new Error(`Value returned by the mock for ${typeName} is not an object`);\n                }\n                for (const otherFieldName in values) {\n                    if (otherFieldName === fieldName)\n                        continue;\n                    if (typeof values[otherFieldName] === 'function')\n                        continue;\n                    onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);\n                }\n                value = values[fieldName];\n                if (typeof value === 'function')\n                    value = value();\n            }\n            else if (typeof mock === 'object' && mock != null && typeof mock[fieldName] === 'function') {\n                value = mock[fieldName]();\n            }\n        }\n        if (value !== undefined)\n            return value;\n        const type = this.getType(typeName);\n        // GraphQL 14 Compatibility\n        const interfaces = 'getInterfaces' in type ? type.getInterfaces() : [];\n        if (interfaces.length > 0) {\n            for (const interface_ of interfaces) {\n                if (value)\n                    break;\n                value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);\n            }\n        }\n        return value;\n    }\n    generateKeyForType(typeName, onOtherFieldsGenerated) {\n        const keyFieldName = this.getKeyFieldName(typeName);\n        if (!keyFieldName)\n            return uuidv4();\n        return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);\n    }\n    generateValueFromType(fieldType) {\n        const nullableType = getNullableType(fieldType);\n        if (isScalarType(nullableType)) {\n            const mockFn = this.mocks[nullableType.name];\n            if (typeof mockFn !== 'function')\n                throw new Error(`No mock defined for type \"${nullableType.name}\"`);\n            return mockFn();\n        }\n        else if (isEnumType(nullableType)) {\n            const mockFn = this.mocks[nullableType.name];\n            if (typeof mockFn === 'function')\n                return mockFn();\n            const values = nullableType.getValues().map(v => v.value);\n            return takeRandom(values);\n        }\n        else if (isObjectType(nullableType)) {\n            // this will create a new random ref\n            return this.insert(nullableType.name, {});\n        }\n        else if (isListType(nullableType)) {\n            return [...new Array(randomListLength())].map(() => this.generateValueFromType(nullableType.ofType));\n        }\n        else if (isAbstractType(nullableType)) {\n            const mock = this.mocks[nullableType.name];\n            let typeName;\n            let values = {};\n            if (!mock) {\n                typeName = takeRandom(this.schema.getPossibleTypes(nullableType).map(t => t.name));\n            }\n            else if (typeof mock === 'function') {\n                const mockRes = mock();\n                if (mockRes === null)\n                    return null;\n                if (!isRecord(mockRes)) {\n                    throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);\n                }\n                values = mockRes;\n                if (typeof values['__typename'] !== 'string') {\n                    throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n                }\n                typeName = values['__typename'];\n            }\n            else if (typeof mock === 'object' && mock != null && typeof mock['__typename'] === 'function') {\n                const mockRes = mock['__typename']();\n                if (typeof mockRes !== 'string')\n                    throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);\n                typeName = mockRes;\n            }\n            else {\n                throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n            }\n            const toInsert = {};\n            for (const fieldName in values) {\n                if (fieldName === '__typename')\n                    continue;\n                const fieldValue = values[fieldName];\n                toInsert[fieldName] = typeof fieldValue === 'function' ? fieldValue() : fieldValue;\n            }\n            return this.insert(typeName, toInsert);\n        }\n        else {\n            throw new Error(`${nullableType} not implemented`);\n        }\n    }\n    getFieldType(typeName, fieldName) {\n        if (fieldName === '__typename') {\n            return GraphQLString;\n        }\n        const type = this.getType(typeName);\n        const field = type.getFields()[fieldName];\n        if (!field) {\n            throw new Error(`${fieldName} does not exist on type ${typeName}`);\n        }\n        return field.type;\n    }\n    getType(typeName) {\n        const type = this.schema.getType(typeName);\n        if (!type || !(isObjectType(type) || isInterfaceType(type))) {\n            throw new Error(`${typeName} does not exist on schema or is not an object or interface`);\n        }\n        return type;\n    }\n    isKeyField(typeName, fieldName) {\n        return this.getKeyFieldName(typeName) === fieldName;\n    }\n    getKeyFieldName(typeName) {\n        var _a;\n        const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;\n        if (typePolicyKeyField !== undefined) {\n            if (typePolicyKeyField === false)\n                return null;\n            return typePolicyKeyField;\n        }\n        // How about common key field names?\n        const gqlType = this.getType(typeName);\n        for (const fieldName in gqlType.getFields()) {\n            if (defaultKeyFieldNames.includes(fieldName)) {\n                return fieldName;\n            }\n        }\n        return null;\n    }\n}\nconst getFieldNameInStore = (fieldName, fieldArgs) => {\n    if (!fieldArgs)\n        return fieldName;\n    if (typeof fieldArgs === 'string') {\n        return `${fieldName}:${fieldArgs}`;\n    }\n    // empty args\n    if (Object.keys(fieldArgs).length === 0) {\n        return fieldName;\n    }\n    return `${fieldName}:${stringify(fieldArgs)}`;\n};\nfunction assertIsDefined(value, message) {\n    if (value !== undefined && value !== null) {\n        return;\n    }\n    throw new Error(process.env['NODE_ENV'] === 'production' ? 'Invariant failed:' : `Invariant failed: ${message || ''}`);\n}\n/**\n * Will create `MockStore` for the given `schema`.\n *\n * A `MockStore` will generate mock values for the given schem when queried.\n *\n * It will stores generated mocks, so that, provided with same arguments\n * the returned values will be the same.\n *\n * Its API also allows to modify the stored values.\n *\n * Basic example:\n * ```ts\n * store.get('User', 1, 'name');\n * // > \"Hello World\"\n * store.set('User', 1, 'name', 'Alexandre');\n * store.get('User', 1, 'name');\n * // > \"Alexandre\"\n * ```\n *\n * The storage key will correspond to the \"key field\"\n * of the type. Field with name `id` or `_id` will be\n * by default considered as the key field for the type.\n * However, use `typePolicies` to precise the field to use\n * as key.\n */\nfunction createMockStore(options) {\n    return new MockStore(options);\n}\n\n// todo: add option to preserve resolver\n/**\n * Given a `schema` and a `MockStore`, returns an executable schema that\n * will use the provided `MockStore` to execute queries.\n *\n * ```ts\n * const schema = buildSchema(`\n *  type User {\n *    id: ID!\n *    name: String!\n *  }\n *  type Query {\n *    me: User!\n *  }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({ schema, store });\n * ```\n *\n *\n * If a `resolvers` parameter is passed, the query execution will use\n * the provided `resolvers` if, one exists, instead of the default mock\n * resolver.\n *\n *\n * ```ts\n * const schema = buildSchema(`\n *   type User {\n *     id: ID!\n *     name: String!\n *   }\n *   type Query {\n *     me: User!\n *   }\n *   type Mutation {\n *     setMyName(newName: String!): User!\n *   }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({\n *   schema,\n *   store,\n *   resolvers: {\n *     Mutation: {\n *       setMyName: (_, { newName }) => {\n *          const ref = store.get('Query', 'ROOT', 'viewer');\n *          store.set(ref, 'name', newName);\n *          return ref;\n *       }\n *     }\n *   }\n *  });\n * ```\n *\n *\n * `Query` and `Mutation` type will use `key` `'ROOT'`.\n */\nfunction addMocksToSchema({ schema, store: maybeStore, mocks, typePolicies, resolvers: resolversOrFnResolvers, preserveResolvers = false, }) {\n    if (!schema) {\n        throw new Error('Must provide schema to mock');\n    }\n    if (!isSchema(schema)) {\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n    }\n    if (mocks && !isObject(mocks)) {\n        throw new Error('mocks must be of type Object');\n    }\n    const store = maybeStore ||\n        createMockStore({\n            schema,\n            mocks,\n            typePolicies,\n        });\n    const resolvers = typeof resolversOrFnResolvers === 'function' ? resolversOrFnResolvers(store) : resolversOrFnResolvers;\n    const mockResolver = (source, args, contex, info) => {\n        const defaultResolvedValue = defaultFieldResolver(source, args, contex, info);\n        // priority to default resolved value\n        if (defaultResolvedValue !== undefined)\n            return defaultResolvedValue;\n        if (isRef(source)) {\n            return store.get({\n                typeName: source.$ref.typeName,\n                key: source.$ref.key,\n                fieldName: info.fieldName,\n                fieldArgs: args,\n            });\n        }\n        // we have to handle the root mutation, root query and root subscription types\n        // differently, because no resolver is called at the root\n        if (isRootType(info.parentType, info.schema)) {\n            return store.get({\n                typeName: info.parentType.name,\n                key: 'ROOT',\n                fieldName: info.fieldName,\n                fieldArgs: args,\n            });\n        }\n        if (defaultResolvedValue === undefined) {\n            const mockFn = mocks === null || mocks === void 0 ? void 0 : mocks[info.returnType.toString()];\n            if (typeof mockFn === 'function') {\n                return mockFn(source, args, contex, info);\n            }\n        }\n        return undefined;\n    };\n    const typeResolver = data => {\n        if (isRef(data)) {\n            return data.$ref.typeName;\n        }\n    };\n    const mockSubscriber = () => ({\n        [Symbol.asyncIterator]() {\n            return {\n                async next() {\n                    return {\n                        done: true,\n                        value: {},\n                    };\n                },\n            };\n        },\n    });\n    const schemaWithMocks = mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: fieldConfig => {\n            const newFieldConfig = {\n                ...fieldConfig,\n            };\n            const oldResolver = fieldConfig.resolve;\n            if (!preserveResolvers || !oldResolver) {\n                newFieldConfig.resolve = mockResolver;\n            }\n            else {\n                newFieldConfig.resolve = async (rootObject, args, context, info) => {\n                    const [mockedValue, resolvedValue] = await Promise.all([\n                        mockResolver(rootObject, args, context, info),\n                        oldResolver(rootObject, args, context, info),\n                    ]);\n                    // In case we couldn't mock\n                    if (mockedValue instanceof Error) {\n                        // only if value was not resolved, populate the error.\n                        if (undefined === resolvedValue) {\n                            throw mockedValue;\n                        }\n                        return resolvedValue;\n                    }\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                    }\n                    if (isObject(mockedValue) && isObject(resolvedValue)) {\n                        // Object.assign() won't do here, as we need to all properties, including\n                        // the non-enumerable ones and defined using Object.defineProperty\n                        const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n                    }\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                };\n            }\n            const fieldSubscriber = fieldConfig.subscribe;\n            if (!preserveResolvers || !fieldSubscriber) {\n                newFieldConfig.subscribe = mockSubscriber;\n            }\n            else {\n                newFieldConfig.subscribe = async (rootObject, args, context, info) => {\n                    const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([\n                        mockSubscriber(),\n                        fieldSubscriber(rootObject, args, context, info),\n                    ]);\n                    return oldAsyncIterable || mockAsyncIterable;\n                };\n            }\n            return newFieldConfig;\n        },\n        [MapperKind.ABSTRACT_TYPE]: type => {\n            if (preserveResolvers && type.resolveType != null && type.resolveType.length) {\n                return;\n            }\n            if (isUnionType(type)) {\n                return new GraphQLUnionType({\n                    ...type.toConfig(),\n                    resolveType: typeResolver,\n                });\n            }\n            else {\n                return new GraphQLInterfaceType({\n                    ...type.toConfig(),\n                    resolveType: typeResolver,\n                });\n            }\n        },\n    });\n    return resolvers ? addResolversToSchema(schemaWithMocks, resolvers) : schemaWithMocks;\n}\nconst isRootType = (type, schema) => {\n    const rootTypeNames = getRootTypeNames(schema);\n    return rootTypeNames.has(type.name);\n};\n\n/**\n * A convenience wrapper on top of addMocksToSchema. It adds your mock resolvers\n * to your schema and returns a client that will correctly execute your query with\n * variables. Note: when executing queries from the returned server, context and\n * root will both equal `{}`.\n * @param schema The schema to which to add mocks. This can also be a set of type\n * definitions instead.\n * @param mocks The mocks to add to the schema.\n * @param preserveResolvers Set to `true` to prevent existing resolvers from being\n * overwritten to provide mock data. This can be used to mock some parts of the\n * server and not others.\n */\nfunction mockServer(schema, mocks, preserveResolvers = false) {\n    const mockedSchema = addMocksToSchema({\n        schema: isSchema(schema)\n            ? schema\n            : makeExecutableSchema({\n                typeDefs: schema,\n            }),\n        mocks,\n        preserveResolvers,\n    });\n    return {\n        query: (query, vars) => graphql({\n            schema: mockedSchema,\n            source: query,\n            rootValue: {},\n            contextValue: {},\n            variableValues: vars,\n        }),\n    };\n}\n\nexport { MockList, MockStore, addMocksToSchema, assertIsRef, createMockStore, deepResolveMockList, defaultMocks, isMockList, isRecord, isRef, mockServer };\n"]},"metadata":{},"sourceType":"module"}